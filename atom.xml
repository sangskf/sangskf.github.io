<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[见课就上的小婊砸]]></title>
  <link href="http://books.sangkf.cn/atom.xml" rel="self"/>
  <link href="http://books.sangkf.cn/"/>
  <updated>2019-02-23T16:32:31+08:00</updated>
  <id>http://books.sangkf.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Github Pages 搭建笔记]]></title>
    <link href="http://books.sangkf.cn/15509007032026.html"/>
    <updated>2019-02-23T13:45:03+08:00</updated>
    <id>http://books.sangkf.cn/15509007032026.html</id>
    <content type="html"><![CDATA[
<p>记录GitHub Page搭建过程</p>

<h2 id="toc_0">Github Pages</h2>

<p>前往<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2F">GitHub</a>并且创建一个新的repository，命名规则是：username.github.io（username是Github用户名，蓝色线部分相同）<br/>
<span id="more"></span><!-- more --><br/>
<img src="media/15509007032026/15509106715104.jpg" alt=""/></p>

<p>blog-github-create</p>

<p>clone项目到本地</p>

<pre><code class="language-text">git clone https://github.com/username/username.github.io

</code></pre>

<p>制作Hello World 页面</p>

<pre><code class="language-text">cd username.github.io
echo &quot;Hello World&quot; &gt; index.html

</code></pre>

<p>提交到GitHub，需要配置SSH免密码登录</p>

<pre><code class="language-text">git add --all
git commit -m &quot;Initial commit&quot;
git push -u origin master

</code></pre>

<p>访问：<a href="https://link.jianshu.com?t=https%3A%2F%2Fusername">https://username</a>（GitHub用户名）<a href="https://link.jianshu.com?t=http%3A%2F%2F.github.io">.github.io</a> ，可以看见个人主页。</p>

<h2 id="toc_1">Jekyll</h2>

<p>Jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。</p>

<p><strong>安装过程</strong></p>

<p>1.安装Ruby</p>

<p>Mac有默认的Ruby环境，根据如下命令确认是否正常工作及版本</p>

<pre><code class="language-text">ruby -v

</code></pre>

<p>2.安装Jekyll</p>

<pre><code class="language-text">sudo gem install jekyll bundler

</code></pre>

<p>3.<strong>使用模板安装直接进入下一节，如果不使用模板</strong>，可以进行如下方法安装</p>

<pre><code class="language-text">jekyll new my-awesome-site
cd my-awesome-site
cp -R * path/username.github.io/

</code></pre>

<p>注：path/username.github.io 为GitHub本地目录</p>

<p>4.开启Jekyll环境</p>

<p>在path/username.github.io目录下，执行</p>

<pre><code class="language-text">bundle exec jekyll serve

</code></pre>

<p>5.本地调试</p>

<p>通过<a href="https://link.jianshu.com?t=http%3A%2F%2Flocalhost%3A4000">http://localhost:4000</a> ，访问页面。</p>

<p><img src="media/15509007032026/15509107259701.jpg" alt=""/></p>

<p>blog-jekyll-new</p>

<h2 id="toc_2">Jekyll 模板</h2>

<p>替换Jekyll模板，根据知乎黄玄回答找到<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2FBlackrockDigital%2Fstartbootstrap-clean-blog-jekyll">startbootstrap-clean-blog-jekyll</a>模板BlackrockDigital，其他模板根据说明进行安装。</p>

<p>效果页面可以访问： <a href="https://link.jianshu.com?t=http%3A%2F%2Fblackrockdigital.github.io%2Fstartbootstrap-clean-blog-jekyll%2F">Clean Blog</a></p>

<p><img src="//upload-images.jianshu.io/upload_images/725534-11bc97cf319b407e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""/></p>

<p>blog-github-clean-blog</p>

<p><strong>安装过程</strong></p>

<p>安装过程可以使用两种方式。</p>

<ol>
<li>命令方式：详见startbootstrap-clean-blog-jekyll的GitHub页面</li>
<li>覆盖方式：本文采用方式，详细说明如下</li>
</ol>

<p>下载或者Clone项目startbootstrap-clean-blog-jekyll到本地，覆盖到GitHub.io的本地工程。</p>

<p>修改 _config.yml 文件，下述为需要修改部分，其他保持不变即可。</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>title</td>
<td>名称</td>
</tr>
<tr>
<td>email</td>
<td>通讯方式</td>
</tr>
<tr>
<td>description</td>
<td>描述</td>
</tr>
<tr>
<td>github_username</td>
<td>GitHub用户名</td>
</tr>
<tr>
<td>baserul</td>
<td>二级路径，可以为&#39;&#39;</td>
</tr>
<tr>
<td>url</td>
<td>GitHub.io的URL路径</td>
</tr>
</tbody>
</table>

<p>用过命令</p>

<pre><code class="language-text">bundle exec jekyll serve

</code></pre>

<p>启动本地环境，通过 <a href="https://link.jianshu.com?t=http%3A%2F%2Flocalhost%3A4000">http://localhost:4000</a> 访问页面。变动提交到GitHub后，可以在 <a href="https://link.jianshu.com?t=https%3A%2F%2Fusername">https://username</a>（GitHub用户名）<a href="https://link.jianshu.com?t=http%3A%2F%2F.github.io">.github.io</a> 看到修改变化。</p>

<p><strong>创建文档</strong></p>

<p>在_post文件下，新建md文件，文件书写格式如下</p>

<pre><code class="language-text">---
layout: post
title:  &quot;标题&quot;
subtitle: &quot;副标题&quot;
date:   2018-01-08 00:00:01
background: &#39;/img/posts/01.jpg&#39;
---

</code></pre>

<p>jekyll可以自动检测并识别文档，并添加到博客首页中。</p>

<h2 id="toc_3">域名</h2>

<p><strong>GitHub部分配置</strong></p>

<p>在GitHub工程根目录添加CNAME文件，如下图所示。域名部分仅为域名名称，不添加http等关键字。</p>

<p><img src="//upload-images.jianshu.io/upload_images/725534-19049ac8c2014c95.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""/></p>

<p>blog-github-cname</p>

<p><strong>域名提供商部分</strong></p>

<p>本文使用的是阿里云提供的云解析DNS，添加记录如下图所示。</p>

<p><img src="//upload-images.jianshu.io/upload_images/725534-c5dfc17ab81c9f4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""/></p>

<p>blog-aliyun-cname</p>

<p>记录A部分，添加IP地址：192.30.252.153和192.30.252.154。（IP地址为GitHub提供，详见<a href="https://link.jianshu.com?t=https%3A%2F%2Fhelp.github.com%2Farticles%2Fsetting-up-an-apex-domain%2F">setting-up-an-apex-domain</a>）</p>

<p>记录CNAME部分，添加username（GitHub用户名）<a href="https://link.jianshu.com?t=http%3A%2F%2F.github.io">.github.io</a>，主机记录为www。</p>

<p>10分钟后访问域名，查看是否生效。</p>

<h2 id="toc_4">七牛云</h2>

<p>Jekyll的图片可以使用相对路径，图片放在img文件夹下，在markdown文本中，通过如下方式显示图片。</p>

<pre><code class="language-text">![a](/img/some-name.jpg)

</code></pre>

<p>同样可以使用七牛云存储，存放图片，个人博客的访问量一般在免费额度范围内。结合图床工具，可以方便的把本地图片上传到七牛云中。</p>

<p>申请账号后，在个人中心-密钥管理中，查看<strong>Access Key</strong>和<strong>Secret Key</strong></p>

<p><img src="//upload-images.jianshu.io/upload_images/725534-d6b1ea6a9150a70b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""/></p>

<p>blog-qiniu-new</p>

<p>申请存储空间，本文存储空间为mweb（即为BucketName），申请成功后管理界面如下：</p>

<p><img src="//upload-images.jianshu.io/upload_images/725534-28ec2c27974834b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""/></p>

<p>blog-qiniu-bucket</p>

<p>区域分华东、华北、华南和北美，需要记录，后续使用。</p>

<p>测试域名需要记录，如果配置了CDN加速可以使用正式域名。</p>

<h2 id="toc_5">MWeb</h2>

<p>MWeb是一款Markdown笔记工具，主页：<a href="https://link.jianshu.com?t=http%3A%2F%2Fzh.mweb.im">http://zh.mweb.im</a> 。如果使用其他Markdown工具，可以使用<a href="https://link.jianshu.com?t=http%3A%2F%2Fjiantuku.com%2F">极简图床</a>或者类似工具上传图片。</p>

<p>在MWeb-Preferences-Publishing中配置七牛插件，把本地文件上传到七牛中。</p>

<p><img src="//upload-images.jianshu.io/upload_images/725534-a428747fe7fcbd8d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""/></p>

<p>blog-qiniu-mweb</p>

<p>填写说明如下：</p>

<table>
<thead>
<tr>
<th style="text-align: left">填写项</th>
<th style="text-align: left">填写内容</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Name</td>
<td style="text-align: left">个人喜好填写</td>
</tr>
<tr>
<td style="text-align: left">API URL</td>
<td style="text-align: left">本文以华北为例，其他参看备注</td>
</tr>
<tr>
<td style="text-align: left">Bucket Name</td>
<td style="text-align: left">存储空间名称</td>
</tr>
<tr>
<td style="text-align: left">Access Key</td>
<td style="text-align: left">上一小节提到</td>
</tr>
<tr>
<td style="text-align: left">Secret Key</td>
<td style="text-align: left">上一小节提到</td>
</tr>
<tr>
<td style="text-align: left">Image URL Prefix</td>
<td style="text-align: left">测试域名或者正式域名地址</td>
</tr>
<tr>
<td style="text-align: left">Image URL Suffix</td>
<td style="text-align: left">可以不填写</td>
</tr>
</tbody>
</table>

<p>注： <a href="https://link.jianshu.com?t=https%3A%2F%2Fdeveloper.qiniu.com%2Fkodo%2Fmanual%2F1671%2Fregion-endpoint">存储区域上传域名</a></p>

<p>配置成功后，通过工具栏按钮选取本地文件，生成Markdown图片标签的同时上传到七牛云。</p>

<h2 id="toc_6">参考资源</h2>

<ul>
<li><a href="https://link.jianshu.com?t=https%3A%2F%2Fpages.github.com%2F">GitHub Page</a></li>
<li><a href="https://link.jianshu.com?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20223939">有哪些简洁明快的 Jekyll 模板</a></li>
<li><a href="https://link.jianshu.com?t=https%3A%2F%2Fjekyllrb.com%2F">Jekyll Page</a></li>
<li><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2FBlackrockDigital%2Fstartbootstrap-clean-blog-jekyll">startbootstrap-clean-blog-jekyll</a></li>
<li><a href="https://www.jianshu.com/p/88c9e72978b4">用Jekyll搭建的Github Pages个人博客</a></li>
<li><a href="https://link.jianshu.com?t=http%3A%2F%2Fplayingfingers.com%2F2016%2F03%2F26%2Fbuild-a-blog%2F">Github Pages + Jekyll 独立博客一小时快速搭建&amp;上线指南</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Gatsby 创建一个博客]]></title>
    <link href="http://books.sangkf.cn/15508995579898.html"/>
    <updated>2019-02-23T13:25:57+08:00</updated>
    <id>http://books.sangkf.cn/15508995579898.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>转载 <a href="https://blog.csdn.net/itheima_wujie/article/details/78862801#">https://blog.csdn.net/itheima_wujie/article/details/78862801#</a></p>
</blockquote>

<p>Gatsby 是一个令人难以置信的静态站点生成器，它允许使用React作为渲染引擎引擎来搭建一个静态站点，它真正具有现代web应用程序所期望的所有优点。它通过在构建时通过服务器端渲染将动态的 React 组件呈现为静态 HTML 内容。这意味着您的用户可以获得静态站点的所有好处，比如不使用 JavaScript、搜索引擎友好性、非常快的加载速度等等，也并没有失去现代 web 所期望的活力和交互性。一旦呈现为静态 HTML，客户端站点的 React 和 JavaScript 会接管它并添加动态的内容。 Gatsby 最近发布了v1.0.0，推出了很多新特性。包括(但不限于)使用GraphQL创建内容查询的能力，与各种cms集成——包括 WordPress、Contentful、Drupal 等等。还有基于路由的代码分布使得用户体验更佳。在这篇文章中，我们将深入探讨 Gatsby 和一些新特性，并创建一个静态博客。让我们开始吧！<br/>
<span id="more"></span><!-- more --><br/>
起步<br/>
安装cli</p>

<pre><code class="language-javascript">npm install -g gatsby-cli
</code></pre>

<p>Gatsby 带有一个很棒的CLI(命令行接口)，它包含了一个工作站点的搭建功能，以及帮助开发该站点的命令。</p>

<pre><code class="language-javascript">gatsby new personal-blog &amp;&amp; cd $_
</code></pre>

<p>该命令将创建文件夹personal-blog，然后进入该目录。现在一个可供开发的环境已经搭建好了。Gatsby 的 CLI包含了许多常见的开发特性，比如gatsby build (构建一个生产、静态生成的项目版本)、gatsby develop(启动一个热加载的web开发服务器)等等。</p>

<p>我们现在可以开始在这个网站上进行真正的开发，并且创建一个功能齐全的，现代的博客。您通常希望使用gatsby develop 来启动本地开发服务器，以验证我们在步骤中所完成的功能。</p>

<p>添加必要的插件<br/>
Gatsby 支持使用丰富的插件，很多非常有用的插件都是为了完成普通任务而编写的。插件可以分为三个主要类别:功能( functional )插件、源( source )插件和转换器( transformer )插件。</p>

<p>功能插件<br/>
功能插件用来实现某些功能（离线支持，生成一个站点地图等等）或者他们扩展了 Gatsby 的 webpack 配置，增加了对 Typescript、Sass 等的支持。 对于这个特定的博客文章，我们想要一个单页面应用的感觉(没有页面重载)，以及在head 标签中动态更改title标签的能力。正如所提到的，Gatsby 插件的生态系统是丰富的、充满活力的，而且还在不断增长，所以通常一个已经存在的插件，可以解决你想要解决的特定问题。为了解决我们想要的这个博客的功能，我们将使用以下插件：</p>

<p>gatsby-plugin-catch-links<br/>
实现了历史 pushState API, 不需要页面重载就可以导航到博客的不同页面<br/>
gatsby-plugin-react-helmet<br/>
react-helmet 是一种允许修改head标签的工具 Gatsby 静态地呈现这些头部标签的变化<br/>
使用下面的命令：</p>

<pre><code class="language-javascript">yarn add gatsby-plugin-catch-links gatsby-plugin-react-helmet
</code></pre>

<p>我们用的是yarn，但是使用 npm 也很容易：npm i --save [deps]。 在安装了这些功能插件之后，我们将编辑gatsby-config.js。Gatsby 在构建时加载指定插件的公开功能。</p>

<pre><code class="language-javascript">module.exports = {
  siteMetadata: {
    title: `Your Name - Blog`,
    author: `Your Name`,
  },
  plugins: [
    &#39;gatsby-plugin-catch-links&#39;,
    &#39;gatsby-plugin-react-helmet&#39;,
  ],
}
</code></pre>

<p>除了使用yarn install 和编辑配置文件之外，我们现在还可以编辑网站 head 标签，同时还可以实现一个无需重新加载的单页面应用，。现在，让我们通过实现一个源插件来增强基本功能，该插件可以实现从本地文件系统加载博客文章。</p>

<p>源插件<br/>
源插件创建节点，然后通过一个转换器插件将其转换为可用的格式。例如，一个典型的工作流通常需要使用gatsby-source-filesystem它从磁盘上加载文件，例如 Markdown 文件，然后指定一个 Markdown 转换器将 Markdown 转换成 HTML 。 因为博客的大部分内容都使用 Markdown 格式，让我们添加gatsby-source-filesystem，与我们之前的步骤类似，我们将安装插件，然后将其注入到我们的 gatsby-config.js,像这样：</p>

<pre><code class="language-javascript">yarn add gatsby-source-filesystem
</code></pre>

<pre><code class="language-javascript">module.exports = {
  // previous configuration
  plugins: [
    &#39;gatsby-plugin-catch-links&#39;,
    &#39;gatsby-plugin-react-helmet&#39;,
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        path: `${__dirname}/src/pages`,
        name: &#39;pages&#39;,
      },
    }
  ]
}
</code></pre>

<p>有一点解释在这里会很有帮助！一个options 对象可以传递给一个插件，我们正在传递文件系统路径(也就是我们的 Markdown 文件将被定位的位置)，然后是源文件的名称。既然 Gatsby 知道了我们的源文件，我们就可以开始应用一些有用的转换器来将这些文件转换为可用的数据！</p>

<p>转换器插件<br/>
正如前面提到的，转换器插件采用了一些底层的数据格式，这种格式在当前的表单中是不可用的（Markdown，json，yaml等），我们可以用 GraphQL 查询把它转换成 Gatsby 能够理解的格式。filesystem 源插件将从我们的文件系统中加载文件节点(如 Markdown )，然后 Markdown 转换器将接管并转换为可用的 HTML 。 我们将只使用一个转换器插件(用于 Markdown )，所以让我们安装它。</p>

<p>gatsby-transformer-remark<br/>
使用 remark Markdown解析器进行转换磁盘上的 md 文件为 HTML 。 此外，该转换器还可以选择使用插件来进一步扩展功能，例如通过 gatsby-remark-prismjs来添加语法高亮，通过 gatsby-remark-copy-linked-files 复制在 markdown 中指定的相关文件，通过 gatsby-remark-images 压缩图像，并使用 srcset 添加响应性图像等等。<br/>
这个过程现在应该很熟悉了，安装之后再添加到配置中。</p>

<pre><code class="language-javascript">yarn add gatsby-transformer-remark
</code></pre>

<p>编辑 gatsby-config.js</p>

<pre><code class="language-javascript">module.exports = {
  // previous setup
    plugins: [
    &#39;gatsby-plugin-catch-links&#39;,
    &#39;gatsby-plugin-react-helmet&#39;,
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        path: `${__dirname}/src/pages`,
        name: &#39;pages&#39;,
      },
    },
    {
      resolve: &#39;gatsby-transformer-remark&#39;,
      options: {
        plugins: [] // just in case those previously mentioned remark plugins sound cool :)
      }
    },
  ]
};
</code></pre>

<p>唷!看起来像有很多设置，但是这些插件将会让 Gatsby 变得强大，并给我们一个难以置信的(但相对简单的！)开发环境。我们还需要一个更简单的步骤。我们只需创建一个 Markdown 文件，它将包含我们的第一个博客文章的内容。让我们开始吧！</p>

<p>书写第一个 Markdown 文章<br/>
我们先前配置的gatsby-source-filesystem 插件希望我们的内容能够放在 src/pages。Gatsby 在命名规范方面并没有什么规定，但博客文章的一个典型做法是给文件夹起个类似MM-DD-YYYY-title的名字，例如07-12-2017-hello-world。让我们创建一个文件夹src/pages/07-12-2017-getting-started，并把 index.md 放进去。 这个Markdown文件的内容将是我们的博客文章，使用 Markdown 编写(当然！)这是它该有的样子：</p>

<pre><code class="language-txt">---
path: &quot;/hello-world&quot;
date: &quot;2017-07-12T17:12:33.962Z&quot;
title: &quot;My First Gatsby Post&quot;
---
</code></pre>

<p>Oooooh-weeee, my first blog post!<br/>
被包含在横线里的部分是什么？这就是所谓的frontmatter，而这部分内容可以供 React 组件使用（例如path，date，title等等）你可以添加其他的数据，因此，你可以自由地进行实验，找到必要的信息，以实现一个理想的博客系统，供你使用。重要的一点是，当我们动态创建页面来指定页面时，path将会被用到识别路由。在这个例子里<a href="http://localhost:8000/hello-world%E5%B0%86%E6%98%AF%E8%BF%99%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%82">http://localhost:8000/hello-world将是这个文件的路径。</a> 现在我们已经创建了一个带有frontmatter和一些内容的博客文章，我们可以开始编写一些可以显示这些数据的 React 组件。</p>

<p>创建 React 模板<br/>
当 Gatsby 支持服务器端渲染(对字符串)的 React 组件时，我们可以使用 React 编写我们的模板（ 也可以使用Preact ）。 我们创建一个 src/templates/blog-post.js文件（请创建一个src/templates文件夹）</p>

<pre><code class="language-javascript">import React from &#39;react&#39;;
import Helmet from &#39;react-helmet&#39;;
 
// import &#39;../css/blog-post.css&#39;; // make it pretty!
 
export default function Template({
  data // this prop will be injected by the GraphQL query we&#39;ll write in a bit
}) {
  const { markdownRemark: post } = data; // data.markdownRemark holds our post data
  return (
    &lt;div className=&quot;blog-post-container&quot;&gt;
      &lt;Helmet title={`Your Blog Name - ${post.frontmatter.title}`} /&gt;
      &lt;div className=&quot;blog-post&quot;&gt;
        &lt;h1&gt;{post.frontmatter.title}&lt;/h1&gt;
        &lt;div className=&quot;blog-post-content&quot; dangerouslySetInnerHTML={{ __html: post.html }} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<p>哇,整洁!这个 React 组件将被呈现为静态 HTML 字符串，这将成为我们博客导航的基础。 在这一点上，有一种合理的混乱和魔法会发生，特别是在 props 属性注入的时候。什么是markdownRemark？这个数据支持从何而来？这些问题，让我们通过编写一个GraphQL查询来回答，以便为我们的组件添加内容。</p>

<p>编写一个 GraphQL 查询<br/>
在 Template 声明下面，我们将添加一个 GraphQL 查询。这是 Gatsby 的一个非常强大的工具。这让我们可以很简单地挑选出我们想要展示给我们的博客文章的数据片段。我们的查询选择的每个数据都将通过我们前面指定的数据属性注入。</p>

<pre><code class="language-javascript">import React from &#39;react&#39;;
import Helmet from &#39;react-helmet&#39;;
 
// import &#39;../css/blog-post.css&#39;;
 
export default function Template({
  data
}) {
  const { markdownRemark: post } = data;
  return (
    &lt;div className=&quot;blog-post-container&quot;&gt;
      &lt;Helmet title={`Your Blog Name - ${post.frontmatter.title}`} /&gt;
      &lt;div className=&quot;blog-post&quot;&gt;
        &lt;h1&gt;{post.frontmatter.title}&lt;/h1&gt;
        &lt;div className=&quot;blog-post-content&quot; dangerouslySetInnerHTML={{ __html: post.html }} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
 
export const pageQuery = graphql`
  query BlogPostByPath($path: String!) {
    markdownRemark(frontmatter: { path: { eq: $path } }) {
      html
      frontmatter {
        date(formatString: &quot;MMMM DD, YYYY&quot;)
        path
        title
      }
    }
  }
`;
</code></pre>

<p>如果你对 GraphQL 不熟悉，这看起来可能有点让人困惑，但是我们可以把它们分解一下。</p>

<p>备注: 学习更多关于 GraphQL 知识, 请参考 excellent resource</p>

<p>查询名称 BlogPostByPath (注意:这些查询名称必须是唯一的！)将被注入当前的路径，例如我们正在查看的特定的博客文章。这条路径将在查询中作为$path可用。比如，如果我们查看之前创建的博客文章，将从数据中提取的文件的路径将是 /hello-world。 通过注入的属性获得 data，在 GraphQL 查询中被命名为markdownRemark 。我们通过 GraphQL 查询获取的每个属性都可以在markdownRemark 下面找到。例如,访问转换后的 HTML 我们会通过 data.markdownRemark.html 去拿到数据。 当然，我们的数据结构是在我们的Markdown文件开始时提供的frontmatter。我们定义的每个键都可以被注入到查询中。 现在，我们已经安装了一堆插件来从磁盘加载文件，将 Markdown 转换为HTML。我们有一个单独的 Markdown 文件，它将作为一个博客发布。最后，我们有一个针对博客文章的 React 模板，还有一个连接的 GraphQL 查询来查询博客文章，并将 React 模板注入到查询的数据中。接下来:以编程方式创建必要的静态页面(并将模板注入)与 Gatsby 的 Node API，让我们开始吧。 此时需要注意的一点是，GraphQL 查询是在构建时进行的。该组件被注入数据由 GraphQL 查询所得到。除非有什么动态处理（ componentDidMount 的逻辑，state 变化），否则这个组件将是纯粹的，通过 React 渲染引擎、GraphQL 和 Gatsby 生成的HTML。</p>

<p>创建静态页面<br/>
Gatsby 公开了一个强大的Node API，它允许创建动态页面这样的功能（博客文章页！），扩展 babel 或 webpack 配置，修改所创建的节点或页面等。这个API写在在gatsby-node.js文件中，在这个文件中发现的每一个导出都将由 Gatsby 分析。Gatsby详细地介绍了它的Node API规范。但是，我们只关心这个实例中的一个特定的APIcreatePages。</p>

<pre><code class="language-javascript">const path = require(&#39;path&#39;);
​
exports.createPages = ({ boundActionCreators, graphql }) =&gt; {
 const { createPage } = boundActionCreators;
​
 const blogPostTemplate = path.resolve(`src/templates/blog-post.js`);
}
</code></pre>

<p>没什么复杂的！我们已经在使用 createPages API 了（ Gatsby 将在构建时通过注入的参数来调用）。我们还将获取我们先前创建的 blogPostTemplate 的路径。最后，我们使用了 createPage 激活了 boundActionCreators，Gatsby 在内部使用 Redux 来管理其状态，boundActionCreators 仅仅是 Gatsby 创造的一个action。对于所有公开的 action 的完整列表，请参阅 Gatsby 的文档。现在我们可以构造 GraphQL 查询，它将获取我们所有的 Markdown 贴子。</p>

<p>查询文章</p>

<pre><code class="language-javascript">const path = require(&#39;path&#39;);
​
exports.createPages = ({ boundActionCreators, graphql }) =&gt; {
 const { createPage } = boundActionCreators;
​
 const blogPostTemplate = path.resolve(`src/templates/blog-post.js`);
​
 return graphql(`{
    allMarkdownRemark(
      sort: { order: DESC, fields: [frontmatter___date] }
      limit: 1000
    ) {
      edges {
        node {
          excerpt(pruneLength: 250)
          html
          id
          frontmatter {
            date
            path
            title
          }
        }
      }
    }
 }`)
    .then(result =&gt; {
      if (result.errors) {
        return Promise.reject(result.errors);
      }
    });
}
</code></pre>

<p>我们使用 GraphQL 获取所有的 Markdown 节点，并在 GraphQL 属性 allMarkdownRemark 下使用它们。 每个公开的属性(在节点上)都可以用于查询。我们正在有效地创造一个GraphQL数据库，然后我们可以通过页面级的GraphQL查询对它进行查询。这里要注意的是exports.createPages API 期望返回一个 Promise。 这里有一个很酷的地方是gatsby-plugin-remark 插件提供了一些有用的数据供我们使用GraphQL查询，例如 excerpt（作为预览的一个简短的代码片段）， id（每个帖子的唯一标识符）等等。 现在我们已经编写了查询，但是我们还没有通过编程方式创建页面(使用createPage动作创建器)。下面让我们开始！</p>

<p>创建页面</p>

<pre><code class="language-javascript">const path = require(&#39;path&#39;);
​
exports.createPages = ({ boundActionCreators, graphql }) =&gt; {
 const { createPage } = boundActionCreators;
​
 const blogPostTemplate = path.resolve(`src/templates/blog-post.js`);
​
 return graphql(`{
    allMarkdownRemark(
      sort: { order: DESC, fields: [frontmatter___date] }
      limit: 1000
    ) {
      edges {
        node {
          excerpt(pruneLength: 250)
          html
          id
          frontmatter {
            date
            path
            title
          }
        }
      }
    }
 }`)
    .then(result =&gt; {
      if (result.errors) {
        return Promise.reject(result.errors);
      }
​
      result.data.allMarkdownRemark.edges
        .forEach(({ node }) =&gt; {
          createPage({
            path: node.frontmatter.path,
            component: blogPostTemplate,
            context: {} // additional data can be passed via context
          });
        });
    });
}
</code></pre>

<p>我们现在得到了一个 Promise 的 graphql 查询。实际的贴子可以通过路径 result.data.allMarkdownRemark.edges 获得。我们将使用这些数据来构建一个包含 Gatsby 的页面。我们的 GraphQL“形状”直接反映在这个数据对象中，因此，当我们在GraphQL博客文章模板中查询时，我们从该查询中提取的每个属性都将可用。 createPage API接受一个需要定义path和component 属性的对象，我们已经在上面做过了。此外，可以使用可选属性context来注入数据并使其可用于博客文章模板组件通过注入props（用各种 props 来查看每一个可用的 prop！）每一次我们构建 Gatsby 时， createPage 将被调用，Gatsby 将会创建一个静态的 HTML 文件路径根据我们在帖子的前面专门写的 frontmatter。GraphQL查询的数据将注入到 stringified 和 parsed 后的 React 模板。哇，它真的开始工作起来了！ 我们可以在这时运行 yarn develop 然后打开 <a href="http://localhost:8000/hello-world">http://localhost:8000/hello-world</a> 查看我们的第一篇博客文章，应该如下所示：</p>

<p>在这一点上，我们使用 React 组件和几个 GraphQL 查询创建了一个单页静态博客。然而，这不是一个博客！我们不能期望用户猜测每个帖子的路径，我们需要有一个索引或列表页面来展示每个博客文章，简短的介绍，以及一个完整的博客文章的链接。你不知道，我们在 Gatsby 做到这一点有多容易，使用我们在博客模板中使用的类似策略，例如一个 React 组件和一个 GraphQL 查询。</p>

<p>创建博客列表<br/>
我在这一节中没有详细介绍，因为我们已经对我们的博客模板做了一些非常相似的事情！看看我们，我们在这一点上已经是一个专业级的 Gatsby 使用者了！ 对于页面列表，Gatsby 有一个规范， 它们被放在我们指定的文件系统的根目录中gatsby-source-filesystem，例如src/pages/index.js。如果它不存在，就创建这个文件，让它运行。另外请注意，任何静态的 JavaScript 文件(导出一个 React 组件！)都会得到相应的静态 HTML 文件。例如，我们创造一个 src/pages/tags.js 文件，<a href="http://localhost:8000/tags/">http://localhost:8000/tags/</a> 将可访问。</p>

<pre><code class="language-javascript">import React from &#39;react&#39;;
import Link from &#39;gatsby-link&#39;;
import Helmet from &#39;react-helmet&#39;;
​
// import &#39;../css/index.css&#39;; // add some style if you want!
​
export default function Index({
 data
}) {
 const { edges: posts } = data.allMarkdownRemark;
 return (
    &lt;div className=&quot;blog-posts&quot;&gt;
      {posts
        .filter(post =&gt; post.node.frontmatter.title.length &gt; 0)
        .map(({ node: post }) =&gt; {
          return (
            &lt;div className=&quot;blog-post-preview&quot; key={post.id}&gt;
              &lt;h1&gt;
                &lt;Link to={post.frontmatter.path}&gt;{post.frontmatter.title}&lt;/Link&gt;
              &lt;/h1&gt;
              &lt;h2&gt;{post.frontmatter.date}&lt;/h2&gt;
              &lt;p&gt;{post.excerpt}&lt;/p&gt;
            &lt;/div&gt;
          );
        })}
    &lt;/div&gt;
 );
}
​
export const pageQuery = graphql`
 query IndexQuery {
    allMarkdownRemark(sort: { order: DESC, fields: [frontmatter___date] }) {
      edges {
        node {
          excerpt(pruneLength: 250)
          id
          frontmatter {
            title
            date(formatString: &quot;MMMM DD, YYYY&quot;)
            path
          }
        }
      }
    }
 }
`;

</code></pre>

<p>好的!我们在博客文章模板中采用了类似的方法，因此这应该看起来非常熟悉。我们再一次导出包含了 GraphQL 查询的 pageQuery。 注意，我们正在提取一个稍微不同的数据集，具体来说，我们将提取250个字符的摘要，而不是完整的HTML，同时我们还在用格式字符串格式化拖拽日期！GraphQL是很优雅的。 实际的 React 组件是相当琐碎的，需要注意一点，当链接到内部内容时，你应该经常使用 gatsby-link。 如果页面没有通过这个实用工具进行路由，Gatsby 就无法工作。另外，可以使用 pathPrefix，这使得 Gatsby 的网站可以被部署到一个非根域。如果这个博客将托管在Github页面上，这是很有用的。或者挂在 /blog。 现在这变得令人兴奋，感觉我们终于要成功了。现在我们有一个由 Gatsby 所生成的功能完整的博客，其中有真正的内容在 Markdown 里，有一个博客列表，以及在博客中浏览的能力。如果你执行 yarn develop，<a href="http://localhost:8000">http://localhost:8000</a> 应该显示每个博客文章的缩略内容，每个文章标题都链接到博客文章的内容。这是一个真正的博客！</p>

<p>现在，你在跟随本教程的学习过程中获得的知识，将会使你做出一些不可思议的事情。您不仅可以使用CSS(styled-components！)使其变得漂亮，还可以通过实现以下功能来变得更强大！</p>

<p>添加一个 tag 列表和 tag 查询页</p>

<p>提示：gatsby-node.js 文件中的 createPages API 在这里很有用，还有之前的 frontmatter<br/>
在特定的博客文章之间添加导航（createPages 的 context API在这里很有用） 随着我们对 Gatsby 及其API的探索，你应该感到有能力开始充分利用 Gatsby 的潜力，博客仅仅是一个起点;Gatsby 丰富的生态系统、可扩展的 API 和高级的查询功能为构建真正令人难以置信的高性能站点提供了强大的工具集。<br/>
现在去做一些伟大的事情吧！</p>

]]></content>
  </entry>
  
</feed>
