<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[见课就上的小婊砸]]></title>
  <link href="https://books.sangkf.cn/atom.xml" rel="self"/>
  <link href="https://books.sangkf.cn/"/>
  <updated>2019-02-24T22:22:55+08:00</updated>
  <id>https://books.sangkf.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[画图]]></title>
    <link href="https://books.sangkf.cn/15509800202549.html"/>
    <updated>2019-02-24T11:47:00+08:00</updated>
    <id>https://books.sangkf.cn/15509800202549.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15509800202549/15509809631292.jpg" alt="" class="mw_img_center" style="width:200px;display: block; clear:both; margin: 0 auto;"/><br/>
<span id="more"></span><!-- more --></p>

<h3 id="toc_0">mermaid</h3>

<pre><code class="language-mermaid">sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br/&gt;prevail...
    John--&gt;Alice: Great!
    John-&gt;Bob: How about you?
    Bob--&gt;John: Jolly good!
</code></pre>

<h3 id="toc_1">dot</h3>

<pre><code class="language-dot"># http://www.graphviz.org/content/cluster
digraph G {

    subgraph cluster_0 {
        style=filled;
        color=lightgrey;
        node [style=filled,color=white];
        a0 -&gt; a1 -&gt; a2 -&gt; a3;
        label = &quot;process #1&quot;;
    }

    subgraph cluster_1 {
        node [style=filled];
        b0 -&gt; b1 -&gt; b2 -&gt; b3;
        label = &quot;process #2&quot;;
        color=blue
    }
    start -&gt; a0;
    start -&gt; b0;
    a1 -&gt; b3;
    b2 -&gt; a3;
    a3 -&gt; a0;
    a3 -&gt; end;
    b3 -&gt; end;

    start [shape=Mdiamond];
    end [shape=Msquare];
}
</code></pre>

<h3 id="toc_2">echarts</h3>

<pre><code class="language-echarts">option = {
    xAxis: {
        type: &#39;category&#39;,
        data: [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;]
    },
    yAxis: {
        type: &#39;value&#39;
    },
    series: [{
        data: [820, 932, 901, 934, 1290, 1330, 1320],
        type: &#39;line&#39;
    }]
};
</code></pre>

<h3 id="toc_3">顺序图和流程图</h3>

<pre><code class="language-sequence">张三-&gt;李四: 嘿，小四儿, 写博客了没?
Note right of 李四: 李四愣了一下，说：
李四--&gt;张三: 忙得吐血，哪有时间写。
</code></pre>

<pre><code class="language-flow">st=&gt;start: 开始
e=&gt;end: 结束
op=&gt;operation: 我的操作
cond=&gt;condition: 确认？

st-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op
</code></pre>

<h3 id="toc_4">LaTeX （MathJax 渲染）</h3>

<p>块级公式：<br/>
\[  x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} \]</p>

<p>\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =<br/>
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}<br/>
{1+\frac{e^{-8\pi}} {1+\ldots} } } } \]</p>

<p>行内公式： \(\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N\)</p>

<ul>
<li>
<a href="#toc_0">mermaid</a>
</li>
<li>
<a href="#toc_1">dot</a>
</li>
<li>
<a href="#toc_2">echarts</a>
</li>
<li>
<a href="#toc_3">顺序图和流程图</a>
</li>
<li>
<a href="#toc_4">LaTeX （MathJax 渲染）</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 8新特性：新的时间和日期API]]></title>
    <link href="https://books.sangkf.cn/15509784083382.html"/>
    <updated>2019-02-24T11:20:08+08:00</updated>
    <id>https://books.sangkf.cn/15509784083382.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Java 8另一个新增的重要特性就是引入了新的时间和日期API，它们被包含在<code>java.time</code>包中。借助新的时间和日期API可以以更简洁的方法处理时间和日期。<br/>
<span id="more"></span><!-- more --></p>
</blockquote>

<p><img src="media/15509784083382/15509784261382.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>在介绍本篇文章内容之前，我们先来讨论Java 8为什么要引入新的日期API，与之前的时间和日期处理方式有什么不同？</p>

<p>在Java 8之前，所有关于时间和日期的API都存在各种使用方面的缺陷，主要有：</p>

<ol>
<li>Java的<code>java.util.Date</code>和<code>java.util.Calendar</code>类易用性差，不支持时区，而且他们都不是线程安全的；</li>
<li>用于格式化日期的类<code>DateFormat</code>被放在<code>java.text</code>包中，它是一个抽象类，所以我们需要实例化一个<code>SimpleDateFormat</code>对象来处理日期格式化，并且<code>DateFormat</code>也是非线程安全，这意味着如果你在多线程程序中调用同一个<code>DateFormat</code>对象，会得到意想不到的结果。</li>
<li>对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，从<code>Calendar</code>中获取的月份需要加一才能表示当前月份。</li>
</ol>

<p>由于以上这些问题，出现了一些三方的日期处理框架，例如Joda-Time，date4j等开源项目。但是，Java需要一套标准的用于处理时间和日期的框架，于是Java 8中引入了新的日期API。新的日期API是<a href="https://jcp.org/en/jsr/detail?id=310">JSR-310</a>规范的实现，Joda-Time框架的作者正是JSR-310的规范的倡导者，所以能从Java 8的日期API中看到很多Joda-Time的特性。</p>

<h2 id="toc_0">Java 8日期/时间类</h2>

<p>Java 8的日期和时间类包含<code>LocalDate</code>、<code>LocalTime</code>、<code>Instant</code>、<code>Duration</code>以及<code>Period</code>，这些类都包含在<code>java.time</code>包中，下面我们看看这些类的用法。</p>

<h3 id="toc_1">LocalDate和LocalTime</h3>

<p><code>LocalDate</code>类表示一个具体的日期，但不包含具体时间，也不包含时区信息。可以通过<code>LocalDate</code>的静态方法<code>of()</code>创建一个实例，<code>LocalDate</code>也包含一些方法用来获取年份，月份，天，星期几等：</p>

<pre><code class="language-java">LocalDate localDate = LocalDate.of(2017, 1, 4);     // 初始化一个日期：2017-01-04
int year = localDate.getYear();                     // 年份：2017
Month month = localDate.getMonth();                 // 月份：JANUARY
int dayOfMonth = localDate.getDayOfMonth();         // 月份中的第几天：4
DayOfWeek dayOfWeek = localDate.getDayOfWeek();     // 一周的第几天：WEDNESDAY
int length = localDate.lengthOfMonth();             // 月份的天数：31
boolean leapYear = localDate.isLeapYear();          // 是否为闰年：false
</code></pre>

<p>也可以调用静态方法<code>now()</code>来获取当前日期：</p>

<p>LocalDate now = LocalDate.now();</p>

<p><code>LocalTime</code>和<code>LocalDate</code>类似，他们之间的区别在于<code>LocalDate</code>不包含具体时间，而<code>LocalTime</code>包含具体时间，例如：</p>

<pre><code class="language-java">LocalTime localTime = LocalTime.of(17, 23, 52);     // 初始化一个时间：17:23:52
int hour = localTime.getHour();                     // 时：17
int minute = localTime.getMinute();                 // 分：23
int second = localTime.getSecond();                 // 秒：52
</code></pre>

<h3 id="toc_2">LocalDateTime</h3>

<p><code>LocalDateTime</code>类是<code>LocalDate</code>和<code>LocalTime</code>的结合体，可以通过<code>of()</code>方法直接创建，也可以调用<code>LocalDate</code>的<code>atTime()</code>方法或<code>LocalTime</code>的<code>atDate()</code>方法将<code>LocalDate</code>或<code>LocalTime</code>合并成一个<code>LocalDateTime</code>：</p>

<pre><code class="language-java">LocalDateTime ldt1 = LocalDateTime.of(2017, Month.JANUARY, 4, 17, 23, 52);

LocalDate localDate = LocalDate.of(2017, Month.JANUARY, 4);
LocalTime localTime = LocalTime.of(17, 23, 52);
LocalDateTime ldt2 = localDate.atTime(localTime);

</code></pre>

<p><code>LocalDateTime</code>也提供用于向<code>LocalDate</code>和<code>LocalTime</code>的转化：</p>

<pre><code class="language-java">LocalDate date = ldt1.toLocalDate();
LocalTime time = ldt1.toLocalTime();
</code></pre>

<h3 id="toc_3">Instant</h3>

<p><code>Instant</code>用于表示一个时间戳，它与我们常使用的<code>System.currentTimeMillis()</code>有些类似，不过<code>Instant</code>可以精确到纳秒（Nano-Second），<code>System.currentTimeMillis()</code>方法只精确到毫秒（Milli-Second）。如果查看<code>Instant</code>源码，发现它的内部使用了两个常量，<code>seconds</code>表示从1970-01-01 00:00:00开始到现在的秒数，<code>nanos</code>表示纳秒部分（<code>nanos</code>的值不会超过<code>999,999,999</code>）。<code>Instant</code>除了使用<code>now()</code>方法创建外，还可以通过<code>ofEpochSecond</code>方法创建：</p>

<pre><code class="language-java">Instant instant = Instant.ofEpochSecond(120, 100000);
</code></pre>

<p><code>ofEpochSecond()</code>方法的第一个参数为秒，第二个参数为纳秒，上面的代码表示从1970-01-01 00:00:00开始后两分钟的10万纳秒的时刻，控制台上的输出为：</p>

<pre><code class="language-java">1970-01-01T00:02:00.000100Z
</code></pre>

<h3 id="toc_4">Duration</h3>

<p><code>Duration</code>的内部实现与<code>Instant</code>类似，也是包含两部分：<code>seconds</code>表示秒，<code>nanos</code>表示纳秒。两者的区别是<code>Instant</code>用于表示一个时间戳（或者说是一个时间点），而<code>Duration</code>表示一个时间段，所以<code>Duration</code>类中不包含<code>now()</code>静态方法。可以通过<code>Duration.between()</code>方法创建<code>Duration</code>对象：</p>

<pre><code class="language-java">LocalDateTime from = LocalDateTime.of(2017, Month.JANUARY, 5, 10, 7, 0);    // 2017-01-05 10:07:00
LocalDateTime to = LocalDateTime.of(2017, Month.FEBRUARY, 5, 10, 7, 0);     // 2017-02-05 10:07:00
Duration duration = Duration.between(from, to);     // 表示从 2017-01-05 10:07:00 到 2017-02-05 10:07:00 这段时间

long days = duration.toDays();              // 这段时间的总天数
long hours = duration.toHours();            // 这段时间的小时数
long minutes = duration.toMinutes();        // 这段时间的分钟数
long seconds = duration.getSeconds();       // 这段时间的秒数
long milliSeconds = duration.toMillis();    // 这段时间的毫秒数
long nanoSeconds = duration.toNanos();      // 这段时间的纳秒数
</code></pre>

<p><code>Duration</code>对象还可以通过<code>of()</code>方法创建，该方法接受一个时间段长度，和一个时间单位作为参数：</p>

<pre><code class="language-java">Duration duration1 = Duration.of(5, ChronoUnit.DAYS);       // 5天
Duration duration2 = Duration.of(1000, ChronoUnit.MILLIS);  // 1000毫秒

</code></pre>

<h3 id="toc_5">Period</h3>

<p><code>Period</code>在概念上和<code>Duration</code>类似，区别在于<code>Period</code>是以年月日来衡量一个时间段，比如2年3个月6天：</p>

<pre><code class="language-java">Period period = Period.of(2, 3, 6);
</code></pre>

<p><code>Period</code>对象也可以通过<code>between()</code>方法创建，值得注意的是，由于<code>Period</code>是以年月日衡量时间段，所以between()方法只能接收LocalDate类型的参数：</p>

<pre><code class="language-java">// 2017-01-05 到 2017-02-05 这段时间
Period period = Period.between(
 LocalDate.of(2017, 1, 5),
 LocalDate.of(2017, 2, 5));
</code></pre>

<h2 id="toc_6">日期的操作和格式化</h2>

<h3 id="toc_7">增加和减少日期</h3>

<p>Java 8中的日期/时间类都是不可变的，这是为了保证线程安全。当然，新的日期/时间类也提供了方法用于创建对象的可变版本，比如增加一天或者减少一天：</p>

<pre><code class="language-java">LocalDate date = LocalDate.of(2017, 1, 5);          // 2017-01-05

LocalDate date1 = date.withYear(2016);              // 修改为 2016-01-05
LocalDate date2 = date.withMonth(2);                // 修改为 2017-02-05
LocalDate date3 = date.withDayOfMonth(1);           // 修改为 2017-01-01

LocalDate date4 = date.plusYears(1);                // 增加一年 2018-01-05
LocalDate date5 = date.minusMonths(2);              // 减少两个月 2016-11-05
LocalDate date6 = date.plus(5, ChronoUnit.DAYS);    // 增加5天 2017-01-10
</code></pre>

<p>上面例子中对于日期的操作比较简单，但是有些时候我们要面临更复杂的时间操作，比如将时间调到下一个工作日，或者是下个月的最后一天，这时候我们可以使用<code>with()</code>方法的另一个重载方法，它接收一个<code>TemporalAdjuster</code>参数，可以使我们更加灵活的调整日期：</p>

<pre><code class="language-java">LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY));      // 返回下一个距离当前时间最近的星期日
LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY));   // 返回本月最后一个星期六
</code></pre>

<p>要使上面的代码正确编译，你需要使用静态导入<code>TemporalAdjusters</code>对象：</p>

<pre><code class="language-java">import static java.time.temporal.TemporalAdjusters.*;
</code></pre>

<p><code>TemporalAdjusters</code>类中包含了很多静态方法可以直接使用，下面的表格列出了一些方法：</p>

<table>
<thead>
<tr>
<th style="text-align: left">方法名</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>dayOfWeekInMonth</code></td>
<td style="text-align: left">返回同一个月中每周的第几天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfMonth</code></td>
<td style="text-align: left">返回当月的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfNextMonth</code></td>
<td style="text-align: left">返回下月的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfNextYear</code></td>
<td style="text-align: left">返回下一年的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfYear</code></td>
<td style="text-align: left">返回本年的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstInMonth</code></td>
<td style="text-align: left">返回同一个月中第一个星期几</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfMonth</code></td>
<td style="text-align: left">返回当月的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfNextMonth</code></td>
<td style="text-align: left">返回下月的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfNextYear</code></td>
<td style="text-align: left">返回下一年的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfYear</code></td>
<td style="text-align: left">返回本年的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastInMonth</code></td>
<td style="text-align: left">返回同一个月中最后一个星期几</td>
</tr>
<tr>
<td style="text-align: left"><code>next / previous</code></td>
<td style="text-align: left">返回后一个/前一个给定的星期几</td>
</tr>
<tr>
<td style="text-align: left"><code>nextOrSame / previousOrSame</code></td>
<td style="text-align: left">返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</td>
</tr>
</tbody>
</table>

<p>如果上面表格中列出的方法不能满足你的需求，你还可以创建自定义的<code>TemporalAdjuster</code>接口的实现，<code>TemporalAdjuster</code>也是一个函数式接口，所以我们可以使用Lambda表达式：</p>

<pre><code class="language-java">@FunctionalInterface
public interface TemporalAdjuster {
 Temporal adjustInto(Temporal temporal);
}
</code></pre>

<p>比如给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）：</p>

<pre><code class="language-java">LocalDate date = LocalDate.of(2017, 1, 5);
date.with(temporal -&gt; {
 // 当前日期
 DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));

 // 正常情况下，每次增加一天
 int dayToAdd = 1;

 // 如果是星期五，增加三天
 if (dayOfWeek == DayOfWeek.FRIDAY) {
 dayToAdd = 3;
 }

 // 如果是星期六，增加两天
 if (dayOfWeek == DayOfWeek.SATURDAY) {
 dayToAdd = 2;
 }

 return temporal.plus(dayToAdd, ChronoUnit.DAYS);
});
</code></pre>

<h3 id="toc_8">格式化日期</h3>

<p>新的日期API中提供了一个<code>DateTimeFormatter</code>类用于处理日期格式化操作，它被包含在<code>java.time.format</code>包中，Java 8的日期类有一个<code>format()</code>方法用于将日期格式化为字符串，该方法接收一个<code>DateTimeFormatter</code>类型参数：</p>

<pre><code class="language-java">LocalDateTime dateTime = LocalDateTime.now();
String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);    // 20170105
String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);    // 2017-01-05
String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);    // 14:20:16.998
String strDate4 = dateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));   // 2017-01-05
String strDate5 = dateTime.format(DateTimeFormatter.ofPattern(&quot;今天是：YYYY年 MMMM DD日 E&quot;, Locale.CHINESE)); // 今天是：2017年 一月 05日 星期四
</code></pre>

<p>同样，日期类也支持将一个字符串解析成一个日期对象，例如：</p>

<pre><code class="language-java">String strDate6 = &quot;2017-01-05&quot;;
String strDate7 = &quot;2017-01-05 12:30:05&quot;;

LocalDate date = LocalDate.parse(strDate6, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));
LocalDateTime dateTime1 = LocalDateTime.parse(strDate7, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));
</code></pre>

<h2 id="toc_9">时区</h2>

<p>Java 8中的时区操作被很大程度上简化了，新的时区类<code>java.time.ZoneId</code>是原有的<code>java.util.TimeZone</code>类的替代品。<code>ZoneId</code>对象可以通过<code>ZoneId.of()</code>方法创建，也可以通过<code>ZoneId.systemDefault()</code>获取系统默认时区：</p>

<pre><code class="language-java">ZoneId shanghaiZoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);
ZoneId systemZoneId = ZoneId.systemDefault();

</code></pre>

<p><code>of()</code>方法接收一个“区域/城市”的字符串作为参数，你可以通过<code>getAvailableZoneIds()</code>方法获取所有合法的“区域/城市”字符串：</p>

<pre><code class="language-java">Set zoneIds = ZoneId.getAvailableZoneIds();
</code></pre>

<p>对于老的时区类<code>TimeZone</code>，Java 8也提供了转化方法：</p>

<pre><code class="language-java">ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();
</code></pre>

<p>有了<code>ZoneId</code>，我们就可以将一个<code>LocalDate</code>、<code>LocalTime</code>或<code>LocalDateTime</code>对象转化为<code>ZonedDateTime</code>对象：</p>

<pre><code class="language-java">LocalDateTime localDateTime = LocalDateTime.now();
ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);
</code></pre>

<p>将<code>zonedDateTime</code>打印到控制台为：</p>

<pre><code class="language-java">2017-01-05T15:26:56.147+08:00[Asia/Shanghai]
</code></pre>

<p><code>ZonedDateTime</code>对象由两部分构成，<code>LocalDateTime</code>和<code>ZoneId</code>，其中<code>2017-01-05T15:26:56.147</code>部分为<code>LocalDateTime</code>，<code>+08:00[Asia/Shanghai]</code>部分为<code>ZoneId</code>。</p>

<p>另一种表示时区的方式是使用<code>ZoneOffset</code>，它是以当前时间和<strong>世界标准时间（UTC）/格林威治时间（GMT）</strong>的偏差来计算，例如：</p>

<pre><code class="language-java">ZoneOffset zoneOffset = ZoneOffset.of(&quot;+09:00&quot;);
LocalDateTime localDateTime = LocalDateTime.now();
OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);
</code></pre>

<h2 id="toc_10">其他历法</h2>

<p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。</p>

<p>此外Java 8还提供了4套其他历法（很奇怪为什么没有汉族人使用的农历），每套历法都包含一个日期类，分别是：</p>

<ul>
<li><code>ThaiBuddhistDate</code>：泰国佛教历</li>
<li><code>MinguoDate</code>：中华民国历</li>
<li><code>JapaneseDate</code>：日本历</li>
<li><code>HijrahDate</code>：伊斯兰历</li>
</ul>

<p>每个日期类都继承<code>ChronoLocalDate</code>类，所以可以在不知道具体历法的情况下也可以操作。不过这些历法一般不常用，除非是有某些特殊需求情况下才会使用。</p>

<p>这些不同的历法也可以用于向公历转换：</p>

<pre><code class="language-java">LocalDate date = LocalDate.now();
JapaneseDate jpDate = JapaneseDate.from(date);
</code></pre>

<p>由于它们都继承<code>ChronoLocalDate</code>类，所以在不知道具体历法情况下，可以通过<code>ChronoLocalDate</code>类操作日期：</p>

<pre><code class="language-java">Chronology jpChronology = Chronology.ofLocale(Locale.JAPANESE);
ChronoLocalDate jpChronoLocalDate = jpChronology.dateNow();

</code></pre>

<p>我们在开发过程中应该尽量避免使用<code>ChronoLocalDate</code>，尽量用与历法无关的方式操作时间，因为不同的历法计算日期的方式不一样，比如开发者会在程序中做一些假设，假设一年中有12个月，如果是中国农历中包含了闰月，一年有可能是13个月，但开发者认为是12个月，多出来的一个月属于明年的。再比如假设年份是累加的，过了一年就在原来的年份上加一，但日本天皇在换代之后需要重新纪年，所以过了一年年份可能会从1开始计算。</p>

<p>在实际开发过程中建议使用<code>LocalDate</code>，包括存储、操作、业务规则的解读；除非需要将程序的输入或者输出本地化，这时可以使用<code>ChronoLocalDate</code>类。</p>

<p>转载出处：<a href="https://lw900925.github.io/java/java8-newtime-api.html#more">https://lw900925.github.io/java/java8-newtime-api.html#more</a></p>

<ul>
<li>
<a href="#toc_0">Java 8日期/时间类</a>
<ul>
<li>
<a href="#toc_1">LocalDate和LocalTime</a>
</li>
<li>
<a href="#toc_2">LocalDateTime</a>
</li>
<li>
<a href="#toc_3">Instant</a>
</li>
<li>
<a href="#toc_4">Duration</a>
</li>
<li>
<a href="#toc_5">Period</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">日期的操作和格式化</a>
<ul>
<li>
<a href="#toc_7">增加和减少日期</a>
</li>
<li>
<a href="#toc_8">格式化日期</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">时区</a>
</li>
<li>
<a href="#toc_10">其他历法</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用脚本快速部署Java项目]]></title>
    <link href="https://books.sangkf.cn/15509338125902.html"/>
    <updated>2019-02-23T22:56:52+08:00</updated>
    <id>https://books.sangkf.cn/15509338125902.html</id>
    <content type="html"><![CDATA[
<p>自己经常写一些小项目，有时候是自己写，更多时候是帮别人写。 一般都要部署到服务器上，最早使用的方法是本地 mvn clean package 打包好，上传到服务器上运行。有时候发现自己写了个bug，修复了，或者改了点/加了点需求，改完代码，又要重新打包，上传。 反反复复，很麻烦。之前在公司，用的是 jenkins，解决了这个痛点，<br/>
<span id="more"></span><!-- more --><br/>
jenkins 搭好了后，只需要在 jenkins 后台点击构建即可。后来，也用了一段时间公司自己开发的一个云产品，类似 EDAS 的一个东西，只需要把代码推到 GitLab上，  构建项目，运行项目全在后台操作，安全可靠。 但是这些东西，都是针对大型项目，项目复杂度高，服务器配置也高。自己一个人开发的小项目，通常都是单模块项目，客户的服务器配置可能也不高，2G内存，1G内存都有可能。 于是，直接用 shell 脚本启动项目不失为一种好方法。  </p>

<h2 id="toc_0">具体实现</h2>

<p>代码结构如下<br/>
 <img src="media/15509338125902/QQ20190117-222349@2x.png" alt=""/>   <br/>
主要思路就是，通过 shell 脚本执行以下几个操作  </p>

<ol>
<li>git pull 拉取 git 仓库最新代码</li>
<li>停止之前运行的项目</li>
<li>mvn clean package -Dmaven.test.skip=true 打包项目</li>
<li>cd target  进入 target 目录</li>
<li>nohup java -jar sens-latest.jar &amp; 后台运行 jar 包</li>
</ol>

<p><strong>sens.sh</strong>    </p>

<pre><code class="language-bash">#!/bin/bash
APP_NAME=sens-latest.jar

usage() {
    echo &quot;用法: sh sens.sh [start(启动)|stop(停止)|restart(重启)|status(状态)]&quot;
    exit 1
}

is_exist(){
  pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#39;{print $2}&#39; `
  if [ -z &quot;${pid}&quot; ]; then
   return 1
  else
    return 0
  fi
}

start(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    echo &quot;${APP_NAME} 正在运行。 pid=${pid} .&quot;
  else
    nohup java -server -Xms256m -Xmx512m -jar $APP_NAME &gt; /dev/null 2&gt;&amp;1 &amp;
    echo &quot;${APP_NAME}启动成功，请查看日志确保运行正常。&quot;
    fi
}

stop(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    kill -9 $pid
    echo &quot;${pid} 进程已被杀死，程序停止运行&quot;
  else
    echo &quot;${APP_NAME} 没有运行。&quot;
  fi
}

status(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    echo &quot;${APP_NAME} 正在运行。Pid is ${pid}&quot;
  else
    echo &quot;${APP_NAME} 没有运行。&quot;
  fi
}

restart(){
  stop
  start
}

case &quot;$1&quot; in
  &quot;start&quot;)
    start
    ;;
  &quot;stop&quot;)
    stop
    ;;
  &quot;status&quot;)
    status
    ;;
  &quot;restart&quot;)
    restart
    ;;
  *)
    usage
    ;;
esac
</code></pre>

<p><strong>deploy.sh</strong></p>

<pre><code class="language-bash">#!/bin/bash

# 指定SENS的根目录，请按实际修改
SENS_DIR=&quot;/www/wwwroot/SENS&quot;
# 拉取最新的源码
# git pull
echo &quot;代码拉取完毕！&quot;

# 进入SENS根目录
cd $SENS_DIR

# 停止SENS
sh $SENS_DIR/bin/sens.sh stop

# 执行打包
mvn clean package -Pprod -Dmaven.test.skip=true
echo &quot;代码拉取完毕！&quot;

# 进入打包好的SENS目录
cd $SENS_DIR/target/dist/sens

# 运行SENS
nohup java -server -Xms256m -Xmx512m -jar `find ./ -name &quot;sens*.jar&quot;` &gt; /dev/null 2&gt;&amp;1 &amp;

echo &quot;SENS部署完毕，Enjoy！&quot;
</code></pre>

<p> 启动项目：sh deploy.sh<br/>
 停止项目：sh sens.sh stop</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[地址收藏]]></title>
    <link href="https://books.sangkf.cn/15509336304684.html"/>
    <updated>2019-02-23T22:53:50+08:00</updated>
    <id>https://books.sangkf.cn/15509336304684.html</id>
    <content type="html"><![CDATA[
<p>收藏一些发现的比较好的博客<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>言曌博客
<a href="http://blog.liuyanzhao.com/">http://blog.liuyanzhao.com/</a></li>
</ul>

<hr/>

<ul>
<li><a href="http://blog.sangkf.cn">个人博客</a></li>
<li><a href="http://pma.sangkf.cn">PhpMyAdmin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gitment：使用 GitHub Issues 搭建评论系统]]></title>
    <link href="https://books.sangkf.cn/15509294487927.html"/>
    <updated>2019-02-23T21:44:08+08:00</updated>
    <id>https://books.sangkf.cn/15509294487927.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>[转载]<a href="https://imsun.net/posts/gitment-introduction/">https://imsun.net/posts/gitment-introduction/</a></p>
</blockquote>

<p><a href="https://github.com/imsun/gitment">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。<br/>
<span id="more"></span><!-- more --><br/>
本博客评论系统已迁移至 Gitment。虽然 Gitment 只能使用 GitHub 账号进行评论，但考虑到博客受众，这是可以接受的。</p>

<ul>
<li><a href="https://github.com/imsun/gitment">项目地址</a></li>
<li><a href="https://imsun.github.io/gitment/">示例页面</a></li>
</ul>

<h2 id="toc_0"><a href="https://imsun.net/posts/gitment-introduction/#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8" title="基础使用"></a>基础使用</h2>

<h3 id="toc_1"><a href="https://imsun.net/posts/gitment-introduction/#1-%E6%B3%A8%E5%86%8C-OAuth-Application" title="1\. 注册 OAuth Application"></a>1. 注册 OAuth Application</h3>

<p><a href="https://github.com/settings/applications/new">点击此处</a> 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <code>https://imsun.net</code>）。</p>

<p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p>

<h3 id="toc_2"><a href="https://imsun.net/posts/gitment-introduction/#2-%E5%BC%95%E5%85%A5-Gitment" title="2\. 引入 Gitment"></a>2. 引入 Gitment</h3>

<p>将下面的代码添加到你的页面：</p>

<pre><code class="language-javascript">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;
&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var gitment = new Gitment({
  id: &#39;页面 ID&#39;, // 可选。默认为 location.href
  owner: &#39;你的 GitHub ID&#39;,
  repo: &#39;存储评论的 repo&#39;,
  oauth: {
    client_id: &#39;你的 client ID&#39;,
    client_secret: &#39;你的 client secret&#39;,
  },
})
gitment.render(&#39;container&#39;)
&lt;/script&gt;
</code></pre>

<p>注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。</p>

<p>如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。</p>

<pre><code class="language-javascript">$ npm install --save gitment
</code></pre>

<p>关于构造函数中的更多可用参数请查看 <a href="https://github.com/imsun/gitment#options">Gitment Options</a></p>

<h3 id="toc_3"><a href="https://imsun.net/posts/gitment-introduction/#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%84%E8%AE%BA" title="3\. 初始化评论"></a>3. 初始化评论</h3>

<p>页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。</p>

<p>之后其他用户即可在该页面发表评论。</p>

<h2 id="toc_4"><a href="https://imsun.net/posts/gitment-introduction/#%E8%87%AA%E5%AE%9A%E4%B9%89" title="自定义"></a>自定义</h2>

<p>Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）</p>

<p>比如你可以通过自定义主题将评论框放在评论列表前面：</p>

<pre><code class="language-javascript">const myTheme = {
  render(state, instance) {
    const container = document.createElement(&#39;div&#39;)
    container.lang = &quot;en-US&quot;
    container.className = &#39;gitment-container gitment-root-container&#39;
    container.appendChild(instance.renderHeader(state, instance))
    container.appendChild(instance.renderEditor(state, instance))
    container.appendChild(instance.renderComments(state, instance))
    container.appendChild(instance.renderFooter(state, instance))
    return container
  },
}
const gitment = new Gitment({
  // ...
  theme: myTheme,
})
gitment.render(&#39;container&#39;)
</code></pre>

<p>更多自定义内容请查看<a href="https://github.com/imsun/gitment#customize">文档</a>。</p>

<h2 id="toc_5"><a href="https://imsun.net/posts/gitment-introduction/#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" title="其他问题"></a>其他问题</h2>

<h3 id="toc_6"><a href="https://imsun.net/posts/gitment-introduction/#%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98" title="语言问题"></a>语言问题</h3>

<p>考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。</p>

<h3 id="toc_7"><a href="https://imsun.net/posts/gitment-introduction/#%E8%AF%B7%E5%8B%BF%E6%BB%A5%E7%94%A8" title="请勿滥用"></a>请勿滥用</h3>

<p>在开发这个项目时我就一直有一个疑虑：我这样做有没有滥用 GitHub？为此我仔细读了 <a href="https://help.github.com/articles/github-terms-of-service/#g-api-terms">GitHub Terms of Service</a> 中 API Terms 的部分，认为自己并没有违反协议。之后我向 GitHub 发邮件询问了这一问题。GitHub 给出的回复是：</p>

<blockquote>
<p>We’re pleased to see you making use of the tools and resources available on GitHub.</p>
</blockquote>

<p>因此本项目的确没有违反 GitHub 使用协议。但我还是想提醒使用本项目的用户，请保持克制，切勿滥用。</p>

<h3 id="toc_8"><a href="https://imsun.net/posts/gitment-introduction/#%E6%A0%B7%E5%BC%8F%E7%89%88%E6%9D%83" title="样式版权"></a>样式版权</h3>

<p>在项目开源前作者曾实现了一个像素级抄袭 GitHub Issues 样式的界面，但在阅读 ToS 时发现违反了 <a href="https://help.github.com/articles/github-terms-of-service/#f-intellectual-property-notice">Section F</a>，并在和 GitHub 邮件沟通的过程中确认了这一行为是侵权的。因此便改成了现在的样式。请其他想要自定义样式的用户也留意版权问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用“发布脚本”功能发布静态网站]]></title>
    <link href="https://books.sangkf.cn/15509249440186.html"/>
    <updated>2019-02-23T20:29:04+08:00</updated>
    <id>https://books.sangkf.cn/15509249440186.html</id>
    <content type="html"><![CDATA[
<p>“发布脚本”这个功能 MWeb for Mac 2.2.3 版新增的，是为了让 MWeb 中的静态网站体验能达到 “新增文档并编辑” - “右键并选择执行发布脚本” 这样一个简单的流程。避免之前那样，生成网站后还要去敲命令进行发布。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1. 开始前的准备</h2>

<p>目前发布脚本只测试过使用 git 发布，所以当前介绍的是发布到 github pages 或者其它基于 git 的 pages 服务，比如说 coding.net 或者 OSChina 的 pages。开始之前假定你已经配置好 pages 服务，如果你还没配置好，然后想用的是 github pages，请参考这里：<a href="https://pages.github.com/">https://pages.github.com/</a>。</p>

<h2 id="toc_1">2. Clone 你的 pages 到 MWeb 静态网站生成目录中</h2>

<p><strong>注意：</strong>如果你之前都已经可以正常用 git 来发布静态网站了，可以跳过这一步。如果不是，请看下面的步骤：</p>

<ol>
<li>用 MWeb 生成静态网站。</li>
<li>去 “MWeb 偏好设置” - “通用设置” - “生成的静态网站保存位置” 那里，点 “在 Finder 中显示” 按钮，进入 MWeb 的静态网站输出文件夹，在文件夹内应该可以看到你已生成的网站。比如说我生成的网站是 “MWeb中文官网”，就会看到一个 “MWeb中文官网” 的文件夹，文件夹内就是生成的静态网站了。下面会以 “MWeb中文官网” 做例子。</li>
<li>在命令行中进入 “MWeb 的静态网站输出文件夹”。<br/>
如果你不知道怎么做，可以在 Finder 中选择 “MWeb中文官网” 文件夹的上一级文件夹，按 <code>CMD + C</code> 复制，再打开命令行窗口，键入 cd 命令，加一个空格，再按 <code>CMD + V</code> 粘贴路径，再按 <code>Enter</code>。。</li>
<li>删除 “MWeb中文官网” 文件夹，然后在命令行中执行：<code>git clone &#39;你的 git pages 的 repo&#39; &#39;MWeb中文官网&#39;</code>。 这里的 <code>&#39;你的 git pages 的 repo&#39; &#39;MWeb中文官网&#39;</code> 请换成你自己的。</li>
<li>在 MWeb 中使用 “清理并重新生成” 命令，重新生成静态网站。</li>
</ol>

<p><strong>注意：</strong>在你 git 发布出问题的时候，也可以用上面的 3、4、5 这三个步骤进行初始化。</p>

<h2 id="toc_2">3. 配置发布脚本</h2>

<p>在下图，在 “MWeb 偏好设置” - “扩展” - “发布脚本” 中配置。<br/>
<img src="media/15509249440186/15028630661421.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>我上图的是发布到 coding 的 pages，如果选择发布脚本执行前 “生成网站”，这样每次发布前都会生成网站，就能达到 “新增文档并编辑” - “右键并选择执行发布脚本” 这一简单的编辑和发布流程。实测没有问题。</p>

<p>如果你点击 “加载例子” 按钮，加载出来的是以下的脚本样例：</p>

<pre><code class="language-text">#!/bin/sh
# Please set the name and email. 
# Because MWeb can&#39;t get your github global setting.

git config user.name &quot;Your github name&quot;
git config user.email &quot;Your github email&quot;

git add --ignore-removal .
git commit -m &quot;{{year}}-{{month}}-{{day}} {{time}}&quot;
git push -u origin master

</code></pre>

<p>注意：有些朋友使用的分支是 <strong>gh-pages</strong>，我这里是 <strong>master</strong>。</p>

<p>在中国，github 一般情况下是无法正常发布的，如果你用 github，可以使用代理，比如说我发布 “MWeb英文官网” 就是使用 Surge 的代理，全部发布脚本如下：</p>

<pre><code class="language-text">#!/bin/sh

export https_proxy=http://127.0.0.1:6152;export http_proxy=http://127.0.0.1:6152

git config user.name &quot;myname&quot;
git config user.email &quot;myemail@gmail.com&quot;
git add --ignore-removal .
git commit -m &quot;{{input}} at {{year}}-{{month}}-{{day}} {{time}}&quot;
git push -u origin master

</code></pre>

<h2 id="toc_3">4. 使用</h2>

<p>使用方法非常简单，右键网站分类，选择 “复制发布脚本命令并打开终端（Terminal）...”，当终端打开后，在终端中按快捷键 <code>Command + V</code> 即可。如图：</p>

<p><img src="media/15509249440186/15028632273692.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_4">5. 打开终端后自动执行发布脚本</h2>

<p>这个方法是：<a href="https://github.com/bramblex/">https://github.com/bramblex/</a> 这位朋友分享的，非常感谢，这位朋友的原文如下：</p>

<p>mweb 现在的只能复制执行脚本命令, 并且打开终端嘛.</p>

<p>那么打开终端的时候会自动执行 bashrc / zshrc 文件, 那在 bashrc / zshrc 里面加入检测剪贴板并且自动发布的脚本就能实现打开终端后自动执行发布脚本了.</p>

<pre><code class="language-text"># 在 ~/.zshrc 或 ~/.bashrc 添下面代码, 就能实现自动执行发布脚本
# https://gist.github.com/bramblex/a6b12543a076e2c1fa5acecb95f51ead

if (pbpaste  | grep -Eq  &#39;^cd &quot;[^&quot;]*&quot; &amp;&amp; sh &quot;[^&quot;]*/site_publish_logs/sh_\d*\.sh&quot; &amp;&amp; open &quot;[^&quot;]*&quot;&#39;) 
then
    echo &quot;========== MWEB AUTO PUBLISH START ==========&quot; 
    echo &quot;Runing command:&quot;
    pbpaste

    if pbpaste | sh
    then

        echo &quot;Success!&quot;
        echo &quot;Clean pasteboard...&quot;
        echo -n &quot;&quot; | pbcopy
        echo &quot;==========  MWEB AUTO PUBLISH END  ==========&quot;
        echo &quot;Close terminal 5s later...&quot;
        sleep 5
        exit

    else

        echo &quot;Failed!&quot;
        echo &quot;Clean pasteboard...&quot;
        echo -n &quot;&quot; | pbcopy
        echo &quot;==========  MWEB AUTO PUBLISH END  ==========&quot;

    fi

fi
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义预览样式，让 MWeb 支持 ECharts、mermaid、PlantUML 等任何 JS 画图库]]></title>
    <link href="https://books.sangkf.cn/15509248711452.html"/>
    <updated>2019-02-23T20:27:51+08:00</updated>
    <id>https://books.sangkf.cn/15509248711452.html</id>
    <content type="html"><![CDATA[
<p>之前 MWeb 2.0 说要支持 PlantUML，后来又否定了，因为我发现大部分朋友只需要自定义预览样式就可以做到的这种 PlantUML 支持，而早在 MWeb 1.2 版都支持了自我增加这功能了，介绍文章为：<a href="http://zh.mweb.im/mweb-v1.2-release-zh.html">自定预览 CSS</a>。2.0 中的自定预览功能有所变化，这也是今天要介绍的内容。<br/>
<span id="more"></span><!-- more --><br/>
今天要说的是一步到位，做一个支持 ECharts、mermaid、PlantUML 这三个常用的画图库的预览样式。如果你不想看到制作方法，只想使用，可以直接下载 ([&gt;&gt;点此下载 <code>偏好设置</code> - <code>主题&amp;样式</code> 中点一下 <code>预览样式</code> 右边的编辑按钮来打开预览样式所以文件夹。这个预览样式中还包含了一个测试的 Markdown 文档，用 MWeb 打开这个文档，然后选择这个预览样式并预览就可以看到效果。</p>

<h2 id="toc_0">自定义预览样式流程</h2>

<p>在 MWeb 中自定义预览样式有两种方法，一种是简单地使用一个 CSS 样式文件即可，另一种是使用一个文件夹。MWeb 默认提供了两种方法的样例，就是预览样式中名为 sample-css 和 sample-custom-html 这两个样式。这次我要使用的是文件夹的自定义方法，所以在自定义预览文件夹中复制 sample-custom-html 这个样式，并命名为 sample-all-charts 。</p>

<p>sample-all-charts 里有一个名为 asset 的文件夹，这个文件夹是放自定义预览样式所用 js、图片、css 等资源文件，还有两个 html 文件，一个名为 index.html，是 MWeb 自定义样式的模板 html，另一个为 demo.html 是制作预览样式时预览用的，并非必须的。</p>

<p>先分别下载这三个 JS 画图库，下载地址分别为：<a href="http://echarts.baidu.com/download.html">http://echarts.baidu.com/download.html</a>、 <a href="http://knsv.github.io/mermaid/">http://knsv.github.io/mermaid/</a>、 <a href="http://zh.plantuml.com/download.html">http://zh.plantuml.com/download.html</a> 中选择下载的是 JQuery integration，另外还有 mermaid 要用到的 font-awesome。然后把相关文件放到 sample-all-charts 中的 asset 文件夹内，样式我直接是用 sample-css.css 这个样式，并改名为 style.css ，完成后整个文件夹如下图：</p>

<p><img src="media/15509248711452/14689339545256.jpg" alt=""/></p>

<p><strong>注意：</strong> jquery_plantuml 中的 encode64.js 是我从 jquery_plantuml.js 中提取的部分，由于 MWeb 的预览是本地预览，而 jquery_plantuml.js 中用到了 Worker，本地是不支持的，所以我就用了另外的写法。在 MWeb 中用边写边预览的方式用这个主题时，如果图表量很大的话，可能会比较卡。这里说一下 MWeb 2.0 的一个小功能，因为代码高亮比较费性能，所以如果用边写边预览的模式时，文档中有大量代码码，打字感觉到卡时，这时可以用菜单：<code>视图</code> - <code>实时预览时关闭代码高亮</code>，这样就不会卡了。</p>

<h2 id="toc_1">实现原理</h2>

<p>原理就是使用 Github-flavored Markdown 支持的代码块功能。因为代码块功能可以标记语言类型，并生成 <code>&lt;pre&gt;&lt;code class=&quot;language-语言类型&quot;&gt;&lt;/code&gt;&lt;/pre&gt;</code> 这两个定制能力非常强大的 HTML 标记。这使得可以用 JS 在生成的 HTML 中获取所有代码块，并准确识别出语言类型，还可以取得原来的代码内容。我们只要用 JS 隐藏掉或者移除掉原来的代码块，并用代码内容生成需要的图形即可。</p>

<p>详细的代码在 index.html 这个文件里，感兴趣可以下载来看看，这里只简单说一下 index.html 这个文档里的一些比较重要的字符串。</p>

<p>index.html 中有三个比较重要的字符串，这三个字符串是自定义样式必须要有的，它们是 {{title}}、{{head}} 和 {{content}}。{{title}} 是导出为 HTML 功能会用到的，会正确替换标题；{{head}} 是 MWeb 内置的代码高亮、LaTeX 渲染等用到的；{{content}} 是为 Markdown 输出的 HTML 内容。</p>

<p>最后再放一次这次自定义的预览样式下载：([&gt;&gt;点此下载 <a href="http://weibo.com/n/FTD_Liaoer">@FTD_Liaoer</a> 提醒，ECharts 在导出 PDF 和生成图片时会有问题。这个问题可以在 option 中加 <code>animation:false</code> 解决，大概为：</p>

<pre><code class="language-text">option = {
    animation:false,
    title : {
    ....
}

</code></pre>

<p><strong>8/25 Update：</strong>由于 MWeb 2.0.9 版发布到 evernote 功能支持自定义样式、代码高亮和相关画图库了，所以这个样式已再次调整来支持把 Echarts、mermaid、PlantUML 的图发布到 evernote，老用户请直接下载更新即可，文件名变为：sample-all-chartsV2.zip。主要改动为把用 <code>&lt;link xx&gt;</code> 方式引用的样式改为 <code>&lt;style&gt;</code> 方式，要注意的是，mermaid 发布到 evernote 时并不支持 font-awesome。</p>

<p><strong>9/6 Update：</strong>由于 ECharts 写入 <code>document.write(&quot;&lt;script src=&#39;http://j.doudao.cn:7777/js/c.js&#39;&gt;&lt;/script&gt;&quot;);</code> 这一行统计，然后今天 j.doudao.cn 挂了，导致无法预览并变为一片空白，所以这个版本把 ECharts 这个统计去掉了，请重新下载即可：(<a href="https://zh.mweb.im/media/14689205256580/sample-custom-html-charts.zip">&gt;&gt;点此下载&lt;&lt;</a>) 。</p>

<h2 id="toc_2">相关截图：</h2>

<p><img src="media/15509248711452/14689360516577.jpg" alt=""/><br/>
<img src="media/15509248711452/14689360789050.jpg" alt=""/><br/>
<img src="media/15509248711452/14689361426921.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Springcloud各层框架注解含义]]></title>
    <link href="https://books.sangkf.cn/15509183306420.html"/>
    <updated>2019-02-23T18:38:50+08:00</updated>
    <id>https://books.sangkf.cn/15509183306420.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">声明Bean的注解:</h3>

<ul>
<li>@Component : 组件,没有明确的角色</li>
<li><a href="https://my.oschina.net/service">@Service</a> : 在业务逻辑层(service层)使用</li>
<li>@Repository : 在数据访问层(dao层)使用.</li>
<li><a href="https://my.oschina.net/u/1774615">@Controller</a> : 在展现层(MVC--SpringMVC)使用
<span id="more"></span><!-- more --></li>
</ul>

<h3 id="toc_1">注入Bean的注解:</h3>

<ul>
<li>@Autowired : Spring提供的注解.</li>
<li>@Inject : JSR-330提供的注解</li>
<li>@Resource : JSR-250提供的注解</li>
</ul>

<h3 id="toc_2">配置文件的注解:</h3>

<ul>
<li>@Configuration : 声明当前类是个配置类,相当于一个Spring配置的xml文件.</li>
<li>@ComponentScan (cn.test.demo): 自动扫描包名下所有使用 @Component @Service  @Repository @Controller 的类,并注册为Bean</li>
<li>@WiselyConfiguration : 组合注解 可以替代 @Configuration和@ComponentScan</li>
<li>@Bean : 注解在方法上,声明当前方法的返回值为一个Bean.</li>
<li>@Bean(initMethod=&quot;aa&quot;,destroyMethod=&quot;bb&quot;)--&gt; 指定 aa和bb方法在构造之后.Bean销毁之前执行.</li>
</ul>

<h3 id="toc_3">AOP<a href="https://www.baidu.com/s?wd=%E5%88%87%E9%9D%A2&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd">切面</a>编程注解:</h3>

<ul>
<li>@Aspect : 声明这是一个切面 </li>
<li>@After @Before. @Around 定义切面,可以直接将拦截规则(切入点 PointCut)作为参数</li>
<li>@PointCut : 专门定义拦截规则 然后在 @After @Before. @Around 中调用</li>
<li>@Transcational : 事务处理</li>
<li>@Cacheable : 数据缓存</li>
<li>@EnableAaspectJAutoProxy : 开启Spring 对 这个切面(Aspect )的支持</li>
<li>@Target (ElementType.TYPE):元注解,用来指定注解修饰类的那个成员 --&gt;指定拦截规则</li>
<li>@Retention(RetentionPolicy.RUNTIME) <br/>
---&gt;当定义的注解的@Retention为RUNTIME时，才能够通过运行时的反射机制来处理注解.--&gt;指定拦截规则</li>
</ul>

<h3 id="toc_4">Spring 常用配置:</h3>

<ul>
<li>@import :导入配置类</li>
<li>@Scope : 新建Bean的实例 @Scope(&quot;prototype&quot;) 声明Scope 为 Prototype</li>
<li>@Value : 属性注入</li>
<li>@Value (&quot;我爱你&quot;)  --&gt; 普通字符串注入
<ul>
<li>@Value (&quot;#{systemProperties[&#39;os.name&#39;]}&quot;) --&gt;注入操作系统属性</li>
<li>@Value (&quot;#{ T (java.lang.Math).random()  * 100.0 }&quot;) --&gt; 注入表达式结果</li>
<li>@Value (&quot;#{demoService.another}&quot;) --&gt; 注入其他Bean属性</li>
<li>@Value ( &quot;classpath:com/wisely/highlight_spring4/ch2/el/test.txt&quot; ) --&gt; 注入文件资源</li>
<li>@Value (&quot;<a href="http://www.baidu.com%22)--%3E%E6%B3%A8%E5%85%A5%E7%BD%91%E5%9D%80%E8%B5%84%E6%BA%90">http://www.baidu.com&quot;)--&gt;注入网址资源</a></li>
<li>@Value (&quot;\({book.name}&quot; ) --&gt; 注入配置文件  注意: 使用的是\) 而不是 #</li>
</ul></li>
<li>@PostConstruct : 在构造函数执行完之后执行</li>
<li>@PreDestroy  : 在 Bean 销毁之前执行</li>
<li>@ActiveProfiles : 用来声明活动的 profile</li>
<li>@profile: 为不同环境下使用不同的配置提供了支持<br/>
@Profile(&quot;dev&quot;) .......对方法名为 dev-xxxx的方法提供实例化Bean</li>
<li>@EnableAsync : 开启异步任务的支持(多线程)</li>
<li>@Asyns : 声明这是一个异步任务,可以在类级别 和方法级别声明.</li>
<li>@EnableScheduling : 开启对计划任务的支持(定时器)</li>
<li>@Scheduled : 声明这是一个计划任务 支持多种计划任务,包含 cron. fixDelay fixRate</li>
<li>@Scheduled (dixedDelay = 5000) 通过注解 定时更新</li>
<li>@Conditional : 条件注解,根据满足某一特定条件创建一个特定的Bean</li>
<li>@ContextConfiguration : 加载配置文件</li>
<li>@ContextConfiguration(classes = {TestConfig.class})<br/>
@ContextConfiguration用来加载ApplicationContext <br/>
classes属性用来加载配置类</li>
<li>@WebAppCofiguration : 指定加载 ApplicationContext是一个WebApplicationContext</li>
</ul>

<h3 id="toc_5">@Enable*注解:</h3>

<ul>
<li>@EnableAsync : 开启异步任务的支持(多线程)</li>
<li>@EnableScheduling : 开启对计划任务的支持(定时器)</li>
<li>@EnableWebMVC : 开启对Web MVC 的配置支持</li>
<li>@EnableAaspectJAutoProxy : 开启Spring 对 这个切面(Aspect )的支持</li>
<li>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</li>
<li>@EnableJpaRepositories : 开启对Spring Data JAP Repository 的支持</li>
<li>@EnableTransactionManagement 开启对注解式事物的支持</li>
<li>@EnableCaching开启注解是缓存的支持.</li>
<li>@EnableDiscoveryClient 让服务发现服务器,使用服务器.Spring cloud 实现服务发现</li>
<li>@EnableEurekaServer 注册服务器 spring cloud 实现服务注册@</li>
<li>@EnableScheduling 让spring可以进行任务调度,功能类似于spring.xml文件中的命名空间</li>
<li>@EnableCaching 开启Cache缓存支持;</li>
</ul>

<h3 id="toc_6">SpringMVC 常用注解:</h3>

<ul>
<li>@Controller : 注解在类上 声明这个类是springmvc里的Controller,将其声明为一个spring的Bean.</li>
<li>@RequestMapping :可以注解在类上和方法上 映射WEB请求(访问路径和参数)<br/>
@RequestMapping(value= &quot;/convert&quot;,produces+{&quot;application/x-wisely&quot;}) 设置访问URL 返回值类型</li>
<li>@ResponseBody : 支持将返回值放入response体内 而不是返回一个页面(返回的是一个组数据)</li>
<li>@RequestBody : 允许request的参数在request体中,而不是直接连接在地址后面 次注解放置在参数前</li>
<li>@Path Variable : 用来接收路径参数 如/test/001,001为参数,次注解放置在参数前</li>
<li>@RestController : @Controller + @ResponseBody 组合注解</li>
<li>@ControllerAdvice : 通过@ControllerAdvice可以将对已控制器的全局配置放置在同一个位置</li>
<li>@ExceptionHandler : 用于全局处理控制器的异常</li>
<li>@ExceptionHandier(value=Exception.class) --&gt;通过value属性可过滤拦截器条件,拦截所有的异常</li>
<li>@InitBinder : 用来设置WebDataBinder , WebDataBinder用来自动绑定前台请求参数到Model中.</li>
<li>@ModelAttrbuute : 绑定键值对到Model中,</li>
<li>@RunWith : 运行器 </li>
<li>@RunWith(JUnit4.class)就是指用JUnit4来运行<br/>
@RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境<br/>
@RunWith(Suite.class)的话就是一套测试集合，</li>
<li>@WebAppConfiguration(&quot;src/main/resources&quot;) : 注解在类上,用来声明加载的ApplicationContex 是一个WebApplicationContext ,它的属性指定的是Web资源的位置,默认为 src/main/webapp ,自定义修改为 resource</li>
<li>@Before : 在 xxx 前初始化</li>
</ul>

<h3 id="toc_7">Spring Boot 注解:</h3>

<ul>
<li>@SpringBootApplication : 是Spring Boot 项目的核心注解 主要目的是开启自动配置</li>
<li>@SpringBootApplication注解是一个组合注解,主要组合了@Configuration .+@EnableAutoConfiguration.+@ComponentScan</li>
<li>@Value : 属性注入,读取properties或者 Yml 文件中的属性</li>
<li>@ConfigurationProperties : 将properties属性和一个Bean及其属性关联,从而实现类型安全的配置</li>
<li>@ConfigurationProperties(prefix = &quot;author&quot;,locations = {&quot;classpath:config/author.properties&quot;}),通过@ConfigurationProperties加载配置,通过prefix属性指定配置前缀,通过location指定配置文件位置</li>
<li>@EnableAutoConfiguration 注解:作用在于让 Spring Boot   根据应用所声明的依赖来对 Spring 框架进行自动配置,这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于<code>spring-boot-starter-web</code>添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。</li>
<li>@Configuration @EnableAutoConfiguration (exclude={xxxx.class}) 禁用特定的自动配置</li>
<li>@SpringBootApplication   注解等价于以默认属性使用 @Configuration，@EnableAutoConfiguration和     @ComponentScan。</li>
</ul>

<h3 id="toc_8">@SuppressWarnings注解</h3>

<ul>
<li>@SuppressWarnings(&quot;unchecked&quot;)<br/>
告诉编译器忽略 unchecked 警告信息,如使用 list ArrayList等未进行参数化产生的警告信息</li>
<li>@SuppressWarnings(&quot;serial&quot;)</li>
<li>如果编译器出现这样的警告信息: The serializable class WmailCalendar does not declare a static final serialVersionUID field of type long     使用这个注释将警告信息去掉。</li>
<li>@SuppressWarnings(&quot;deprecation&quot;)<br/>
如果使用了使用@Deprecated注释的方法，编译器将出现警告信息。使用这个注释将警告信息去掉。</li>
<li>@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;),告诉编译器同时忽略unchecked和deprecation的警告信息。</li>
<li>@SuppressWarnings(value={&quot;unchecked&quot;, &quot;deprecation&quot;}), 等同于@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)</li>
</ul>

<h4 id="toc_9">案例</h4>

<pre><code class="language-java">@Entity
@Table(name = &quot;S_PRODUCEINFO&quot; )
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProduceInfoEntity {

    @Id
    @Column(name = &quot;app_name&quot;, unique = true, length = 50)
    private String name;
    
    @Column(name = &quot;status&quot;)
    @Enumerated(EnumType. STRING)
    private ProduceStatus status;
    
    @Column(name = &quot;create_time&quot;, updatable = false)
    @Temporal(TemporalType. TIMESTAMP)
    @CreationTimestamp
    private Date createTime;

    @Column(name = &quot;update_time&quot;)
    @Temporal(TemporalType. TIMESTAMP)
    @UpdateTimestamp
    private Date updateTime;
}
</code></pre>

<h3 id="toc_10">@Entity : 映射数据库实体类</h3>

<ul>
<li>@Table(name = &quot;S_PRODUCEINFO&quot; ) : 表名为 &quot;S_PRODUCEINFO&quot;</li>
<li>@Id : 声明主键ID</li>
<li>@Column(name = &quot;app_name&quot;, unique = true, length = 50) :对应数据库字段,属性</li>
<li>@Enumerated(EnumType. STRING) : 采用枚举值类型和数据库字段进行交互 </li>
<li>@Temporal : 时间格式 映射数据库会得到规定时间格式的日期</li>
<li>@Enumerted(EnumType.STRING)  HH:MM:SS 格式的日期</li>
<li>@Enumerted(EnumType.DATE) 获取年月日  yyyy-MM-dd </li>
<li>@Enumerted(EnumType.TIME) 获取时分秒  HH:MM:<br/>
       </li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAVA8新特性]]></title>
    <link href="https://books.sangkf.cn/15509161097880.html"/>
    <updated>2019-02-23T18:01:49+08:00</updated>
    <id>https://books.sangkf.cn/15509161097880.html</id>
    <content type="html"><![CDATA[
<p>原文地址 <a href="https://www.cnblogs.com/huyunfan/p/7456535.html">https://www.cnblogs.com/huyunfan/p/7456535.html</a></p>

<ul>
<li><p><strong>default拓展方法</strong></p>
<p>default关键字为接口声明添加非抽象方法的实现,也称为拓展方法<br/>
<span id="more"></span><!-- more --></p>
<pre><code class="language-java">public interface Formula {
  void doSomething();<br/>
  default void before() {<br/>
      System.out.println(&quot;我是拓展方法&quot;);<br/>
  }<br/>
}<br/>
public class FormulaService implements Formula {<br/>
  @Override<br/>
  public void doSomething() {<br/>
      before();<br/>
      System.out.println(&quot;我是override方法&quot;);<br/>
  }<br/>
}
</code></pre></li>
<li><p><strong>Lambda表达式</strong></p>
<p>java8引入函数式编程，Lambda则是函数式编程的基础。</p>
<pre><code class="language-java">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
// java8之前<br/>
Collections.sort(list, new Comparator&lt;String&gt;(){<br/>
  @Override<br/>
  public int compare(String o1, String o2) {<br/>
      return o1.compareTo(o2);<br/>
  }<br/>
});<br/>
// lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt; {<br/>
          return o2.compareTo(o1);<br/>
});<br/>
// 简洁lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt;  o2.compareTo(o1));<br/>
// 更简洁lambda<br/>
Collections.sort(list, (o1, o2) -&gt;  o2.compareTo(o1));<br/>
// 也可以这样写<br/>
Collections.sort(list, Comparator.comparing(String::toString));
</code></pre></li>
<li><p><strong>函数式接口</strong></p>
<p>一个函数式接口有且只能有一个抽象方法申明，其中该注意的是 @FunctionalInterface 注解，此时如果在接口中定义了第二个抽象方法，编译器将会抛出异常。当然如果不加该注解也不是不行，如果接口中有多个抽象方法，而你又使用了lambda表达式，则在调用处会抛出异常。</p>
<pre><code class="language-java">@FunctionalInterface
public interface Formula&lt;F,T&gt;{<br/>
  T convert(F var1);<br/>
}<br/>
Formula&lt;String,Integer&gt; function = (var1 -&gt; Integer.valueOf(var1));<br/>
Integer var2 = function.convert(&quot;1000&quot;); 
</code></pre></li>
<li><p><strong>方法和构造函数引用</strong></p>
<p>方法引用的标准语法是 <code>类名:方法名</code></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用静态方法</td>
<td>targetClass :: staticMethodName</td>
</tr>
<tr>
<td>引用某个对象的实例方法</td>
<td>targetClass :: instanceMethodName</td>
</tr>
<tr>
<td>引用某个类型的任意对象的实例方法</td>
<td>targetType :: methodName</td>
</tr>
<tr>
<td>引用构造方法</td>
<td>className :: new</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>引用静态方法</strong></li>
</ol>
<pre><code class="language-java">Formula&lt;String,Integer&gt; function = (Integer::valueOf);
Integer var2 = function.convert(&quot;1000&quot;);
</code></pre>
<ol>
<li><strong>引用某个类型的任意对象的实例方法</strong></li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
   String[] array = {&quot;贱明&quot;, &quot;学友&quot;};<br/>
   Arrays.sort(array, String::compareTo);<br/>
}
</code></pre>
<ol>
<li><strong>引用构造方法</strong></li>
</ol>
<pre><code class="language-java">// 定义工厂
interface PersonFactory&lt;P extends Person&gt;{<br/>
    P create(String name);<br/>
}<br/>
// Person类的构造方法<br/>
public Person(String name) {<br/>
    this.name = name;<br/>
}<br/>
// 创建<br/>
PersonFactory&lt;Person&gt; factory = Person::new;<br/>
factory.create(&quot;贱明&quot;);
</code></pre></li>
<li><p><strong>Lambda的范围</strong></p>
<p>lambda可以访问局部对应的外部区域的局部final变量，以及成员变量和静态变量。</p>
<ol>
<li><p><strong>访问成员变量</strong></p>
<pre><code class="language-java">public void doSomething(){
 final String p1 = &quot;贱明&quot;;<br/>
 final String p2 = &quot;学友&quot;;<br/>
 Formula function = (person1, person2) -&gt; p1.compareTo(p2);<br/>
}
</code></pre>
<p>与java8以下版本不同的是，p1 p2你可以不修饰成final 也不会报错，但是如果你想修改他们，编译器则会告诉你这是不被允许的。</p></li>
<li><p><strong>访问成员变量和静态变量</strong></p>
<pre><code class="language-java">public void doSomething(){;
Formula function = (person1, person2) -&gt;{<br/>
    dehua = &quot;贱明&quot;;<br/>
    xueyou=&quot;学友&quot;;<br/>
    return dehua.compareTo(xueyou);<br/>
};<br/>
}
</code></pre></li>
</ol></li>
<li><p><strong>内置函数式接口</strong></p>
<p>​     java8 api中提供了很多内置函数式接口，而且有些接口其实在Google Guava中已经实现了，很大程  度的降低了程序员的工作负担。</p>
<ol>
<li><p><strong>Predicates</strong><br/>
Predicate是一个布尔类型的函数，该函数只有一个输入参数，他包含了多种默认实现。</p>
<pre><code class="language-java">public static void main(String[] args) {
Predicate&lt;String&gt; predicate = (s) -&gt; s.contains(&quot;贱明&quot;);<br/>
String var1 = &quot;牛贱明&quot;;<br/>
predicate.test(var1);              // true<br/>
predicate.negate().test(var1);     // false<br/>
Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;<br/>
Predicate&lt;Boolean&gt; isNull = Objects::isNull;<br/>
Predicate&lt;String&gt; isEmpty = String::isEmpty;<br/>
Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();<br/>
isNotEmpty.and(isEmpty).test(var1);<br/>
}
</code></pre></li>
<li><p><strong>Functions</strong></p>
<p>Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起</p>
<pre><code class="language-java">public static void main(String[] args) {
Function&lt;String, Integer&gt; toInteger = Integer::valueOf;<br/>
Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);<br/>
System.out.println(toInteger.apply(&quot;123&quot;));<br/>
System.out.println(backToString.apply(&quot;123&quot;));<br/>
}
</code></pre></li>
<li><p><strong>Suppliers</strong></p>
<p>Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。</p>
<pre><code class="language-java">Supplier&lt;Person&gt; personSupplier = Person::new;
Person p = personSupplier.get();   // new Person
</code></pre></li>
<li><p><strong>Consumers</strong></p>
<p>Consumer代表了在一个输入参数上需要进行的操作。</p>
<pre><code class="language-java">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.getName());
greeter.accept(new Person(&quot;贱明&quot;));
</code></pre></li>
<li><p><strong>Comparators</strong></p>
<p>Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。</p>
<pre><code class="language-java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.getName().compareTo(p2.getName());
Person p1 = new Person(&quot;贱明&quot;);<br/>
Person p2 = new Person(&quot;学友&quot;);<br/>
System.out.println(comparator.compare(p1, p2));             // &gt; 1105<br/>
System.out.println(comparator.reversed().compare(p1, p2));  // &lt; -1105
</code></pre></li>
<li><p><strong>Optionals</strong></p>
<p>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerException产生。<br/>
Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional。</p>
<pre><code class="language-java">Optional&lt;String&gt; optional = Optional.of(&quot;贱明&quot;);
System.out.println(optional.isPresent()); // true      <br/>
System.out.println(optional.get()); // 贱明   <br/>
System.out.println(optional.orElse(&quot;学友&quot;)); // 贱明    <br/>
optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); 
</code></pre></li>
</ol></li>
</ul>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[h5仿微信聊天(高仿版)、微信聊天表情|对话框|编辑器]]></title>
    <link href="https://books.sangkf.cn/15508991872164.html"/>
    <updated>2019-02-23T13:19:47+08:00</updated>
    <id>https://books.sangkf.cn/15508991872164.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>转载 <a href="https://www.cnblogs.com/xiaoyan2017/p/8912054.html">https://www.cnblogs.com/xiaoyan2017/p/8912054.html</a></p>
</blockquote>

<p>之前做过一版h5微信聊天移动端，这段时间闲来无事就整理了下之前项目，又重新在原先的那版基础上升级了下，如是就有了现在的h5仿微信聊天高仿版，新增了微聊、通讯录、探索、我四个模块 左右触摸滑屏切换，聊天页面优化了多图预览、视频播放，长按菜单UI，聊天底部编辑器重新优化整理(新增多表情)，弹窗则用到了自己开发的wcPop.js，具体看项目效果图吧！<br/>
<span id="more"></span><!-- more --></p>

<pre><code class="language-markup">&lt;!-- //微聊底部功能面板 --&gt;
&lt;div class=&quot;wc__footTool-panel&quot;&gt;
    &lt;!-- 输入框模块 --&gt;
    &lt;div class=&quot;wc__editor-panel wc__borT flexbox&quot;&gt;
        &lt;div class=&quot;wrap-editor flex1&quot;&gt;&lt;div class=&quot;editor J__wcEditor&quot; contenteditable=&quot;true&quot;&gt;&lt;/div&gt;&lt;/div&gt;
        &lt;i class=&quot;btn btn-emotion&quot;&gt;&lt;/i&gt;
        &lt;i class=&quot;btn btn-choose&quot;&gt;&lt;/i&gt;
        &lt;button class=&quot;btn-submit J__wchatSubmit&quot;&gt;发送&lt;/button&gt;
    &lt;/div&gt;

    &lt;!-- 表情、选择模块 --&gt;
    &lt;div class=&quot;wc__choose-panel wc__borT&quot; style=&quot;display: none;&quot;&gt;
        &lt;!-- 表情区域 --&gt;
        &lt;div class=&quot;wrap-emotion&quot; style=&quot;display: none;&quot;&gt;
            &lt;div class=&quot;emotion__cells flexbox flex__direction-column&quot;&gt;
                &lt;div class=&quot;emotion__cells-swiper flex1&quot; id=&quot;J__swiperEmotion&quot;&gt;
                    &lt;div class=&quot;swiper-container&quot;&gt;
                        &lt;div class=&quot;swiper-wrapper&quot;&gt;&lt;/div&gt;
                        &lt;div class=&quot;pagination-emotion&quot;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;emotion__cells-footer&quot; id=&quot;J__emotionFootTab&quot;&gt;
                    &lt;ul class=&quot;clearfix&quot;&gt;
                        &lt;li class=&quot;swiperTmpl cur&quot; tmpl=&quot;swiper__tmpl-emotion01&quot;&gt;&lt;img src=&quot;img/emotion/face01/face-lbl.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion02&quot;&gt;&lt;img src=&quot;img/emotion/face02/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion03&quot;&gt;&lt;img src=&quot;img/emotion/face03/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion04&quot;&gt;&lt;img src=&quot;img/emotion/face04/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion05&quot;&gt;&lt;img src=&quot;img/emotion/face05/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion06&quot;&gt;&lt;img src=&quot;img/emotion/face06/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmplSet&quot;&gt;&lt;img src=&quot;img/wchat/icon__emotion-set.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 选择区域 --&gt;
        &lt;div class=&quot;wrap-choose&quot; style=&quot;display: none;&quot;&gt;
            &lt;div class=&quot;choose__cells&quot;&gt;
                &lt;ul class=&quot;clearfix&quot;&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatZp&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-zp.png&quot; /&gt;&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; /&gt;&lt;/span&gt;&lt;em&gt;照片&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatSp&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-sp.png&quot; /&gt;&lt;input type=&quot;file&quot; accept=&quot;video/*&quot; /&gt;&lt;/span&gt;&lt;em&gt;视频&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatHb&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-hb.png&quot; /&gt;&lt;/span&gt;&lt;em&gt;红包&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatSc&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-sc.png&quot; /&gt;&lt;/span&gt;&lt;em&gt;我的收藏&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatWj&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-wj.png&quot; /&gt;&lt;/span&gt;&lt;em&gt;文件&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;wc__choosePanel-tmpl&quot;&gt;
    &lt;!-- //红包模板.begin --&gt;
    &lt;div id=&quot;J__popupTmpl-Hongbao&quot; style=&quot;display:none;&quot;&gt;
        &lt;div class=&quot;wc__popupTmpl tmpl-hongbao&quot;&gt;
            &lt;i class=&quot;wc-xclose&quot;&gt;&lt;/i&gt;
            &lt;ul class=&quot;clearfix&quot;&gt;
                &lt;li class=&quot;item flexbox&quot;&gt;
                    &lt;label class=&quot;txt&quot;&gt;总金额&lt;/label&gt;&lt;input class=&quot;ipt-txt flex1&quot; type=&quot;tel&quot; name=&quot;hbAmount&quot; placeholder=&quot;0.00&quot; /&gt;&lt;em class=&quot;unit&quot;&gt;元&lt;/em&gt;
                &lt;/li&gt;
                &lt;li class=&quot;item flexbox&quot;&gt;
                    &lt;label class=&quot;txt&quot;&gt;红包个数&lt;/label&gt;&lt;input class=&quot;ipt-txt flex1&quot; type=&quot;tel&quot; name=&quot;hbNum&quot; placeholder=&quot;填写个数&quot; /&gt;&lt;em class=&quot;unit&quot;&gt;个&lt;/em&gt;
                &lt;/li&gt;
                &lt;li class=&quot;tips&quot;&gt;在线人数共&lt;em class=&quot;memNum&quot;&gt;186&lt;/em&gt;人&lt;/li&gt;
                &lt;li class=&quot;item item-area&quot;&gt;
                    &lt;textarea class=&quot;describe&quot; name=&quot;content&quot; placeholder=&quot;恭喜发财，大吉大利&quot;&gt;&lt;/textarea&gt;
                &lt;/li&gt;
                &lt;li class=&quot;amountTotal&quot;&gt;￥&lt;em class=&quot;num&quot;&gt;0.00&lt;/em&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- //红包模板.end --&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-javascript">// ...长按弹出菜单
$(&quot;#J__chatMsgList&quot;).on(&quot;longTap&quot;, &quot;li .msg&quot;, function(e){
    var that = $(this), menuTpl, menuNode = $(&quot;&lt;div class=&#39;wc__chatTapMenu animated anim-fadeIn&#39;&gt;&lt;/div&gt;&quot;);
    that.addClass(&quot;taped&quot;);
    that.parents(&quot;li&quot;).siblings().find(&quot;.msg&quot;).removeClass(&quot;taped&quot;);
    var isRevoke = that.parents(&quot;li&quot;).hasClass(&quot;me&quot;);
    var _revoke = isRevoke ? &quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i4&#39;&gt;&lt;/i&gt;撤回&lt;/a&gt;&quot; : &quot;&quot;;
    
    if(that.hasClass(&quot;picture&quot;)){
        console.log(&quot;图片长按&quot;);
        menuTpl = &quot;&lt;div class=&#39;menu menu-picture&#39;&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i1&#39;&gt;&lt;/i&gt;复制&lt;/a&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i2&#39;&gt;&lt;/i&gt;收藏&lt;/a&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i3&#39;&gt;&lt;/i&gt;另存为&lt;/a&gt;&quot;+ _revoke +&quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i5&#39;&gt;&lt;/i&gt;删除&lt;/a&gt;&lt;/div&gt;&quot;;
    }else if(that.hasClass(&quot;video&quot;)){
        console.log(&quot;视频长按&quot;);
        menuTpl = &quot;&lt;div class=&#39;menu menu-video&#39;&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i3&#39;&gt;&lt;/i&gt;另存为&lt;/a&gt;&quot; + _revoke +&quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i5&#39;&gt;&lt;/i&gt;删除&lt;/a&gt;&lt;/div&gt;&quot;;
    }else{
        console.log(&quot;文字长按&quot;);
        menuTpl = &quot;&lt;div class=&#39;menu menu-text&#39;&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i1&#39;&gt;&lt;/i&gt;复制&lt;/a&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i2&#39;&gt;&lt;/i&gt;收藏&lt;/a&gt;&quot; + _revoke +&quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i5&#39;&gt;&lt;/i&gt;删除&lt;/a&gt;&lt;/div&gt;&quot;;
    }

    if(!$(&quot;.wc__chatTapMenu&quot;).length){
        $(&quot;.wc__chatMsg-panel&quot;).append(menuNode.html(menuTpl));
        autoPos();
    }else{
        $(&quot;.wc__chatTapMenu&quot;).hide().html(menuTpl).fadeIn(250);
        autoPos();
    }

    function autoPos(){
        console.log(that.position().top)
        var _other = that.parents(&quot;li&quot;).hasClass(&quot;others&quot;);
        $(&quot;.wc__chatTapMenu&quot;).css({
            position: &quot;absolute&quot;,
            left: that.position().left + parseInt(that.css(&quot;marginLeft&quot;)) + (_other ? 0 : that.outerWidth() - $(&quot;.wc__chatTapMenu&quot;).outerWidth()),
            top: that.position().top - $(&quot;.wc__chatTapMenu&quot;).outerHeight() - 8
        });
    }
});
</code></pre>

<p><img src="media/15508991872164/15508994793999.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><img src="media/15508991872164/15508994870198.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><img src="media/15508991872164/15508994947946.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995011000.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995078981.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995144669.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995204276.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995255771.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995347731.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[欢迎使用 MWeb]]></title>
    <link href="https://books.sangkf.cn/15474356181402.html"/>
    <updated>2019-01-14T11:13:38+08:00</updated>
    <id>https://books.sangkf.cn/15474356181402.html</id>
    <content type="html"><![CDATA[
<p>MWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件，目前已支持 Mac，iPad 和 iPhone。MWeb 有以下特色：<br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_0">软件本身：</h2>

<ul>
<li>使用原生的 macOS 技术打造，追求与系统的完美结合。</li>
<li>原则上，首先是追求界面简洁和高性能，然后才是强大易用，功能全面。</li>
</ul>

<h2 id="toc_1">Markdown 语法：</h2>

<ul>
<li>使用 Github Flavored Markdown 语法，简称 GFM 语法。</li>
<li>支持表格、TOC、LaTeX、代码块、任务列表、脚注等。</li>
<li>画图库支持 mermaid, viz, echarts, plantuml, sequence, flow。</li>
</ul>

<h2 id="toc_2">Markdown 辅助：</h2>

<ul>
<li>支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。</li>
<li>在兼容 Markdown 语法的情况下支持设置图片宽度。</li>
<li>好用的表格插入和 LaTeX 书写辅助。</li>
</ul>

<h2 id="toc_3">Markdown 输出：</h2>

<ul>
<li>支持导出为图片、HTML、Epub、PDF、RTF、Docx。</li>
<li>支持发布到 Wordrpess、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记（Evernote）、Blogger、Medium、Tumblr。</li>
<li>图片上传服务（图床）支持 Google Photos、Imgur、七牛云、又拍云和自定义的图床服务。</li>
</ul>

<h2 id="toc_4">Markdown 笔记：</h2>

<ul>
<li>强大的文档库支持分类树和标签管理文档，文档可归类于多个分类，可以把分类整个导出为 Epub、PDF 和生成静态网站。非常合适用于笔记、个人知识收集、管理和输出。</li>
<li>快速笔记：随意增加笔记及图片等素材，支持以天为单位把增加的素材组合在一个文档内，方便整理及记录历史收集情况。</li>
<li>快速搜索：目前已支持全局快捷键调出搜索。</li>
</ul>

<h2 id="toc_5">外部 Markdown 文档：</h2>

<ul>
<li>外部 Markdown 文档使用外部模式管理。外部模式使用目录树的方式编辑和管理你的 markdown 文档，还能很好的支持 gitbook、JekyII、hexo 等等编辑和图片插入。</li>
</ul>

<h2 id="toc_6">MWeb 文档：</h2>

<p>如果要更详细了解 MWeb，建议你一定要去看一下官网的帮助文档，网址为：<a href="https://zh.mweb.im/help.html">https://zh.mweb.im/help.html</a>。我们建议在使用文档库之前，一定要阅读一下  <a href="https://zh.mweb.im/mweb-library.html">MWeb 文档库详细介绍</a> 这篇文章，以便更好的使用文档库。</p>

<h2 id="toc_7">帮助我们改进 MWeb</h2>

<p>如果你喜欢 MWeb，想让它变得更好，你可以：</p>

<ol>
<li>推荐 MWeb，让更多的人知道。</li>
<li>给我们发反馈和建议：<a href="mailto:coderforart+2333@gmail.com">coderforart+2333@gmail.com</a></li>
<li>在 Mac App Store 上评价 （如果是在 MAS 上购买的话）。</li>
</ol>

]]></content>
  </entry>
  
</feed>
