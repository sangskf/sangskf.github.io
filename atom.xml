<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[见课就上的小婊砸]]></title>
  <link href="https://books.sangkf.cn/atom.xml" rel="self"/>
  <link href="https://books.sangkf.cn/"/>
  <updated>2019-02-25T17:13:01+08:00</updated>
  <id>https://books.sangkf.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Java 生态圈知识汇总]]></title>
    <link href="https://books.sangkf.cn/15510844326202.html"/>
    <updated>2019-02-25T16:47:12+08:00</updated>
    <id>https://books.sangkf.cn/15510844326202.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">前言</h3>

<blockquote>
<p>有人认为编程是一门技术活，要有一定的天赋，非天资聪慧者不能及也。其实不然，笔者虽是计算机专业出身，但工作年限并不长，对于技术这碗饭有一些心得体会，大多数人成为某领域顶级专家可能会有些难度，但应对日常工作，成长为资深研发工程师、技术专家、甚至成为小团队的Team Leader，其实并不难。<br/>
<span id="more"></span><!-- more --><br/>
<strong>多读书、多看报，多研究常用开源框架的源码，比如：github.com，这里汇集了全球工程师的智慧！</strong></p>
</blockquote>

<p>言归正传，下文会列举工作中常用的一些技术，以及如何锻炼提升自己的架构能力。</p>

<p>由于每块技术市场上基本都有对应的网络资料或书籍，所以本文只是少篇幅列举工作中用到的核心知识点，抛砖引玉，属于进阶型，不适用初学者。</p>

<h3 id="toc_1"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"></a>基础知识</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fjava.md">java</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspring.md">spring</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspringboot.md">spring boot</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspringcloud.md">spring cloud</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fibatis.md">ibatis</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2F%25E5%25B8%25B8%25E7%2594%25A8%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F.md">设计模式</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2FLog4j.md">Log日志</a></li>
</ul>

<h3 id="toc_2"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E6%95%B0%E6%8D%AE%E5%BA%93"></a>数据库</h3>

<p>目前使用最多还是mysql，虽然单机性能比不上oracle，但免费开源，单机成本低且借助于分布式集群，可以有强大的输出能力。</p>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fdatabase-connection-pool.md">连接池</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Ftransaction.md">事务</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2F%25E5%2588%2586%25E5%25BA%2593%25E5%2588%2586%25E8%25A1%25A8.md">分库分表</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fid-generate.md">id生成器</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F6909240">读写分离</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fsql-optimize.md">SQL调优</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fother.md">其它</a></li>
</ul>

<h3 id="toc_3"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#web%E5%AE%B9%E5%99%A8%E5%8D%8F%E8%AE%AE%E7%BD%91%E7%BB%9C"></a>web容器/协议/网络</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fload-balance.md">负载均衡</a></li>
<li>服务器
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2FNginx.md">Nginx</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Ftomcat.md">Tomcat</a></li>
</ul></li>
<li>协议
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fhttp%25E5%258D%258F%25E8%25AE%25AE.md">HTTP 协议</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Ftcp.md">TCP 协议</a></li>
</ul></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2FCDN.md">CDN</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fother.md">其它</a></li>
</ul>

<h3 id="toc_4"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E5%8C%85"></a>常用三方工具包</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FGoole-Guava.md">Google Guava</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FfastJson.md">fastJson</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F17913607">log4J</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-codec.md">commons-codec</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-lang3.md">commons-lang3</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-io.md">commons-io</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FQuartz.md">Quartz</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FHttpClient.md">HttpClient</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F7671294">Javassist</a></li>
</ul>

<h3 id="toc_5"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E4%B8%AD%E9%97%B4%E4%BB%B6"></a>中间件</h3>

<ul>
<li><p>RPC框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fdubbo.md">dubbo</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fdubbox">dubbox</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fweibocom%2Fmotan">motan</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fapache%2Fthrift">Thrift</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Frpc-compare.md">RPC框架性能比较</a></li>
</ul></li>
<li><p>MQ消息</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fapache%2Factivemq">ActiveMQ</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FRabbitMQ.md">RabbitMQ</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fkafka.md">Kafka</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FRocketMQ.md">RocketMQ</a></li>
</ul></li>
<li><p>分布式缓存</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fredis.md">redis</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster">codis</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F8035197">memcache</a></li>
</ul></li>
<li><p>本地缓存</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fguava.md">Guava</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fehcache.md">ehcache</a></li>
</ul></li>
<li><p>搜索</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Felasticsearch.md">Elasticsearch</a></li>
</ul></li>
<li><p>分布式数据框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fcobar.md">cobar</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fmycat.md">Mycat</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Ftsharding.md">tsharding</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Ftb_tddl">tddl</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fsharding-jdbc.md">sharding-jdbc</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgitee.com%2Frobertleepeak%2Fdbsplit">dbsplit</a></li>
</ul></li>
<li><p>分布式协调服务</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fzookeeper.md">zookeeper</a></li>
</ul></li>
<li><p>配置管理</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fsuper-diamond%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590.md">super-diamond</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fdisconf">disconf</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fapollo.md">apollo</a></li>
</ul></li>
<li><p>分布式文件系统</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FFastDFS.md">FastDFS</a></li>
</ul></li>
<li><p>分布式任务调度框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Felasticjob%2Felastic-job">Elastic-Job</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Fdangdang-distributed-work-framework-elastic-job">详解当当网的分布式作业框架elastic-job</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Ftaosir_zhang%2Farticle%2Fdetails%2F50728362">TBSchedule</a></li>
</ul></li>
<li><p>大数据</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHbase.md">Hbase</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FSpark.md">Spark</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHadoop.md">Hadoop</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHive.md">Hive</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fbig-data.md">other框架</a></li>
</ul></li>
<li><p>其它</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fcanal">数据库binlog的增量订阅&amp;消费组件</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fotter">数据库同步系统</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FTCC-Transaction.md">TCC-Transaction</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FNetty.md">Netty</a></li>
</ul></li>
</ul>

<h3 id="toc_6"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"></a>系统架构</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Farchitecture-experience.md">架构经验</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Farchitecture-good-case.md">经典案例</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Ftechnology-selection.md">通用技术方案选型</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2F%25E7%25BC%2596%25E7%25A0%2581%25E5%2589%258D3000%25E9%2597%25AE.md">编码前3000问</a></li>
</ul>

<h3 id="toc_7"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"></a>项目管理</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2F%25E8%25AE%25BA%25E9%259C%2580%25E6%25B1%2582%25E8%25B0%2583%25E7%25A0%2594%25E7%259A%2584%25E9%2587%258D%25E8%25A6%2581%25E6%2580%25A7.md">论需求调研的重要性</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Fproject-management.md">项目管理</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Fcode.md">代码管理</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Ftest.md">测试相关</a></li>
</ul>

<h3 id="toc_8"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E8%BF%90%E7%BB%B4"></a>运维</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Fonline-question.md">快速排查线上问题</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Flinux-commands.md">linux常用命令</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2F%25E6%259C%25AC%25E5%259C%25B0%25E4%25BB%25A3%25E7%25A0%2581%25E8%25B0%2583%25E8%25AF%2595.md">本地代码调试</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Fdocker.md">Docker</a></li>
</ul>

<h3 id="toc_9"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF"></a>个人成长</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fstudy.md">学习网站</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fbook.md">Tom哥的读书单</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fperson.md">个人成长与职业规划</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fprogramer.md">程序员素养</a></li>
</ul>

<h3 id="toc_10"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%85%B6%E5%AE%83"></a>其它</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Ftool.md">常用软件工具</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2F%25E4%25B8%2580%25E8%2587%25B4%25E6%2580%25A7hash.md">一致性hash算法</a></li>
<li>面试
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fjava-interview.md">java面试题</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fbigdata-interview.md">大数据面试题</a></li>
</ul></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2F%25E5%259B%259E%25E8%25BD%25A6%25E4%25B8%258E%25E6%258D%25A2%25E8%25A1%258C%25E7%259A%2584%25E5%258C%25BA%25E5%2588%25AB.md">回车与换行的区别</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fqq1332479771%2Farticle%2Fdetails%2F56087333">github上fork项目后，如何同步更新后面提交</a></li>
</ul>

<blockquote>
<p>原文地址：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk">github.com/aalansehaiy…</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[限流设计]]></title>
    <link href="https://books.sangkf.cn/15510821177382.html"/>
    <updated>2019-02-25T16:08:37+08:00</updated>
    <id>https://books.sangkf.cn/15510821177382.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>限流，书面意思和作用一致，就是为了限制，通过对并发访问或者请求进行限速或者一个时间窗口内的请求进行限速来保护系统。一旦达到了限制的临界点，可以用拒绝服务、排队、或者等待的方式来保护现有系统，不至于发生雪崩现象。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>限流就像做帝都的地铁一般，如果你住在西二旗或者天通苑也许会体会的更深刻一些。我更习惯在技术角度用消费者的角度来阐述，需要限流的一般原因是消费者能力有限，目的为了避免超过消费者能力而出现系统故障。当然也有其他类似的情况也可以用限流来解决。</p>

<p>限流的表现形式上大部分可以分为两大类：</p>

<ul>
<li>限制消费者数量。也可以说消费的最大能力值。比如：数据库的连接池是侧重的是总的连接数，本质上也是限制了消费者的最大消费能力。</li>
<li>可以被消费的请求数量。这里的数量可以是瞬时并发数，也可以是一段时间内的总并发数。</li>
</ul>

<p>除此之外，限流还有别的表现形式，例如按照网络流量来限流，按照cpu使用率来限流等。按照限流的范围又可以分为分布式限流，应用限流，接口限流等。无论怎么变化，限流都可以用以下图来表示：</p>

<p><img src="media/15510821177382/15510824198802.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_0">常用技术实现</h2>

<ul>
<li>令牌桶算法<br/>
令牌桶是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌，填满了就丢弃令牌，请求是否被处理要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求。令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌。令牌桶中装的是令牌。
<img src="media/15510821177382/15510825111049.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></li>
<li><p>漏桶算法<br/>
漏桶一个固定容量的漏桶，按照固定常量速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝。漏桶可以看做是一个具有固定容量、固定流出速率的队列，漏桶限制的是请求的流出速率。漏桶中装的是请求。</p></li>
<li><p>计数器<br/>
 有时我们还会使用计数器来进行限流，主要用来限制一定时间内的总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流，是一种简单粗暴的总数量限流，而不是平均速率限流。</p></li>
</ul>

<h2 id="toc_1">不用算法的解决方案</h2>

<p>我们可以用一个按照时间段限制请求总数的方式来限流。 总体思路是这样：</p>

<ul>
<li>用一个环形来代表通过的请求容器。</li>
<li>用一个指针指向当前请求所到的位置索引，来判断当前请求时间和当前位置上次请求的时间差，依此来判断是否被限制。</li>
<li>如果请求通过，则当前指针向前移动一个位置，不通过则不移动位置</li>
<li>重复以上步骤 直到永远.......</li>
</ul>

<p><img src="media/15510821177382/15510827864849.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_2">核心代码</h2>

<blockquote>
<p>以下代码的核心思路是这样的：指针当前位置的时间元素和当前时间的差来决定是否允许此次请求，这样通过的请求在时间上表现的比较平滑。</p>
</blockquote>

<pre><code class="language-java">//限流组件,采用数组做为一个环
    class LimitService
    {
        //当前指针的位置
        int currentIndex = 0;
        //限制的时间的秒数，即：x秒允许多少请求
        int limitTimeSencond = 1;
        //请求环的容器数组
        DateTime?[] requestRing = null;
        //容器改变或者移动指针时候的锁
        object objLock = new object();

        public LimitService(int countPerSecond,int  _limitTimeSencond)
        {
            requestRing = new DateTime?[countPerSecond];
            limitTimeSencond= _limitTimeSencond;
        }

        //程序是否可以继续
        public bool IsContinue()
        {
            lock (objLock)
            {
                var currentNode = requestRing[currentIndex];
                //如果当前节点的值加上设置的秒 超过当前时间，说明超过限制
                if (currentNode != null&amp;&amp; currentNode.Value.AddSeconds(limitTimeSencond) &gt;DateTime.Now)
                {
                    return false;
                }
                //当前节点设置为当前时间
                requestRing[currentIndex] = DateTime.Now;
                //指针移动一个位置
                MoveNextIndex(ref currentIndex);
            }            
            return true;
        }
        //改变每秒可以通过的请求数
        public bool ChangeCountPerSecond(int countPerSecond)
        {
            lock (objLock)
            {
                requestRing = new DateTime?[countPerSecond];
                currentIndex = 0;
            }
            return true;
        }

        //指针往前移动一个位置
        private void MoveNextIndex(ref int currentIndex)
        {
            if (currentIndex != requestRing.Length - 1)
            {
                currentIndex = currentIndex + 1;
            }
            else
            {
                currentIndex = 0;
            }
        }
    }
</code></pre>

<p>测试程序如下：</p>

<pre><code class="language-java">static  LimitService l = new LimitService(1000, 1);
        static void Main(string[] args)
        {
            int threadCount = 50;
            while (threadCount &gt;= 0)
            {
                Thread t = new Thread(s =&gt;
                {
                    Limit();
                });
                t.Start();
                threadCount--;
            }           

            Console.Read();
        }

        static void Limit()
        {
            int i = 0;
            int okCount = 0;
            int noCount = 0;
            Stopwatch w = new Stopwatch();
            w.Start();
            while (i &lt; 1000000)
            {
                var ret = l.IsContinue();
                if (ret)
                {
                    okCount++;
                }
                else
                {
                    noCount++;
                }
                i++;
            }
            w.Stop();
            Console.WriteLine($&quot;共用{w.ElapsedMilliseconds},允许：{okCount},  拦截：{noCount}&quot;);
        }
</code></pre>

<p>测试结果如下：</p>

<p><img src="media/15510821177382/15510829240788.jpg" alt=""/><br/>
<img src="media/15510821177382/15510829535558.jpg" alt=""/><br/>
最大用时15秒,共处理请求1000000*50=50000000 次</p>

<p>并未发生GC操作，内存使用率非常低，每秒处理 300万次+请求 。以上程序修改为10个线程，大约用时4秒之内<br/>
<img src="media/15510821177382/15510829711440.jpg" alt=""/></p>

<p>如果是强劲的服务器或者线程数较少情况下处理速度将会更快</p>

<blockquote>
<p>[转载]<a href="https://www.cnblogs.com/zhanlang/p/10424757.html">https://www.cnblogs.com/zhanlang/p/10424757.html</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JDK动态代理]]></title>
    <link href="https://books.sangkf.cn/15510682951931.html"/>
    <updated>2019-02-25T12:18:15+08:00</updated>
    <id>https://books.sangkf.cn/15510682951931.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>[转载]<a href="https://blog.csdn.net/xiaokang123456kao/article/details/77679848">https://blog.csdn.net/xiaokang123456kao/article/details/77679848</a></p>
</blockquote>

<h2 id="toc_0">代理的含义</h2>

<ul>
<li>代理类的目的是为其他对象提供一个代理以控制对某个对象的访问。
<span id="more"></span><!-- more --></li>
<li>代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</li>
<li>为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。</li>
<li>通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好的隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</li>
</ul>

<h2 id="toc_1">动态代理相关类介绍</h2>

<ol>
<li><p>InvocationHandler</p>
<pre><code class="language-text">每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联了一个Handler,当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的Invoke方法来进行调用。
</code></pre>
<p>InvocationHandler这个接口的唯一一个方法invoke方法:</p>
<pre><code class="language-java">Object invoke(Object proxy, Method method, Object[] args) throws Throwable
</code></pre>
<p>三个参数:</p>
<ul>
<li>proxy： 指代JDK动态生成的最终代理对象</li>
<li>method：指代的是我们所要调用真是对象的某个方法的Method对象</li>
<li>args: 指代的是调用真是对象的某个方法时接收的参数</li>
</ul></li>
<li><p>Proxy</p>
<p>​    Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法</p>
<pre><code class="language-java">public static Object newProxyInstance(ClassLoader loader,
                                         Class&lt;?&gt;[] interfaces,<br/>
                                         InvocationHandler h)<br/>
       throws IllegalArgumentException
</code></pre>
<p>这个方法的作用就是得到一个动态的代理对象，其接收三个参数，我们来看看这三个参数所代表的含义：</p>
<ul>
<li>loader:　一个ClassLoader对象，定义了由哪个ClassLoader来对生成的代理对象进行加载</li>
<li>interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</li>
<li>一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</li>
</ul>
<p>其实我们所说的DynamicProxy（动态代理类）是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些 interface。如此一来，我们可以把该class的实例当作这些interface中的任何一个来用（可以强转为相应的接口类型）。当然，这个DynamicProxy其实就是一个Proxy，它不会做实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</p>
<ul>
<li>
<a href="#toc_0">代理的含义</a>
</li>
<li>
<a href="#toc_1">动态代理相关类介绍</a>
</li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql大表优化方案]]></title>
    <link href="https://books.sangkf.cn/15510645880732.html"/>
    <updated>2019-02-25T11:16:28+08:00</updated>
    <id>https://books.sangkf.cn/15510645880732.html</id>
    <content type="html"><![CDATA[
<p><a href="https://yq.aliyun.com/articles/679881?spm=a2c4e.11155472.0.0.ae1e42459WcIqo">原文地址</a><br/>
<a href="https://yq.aliyun.com/articles/679881?spm=a2c4e.11155472.0.0.ae1e42459WcIqo">https://yq.aliyun.com/articles/679881?spm=a2c4e.11155472.0.0.ae1e42459WcIqo</a></p>

<h2 id="toc_0">单表优化方案</h2>

<blockquote>
<p>除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量。<br/>
<span id="more"></span><!-- more --></p>

<ol>
<li><strong>字段优化总结</strong></li>
</ol>
</blockquote>

<ul>
<li>尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED</li>
<li>VARCHAR的长度只分配真正需要的空间</li>
<li>使用枚举或整数代替字符串类型</li>
<li>尽量使用TIMESTAMP而非DATETIME</li>
<li>单表不要有太多字段，建议在20以内</li>
<li>避免使用NULL字段，很难查询优化且占用额外索引空间</li>
<li><p>用整型来存IP</p></li>
</ul>

<ol>
<li><p><strong>索引优化总结</strong></p>
<ul>
<li>索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描</li>
<li>应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>值分布很稀少的字段不适合建索引，例如&quot;性别&quot;这种只有两三个值的字段</li>
<li>字符字段只建前缀索引</li>
<li>字符字段最好不要做主键</li>
<li>不用外键，由程序保证约束</li>
<li>尽量不用UNIQUE，由程序保证约束</li>
<li>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引</li>
</ul></li>
<li><p><strong>查询SQL优化总结</strong></p>
<ul>
<li>可通过开启慢查询日志来找出较慢的SQL</li>
<li>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</li>
<li>sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库</li>
<li>不用SELECT *</li>
<li>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内</li>
<li>不用函数和触发器，在应用程序实现</li>
<li>避免%xxx式查询</li>
<li>少用JOIN</li>
<li>使用同类型进行比较，比如用&#39;123&#39;和&#39;123&#39;比，123和123比</li>
<li>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描</li>
<li>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5</li>
<li>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</li>
</ul></li>
<li><p><strong>引擎的选择</strong></p>
<p>目前广泛使用的是MyISAM和InnoDB两种引擎。</p>
<ul>
<li><p><strong>MyISAM</strong></p>
<p><strong>MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：</strong></p>
<ul>
<li>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</li>
<li>不支持事务</li>
<li>不支持外键</li>
<li>不支持崩溃后的安全恢复</li>
<li>在表有读取查询的同时，支持往表中插入新纪录</li>
<li>支持BLOB和TEXT的前500个字符索引，支持全文索引</li>
<li>支持延迟更新索引，极大提升写入性能</li>
<li>对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用</li>
</ul></li>
<li><p><strong>InnoDB</strong></p>
<p><strong>InnoDB在MySQL 5.5后成为默认索引，它的特点是：</strong></p>
<ul>
<li>支持行锁，采用MVCC来支持高并发</li>
<li>支持事务</li>
<li>支持外键</li>
<li>支持崩溃后的安全恢复</li>
<li>不支持全文索引</li>
</ul></li>
</ul>
<p>总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表</p></li>
<li><p><strong>系统调优参数</strong></p>
<p>1）back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500；</p>
<p>2）wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时；</p>
<p>3）max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限；</p>
<p>4）thread_concurrency：并发线程数，设为CPU核数的两倍；</p>
<p>5）skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问；</p>
<p>6）key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询show status like &#39;key_read%&#39;，保证key_reads / key_read_requests在0.1%以下最好；</p>
<p>7）innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询show status like &#39;Innodb_buffer_pool_read%&#39;，保证 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests越高越好；</p>
<p>8）innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小；</p>
<p>9）innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB；</p>
<p>10）query_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大；</p>
<p>11）可以通过命令show status like &#39;Qcache_%&#39;查看目前系统Query catch使用大小；</p>
<p>12）read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能；</p>
<p>13）sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小；</p>
<p>14）read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大；</p>
<p>15）record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值；</p>
<p>16）thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的；</p>
<p>17）table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM。</p></li>
<li><p><strong>升级硬件</strong></p>
<p>Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能。</p></li>
</ol>

<h2 id="toc_1">读写分离</h2>

<p>也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离</p>

<h2 id="toc_2">缓存</h2>

<p><strong>缓存可以发生在这些层次：</strong></p>

<p>1）MySQL内部：在系统调优参数介绍了相关设置；</p>

<p>2）数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象Persistence Object；</p>

<p>3）应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象Data Transfer Object；</p>

<p>4）Web层：针对web页面做缓存；</p>

<p>5）浏览器客户端：用户端的缓存。</p>

<p>可以根据实际情况在一个层次或多个层次结合加入缓存。</p>

<p><strong>这里重点介绍下服务层的缓存实现，目前主要有两种方式：</strong></p>

<p><strong>1）直写式（Write Through）：</strong>在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般；</p>

<p><strong>2）回写式（Write Back）：</strong>当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。</p>

<h2 id="toc_3">表分区</h2>

<p>MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码。</p>

<p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218160702113.png" alt="image-20190218160702113"/></p>

<p>用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上：</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218160739457.png" alt="image-20190218160739457"/></p>

<p><strong>分区的好处是：</strong></p>

<p>1）可以让单表存储更多的数据；</p>

<p>2）分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作；</p>

<p>3）部分查询能够从查询条件确定只落在少数分区上，速度会很快；</p>

<p>4）分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备；</p>

<p>5）可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争；</p>

<p>6）可以备份和恢复单个分区。</p>

<p><strong>分区的限制和缺点：</strong></p>

<p>1）一个表最多只能有1024个分区；</p>

<p>2）如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来；</p>

<p>3）分区表无法使用外键约束；</p>

<p>4）NULL值会使分区过滤无效；</p>

<p>5）所有分区必须使用相同的存储引擎。</p>

<p><strong>分区的类型：</strong></p>

<p>1）RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区；</p>

<p>2）LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择；</p>

<p>3）HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式；</p>

<p>4）KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</p>

<p><strong>分区最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218160812843.png" alt="image-20190218160812843"/></p>

<p>查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。</p>

<p>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存。</p>

<p>另外MySQL有一种早期的简单的分区实现 - 合并表（merge table），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代。</p>

<h2 id="toc_4">垂直拆分</h2>

<p>垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。</p>

<p><strong>比如原始的用户表是：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218162154213.png" alt="image-20190218162154213"/></p>

<p><strong>垂直拆分后是：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218162129833.png" alt="image-20190218162129833"/></p>

<p><strong>垂直拆分的优点是：</strong></p>

<p>1）可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)；</p>

<p>2）可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起；</p>

<p>3）数据维护简单。</p>

<p><strong>缺点是：</strong></p>

<p>1）主键出现冗余，需要管理冗余列；</p>

<p>2）会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力；</p>

<p>3）依然存在单表数据量过大的问题（需要水平拆分）；</p>

<p>4）事务处理复杂。</p>

<h2 id="toc_5">水平拆分</h2>

<h4 id="toc_6">概述</h4>

<p>水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表。</p>

<p>库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决。</p>

<p><strong>前面垂直拆分的用户表如果进行水平拆分，结果是：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218162027582.png" alt="image-20190218162027582"/></p>

<p>实际情况中往往会是垂直拆分和水平拆分的结合，即将Users_A_M和Users_N_Z再拆成Users和UserExtras，这样一共四张表。</p>

<p><strong>水平拆分的优点是:</strong></p>

<p>1）不存在单库大数据和高并发的性能瓶颈；</p>

<p>2）应用端改造较少；</p>

<p>3）提高了系统的稳定性和负载能力。</p>

<p><strong>缺点是：</strong></p>

<p>1）分片事务一致性难以解决；</p>

<p>2）跨节点Join性能差，逻辑复杂；</p>

<p>3）数据多次扩展难度跟维护量极大。</p>

<h4 id="toc_7">分片原则</h4>

<p>1）能不分就不分，参考“单表优化”；</p>

<p>2）分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量；</p>

<p>3）分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容；</p>

<p>4）尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题；</p>

<p>5）查询条件尽量优化，尽量避免Select * 的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引；</p>

<p>6）通过数据冗余和表分区赖降低跨库Join的可能。</p>

<p>这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p>

<p>总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。</p>

<h4 id="toc_8">解决方案</h4>

<p>由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。</p>

<p>*<strong>【客户端架构】：*</strong></p>

<p>通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现。</p>

<p>这是一个客户端架构的例子：</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218161958669.png" alt="image-20190218161958669"/></p>

<p>可以看到分片的实现是和应用服务器在一起的，通过修改Spring JDBC层来实现</p>

<p>客户端架构的优点是：</p>

<p>1）应用直连数据库，降低外围系统依赖所带来的宕机风险；</p>

<p>2）集成成本低，无需额外运维的组件。</p>

<p>缺点是：</p>

<p>1）限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心；</p>

<p>2）将分片逻辑的压力放在应用服务器上，造成额外风险。</p>

<p>*<strong>【代理架构】：*</strong></p>

<p>通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件。</p>

<p>这是一个代理架构的例子：</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218161928361.png" alt="image-20190218161928361"/></p>

<p>代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理。</p>

<p>代理架构的优点是：</p>

<p>能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强；</p>

<p>对于应用服务器透明且没有增加任何额外负载。</p>

<p>缺点是：</p>

<p>需部署和运维独立的代理中间件，成本高；<br/>
应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险。</p>

<h4 id="toc_9">各方案比较</h4>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218161825489.png" alt="image-20190218161825489"/></p>

<p><strong>如此多的方案，如何进行选择？可以按以下思路来考虑：</strong></p>

<p>1）确定是使用代理架构还是客户端架构。中小型规模或是比较简单的场景倾向于选择客户端架构，复杂场景或大规模系统倾向选择代理架构；<br/>
2）具体功能是否满足，比如需要跨节点ORDER BY，那么支持该功能的优先考虑；<br/>
3）不考虑一年内没有更新的产品，说明开发停滞，甚至无人维护和技术支持；<br/>
4）最好按大公司-&gt;社区-&gt;小公司-&gt;个人这样的出品方顺序来选择；<br/>
5）选择口碑较好的，比如github星数、使用者数量质量和使用者反馈；<br/>
6）开源的优先，往往项目有特殊需求可能需要改动源代码。</p>

<p><strong>按照上述思路，推荐以下选择：</strong></p>

<p>1）客户端架构：ShardingJDBC；<br/>
2）代理架构：MyCat或者Atlas。</p>

<h2 id="toc_10">兼容MySQL且可水平扩展的数据库</h2>

<p><strong>目前也有一些开源数据库兼容MySQL协议，如：</strong></p>

<p>1）<a href="https://github.com/pingcap/tidb">TiDB</a>；<br/>
2）<a href="http://www.cubrid.org/">Cubrid</a>。<br/>
但其工业品质和MySQL尚有差距，且需要较大的运维投入。</p>

<p><strong>如果想将原始的MySQL迁移到可水平扩展的新数据库中，可以考虑一些云数据库：</strong></p>

<p>1）阿里云<a href="https://cn.aliyun.com/product/petadata/?spm=5176.7960203.237031.38.cAzx5r">PetaData</a>；<br/>
2）阿里云<a href="https://cn.aliyun.com/product/oceanbase?spm=5176.7960203.237031.40.cAzx5r">OceanBase</a>；<br/>
3）腾讯云<a href="https://cloud.tencent.com/product/dcdb_for_tdsql">DCDB</a>。</p>

<p>10、NoSQL<br/>
在MySQL上做Sharding是一种戴着镣铐的跳舞，事实上很多大表本身对MySQL这种RDBMS的需求并不大，并不要求ACID，可以考虑将这些表迁移到NoSQL，彻底解决水平扩展问题。</p>

<p><strong>例如：</strong></p>

<p>1）日志类、监控类、统计类数据；<br/>
2）非结构化或弱结构化数据；<br/>
3）对事务要求不强，且无太多关联操作的数据。</p>

<ul>
<li>
<a href="#toc_0">单表优化方案</a>
</li>
<li>
<a href="#toc_1">读写分离</a>
</li>
<li>
<a href="#toc_2">缓存</a>
</li>
<li>
<a href="#toc_3">表分区</a>
</li>
<li>
<a href="#toc_4">垂直拆分</a>
</li>
<li>
<a href="#toc_5">水平拆分</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_6">概述</a>
</li>
<li>
<a href="#toc_7">分片原则</a>
</li>
<li>
<a href="#toc_8">解决方案</a>
</li>
<li>
<a href="#toc_9">各方案比较</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_10">兼容MySQL且可水平扩展的数据库</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java知识点]]></title>
    <link href="https://books.sangkf.cn/15510645390936.html"/>
    <updated>2019-02-25T11:15:39+08:00</updated>
    <id>https://books.sangkf.cn/15510645390936.html</id>
    <content type="html"><![CDATA[
<p>列举一些Java常用的知识点<br/>
<span id="more"></span><!-- more --></p>

<p><strong>基础篇</strong><br/>
<strong>01面向对象</strong><br/>
<strong>→ 什么是面向对象</strong><br/>
面向对象、面向过程</p>

<p>面向对象的三大基本特征和五大基本原则<br/>
<strong>→ 平台无关性</strong><br/>
Java 如何实现的平台无关</p>

<p>JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）</p>

<p><strong>→ 值传递</strong><br/>
值传递、引用传递</p>

<p>为什么说 Java 中只有值传递</p>

<p><strong>→ 封装、继承、多态</strong><br/>
什么是多态、方法重写与重载</p>

<p>Java 的继承与实现</p>

<p>构造函数与默认构造函数</p>

<p>类变量、成员变量和局部变量</p>

<p>成员变量和方法作用域</p>

<p><strong>02 Java 基础知识</strong></p>

<p><strong>→ 基本数据类型</strong><br/>
7 种基本数据类型：整型、浮点型、布尔型、字符型</p>

<p>整型中 byte、short、int、long 的取值范围</p>

<p>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？</p>

<p><strong>→ 自动拆装箱</strong><br/>
什么是包装类型、什么是基本类型、什么是自动拆装箱</p>

<p>Integer 的缓存机制</p>

<p><strong>→ String</strong><br/>
字符串的不可变性</p>

<p>JDK 6 和 JDK 7 中 substring 的原理及区别、</p>

<p>replaceFirst、replaceAll、replace 区别、</p>

<p>String 对“+”的重载、字符串拼接的几种方式和区别</p>

<p>String.valueOf 和 Integer.toString 的区别、</p>

<p>switch 对 String 的支持</p>

<p>字符串池、常量池（运行时常量池、Class 常量池）、intern</p>

<p><strong>→ 熟悉 Java 中各种关键字</strong><br/>
transient、instanceof、final、static、volatile、synchronized、const 原理及用法</p>

<p><strong>→ 集合类</strong><br/>
常用集合类的使用、ArrayList 和 LinkedList 和 Vector 的区别 、SynchronizedList 和 Vector 的区别、HashMap、HashTable、ConcurrentHashMap 区别、</p>

<p>Set 和 List 区别？Set 如何保证元素不重复？</p>

<p>Java 8 中 stream 相关用法、apache 集合处理工具类的使用、不同版本的 JDK 中 HashMap 的实现的区别以及原因</p>

<p>Collection 和 Collections 区别</p>

<p>Arrays.asList 获得的 List 使用时需要注意什么</p>

<p>Enumeration 和 Iterator 区别</p>

<p>fail-fast 和 fail-safe</p>

<p>CopyOnWriteArrayList、ConcurrentSkipListMap</p>

<p><strong>→ 枚举</strong><br/>
枚举的用法、枚举的实现、枚举与单例、Enum 类</p>

<p>Java 枚举如何比较</p>

<p>switch 对枚举的支持</p>

<p>枚举的序列化如何实现</p>

<p>枚举的线程安全性问题</p>

<p><strong>→ IO</strong><br/>
字符流、字节流、输入流、输出流、</p>

<p>同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型</p>

<p>BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty</p>

<p><strong>→ 反射</strong><br/>
反射与工厂模式、反射有什么用</p>

<p>Class 类、java.lang.reflect.*</p>

<p><strong>→ 动态代理</strong><br/>
静态代理、动态代理</p>

<p>动态代理和反射的关系</p>

<p>动态代理的几种实现方式</p>

<p>AOP</p>

<p><strong>→ 序列化</strong><br/>
什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全</p>

<p><strong>→ 注解</strong><br/>
元注解、自定义注解、Java 中常用注解使用、注解与反射的结合</p>

<p>Spring 常用注解</p>

<p><strong>→ JMS</strong><br/>
什么是 Java 消息服务、JMS 消息传送模型</p>

<p><strong>→ JMX</strong><br/>
java.lang.management.<em>、 javax.management.</em></p>

<p><strong>→ 泛型</strong><br/>
泛型与继承、类型擦除、泛型中 KTVE? object 等的含义、泛型各种用法</p>

<p>限定通配符和非限定通配符、上下界限定符 extends 和 super</p>

<p>List</p>

<p>List&lt;?&gt; 和 List</p>

<p><strong>→ 单元测试</strong><br/>
junit、mock、mockito、内存数据库（h2）</p>

<p><strong>→ 正则表达式</strong><br/>
java.lang.util.regex.*</p>

<p><strong>→ 常用的 Java 工具库</strong><br/>
commons.lang、commons.*...、 guava-libraries、 netty</p>

<p><strong>→ API &amp; SPI</strong><br/>
API、API 和 SPI 的关系和区别</p>

<p>如何定义 SPI、SPI 的实现原理</p>

<p><strong>→ 异常</strong><br/>
异常类型、正确处理异常、自定义异常</p>

<p>Error 和 Exception</p>

<p>异常链、try-with-resources</p>

<p>finally 和 return 的执行顺序</p>

<p><strong>→ 时间处理</strong><br/>
时区、冬令时和夏令时、时间戳、Java 中时间 API</p>

<p>格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系</p>

<p>SimpleDateFormat 的线程安全性问题</p>

<p>Java 8 中的时间处理</p>

<p>如何在东八区的计算机上获取美国时间</p>

<p><strong>→ 编码方式</strong><br/>
Unicode、有了 Unicode 为啥还需要 UTF-8</p>

<p>GBK、GB2312、GB18030 之间的区别</p>

<p>UTF8、UTF16、UTF32 区别</p>

<p>URL 编解码、Big Endian 和 Little Endian</p>

<p>如何解决乱码问题</p>

<p><strong>→ 语法糖</strong><br/>
Java 中语法糖原理、解语法糖</p>

<p>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式</p>

<p><strong>03阅读源代码</strong></p>

<p>String、Integer、Long、Enum、</p>

<p>BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、</p>

<p>ArrayList &amp; LinkedList、</p>

<p>HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet</p>

<p><strong>04 Java 并发编程</strong></p>

<p><strong>→ 并发与并行</strong><br/>
什么是并发、什么是并行</p>

<p>并发与并行的区别</p>

<p><strong>→ 什么是线程，与进程的区别</strong><br/>
线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程</p>

<p>线程与进程的区别</p>

<p><strong>→ 线程池</strong><br/>
自己设计线程池、submit() 和 execute()、线程池原理</p>

<p>为什么不允许使用 Executors 创建线程池</p>

<p><strong>→ 线程安全</strong><br/>
死锁、死锁如何排查、线程安全和内存模型的关系</p>

<p><strong>→ 锁</strong><br/>
CAS、乐观锁与****悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、</p>

<p>锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁</p>

<p><strong>→ 死锁</strong><br/>
什么是死锁</p>

<p>死锁如何解决</p>

<p><strong>→ synchronized</strong><br/>
synchronized 是如何实现的？</p>

<p>synchronized 和 lock 之间关系、不使用 synchronized 如何实现一个线程安全的单例</p>

<p>synchronized 和原子性、可见性和有序性之间的关系</p>

<p><strong>→ volatile</strong><br/>
happens-before、内存屏障、编译器指令重排和 CPU 指令重</p>

<p>volatile 的实现原理</p>

<p>volatile 和原子性、可见性和有序性之间的关系</p>

<p>有了 symchronized 为什么还需要 volatile</p>

<p><strong>→ sleep 和 wait</strong><br/>
<strong>→ wait 和 notify</strong><br/>
<strong>→ notify 和 notifyAll</strong><br/>
<strong>→ ThreadLocal</strong><br/>
<strong>→ 写一个死锁的程序</strong><br/>
<strong>→ 写代码来解决生产者消费者问题</strong><br/>
<strong>→ 并方包</strong><br/>
Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、ConcurrentHashMap、Executors</p>

<p><strong>2底层篇</strong></p>

<p><strong>01JVM</strong></p>

<p><strong>→ JVM 内存结构</strong></p>

<p>class 文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、</p>

<p>堆和栈区别</p>

<p>Java 中的对象一定在堆上分配吗？</p>

<p><strong>→ Java 内存模型</strong><br/>
计算机内存模型、缓存一致性、MESI 协议</p>

<p>可见性、原子性、顺序性、happens-before、</p>

<p>内存屏障、synchronized、volatile、final、锁</p>

<p><strong>→ 垃圾回收</strong><br/>
GC 算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收</p>

<p>GC 参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon）</p>

<p><strong>→ JVM 参数及调优</strong><br/>
-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、</p>

<p>-XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold</p>

<p><strong>→ Java 对象模型</strong><br/>
oop-klass、对象头</p>

<p><strong>→ HotSpot</strong><br/>
即时编译器、编译优化</p>

<p><strong>→ 虚拟机性能监控与故障处理工具</strong><br/>
jps, jstack, jmap, jstat, jconsole, jinfo, jhat, javap, btrace, TProfiler</p>

<p>Arthas</p>

<p><strong>02 类加载机制</strong></p>

<p>classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）</p>

<p><strong>03 编译与反编译</strong></p>

<p>什么是编译（前端编译、后端编译）、什么是反编译</p>

<p>JIT、JIT 优化（逃逸分析、栈上分配、标量替换、锁优化）</p>

<p>编译工具：javac</p>

<p>反编译工具：javap 、jad 、CRF</p>

<p><strong>3进阶篇</strong></p>

<p><strong>01 Java 底层知识</strong></p>

<p><strong>→ 字节码、class 文件格式</strong><br/>
<strong>→ CPU 缓存，L1，L2，L3 和伪共享</strong><br/>
<strong>→ 尾递归</strong><br/>
<strong>→ 位运算</strong><br/>
用位运算实现加、减、乘、除、取余</p>

<p><strong>02 设计模式</strong><br/>
设计模式的六大原则：</p>

<p>开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle）</p>

<p>接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle）</p>

<p><strong>→ 了解 23 种设计模式</strong></p>

<p>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</p>

<p>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p>

<p>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</p>

<p><strong>→ 会使用常用设计模式</strong><br/>
单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁</p>

<p>工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会</p>

<p><strong>→ 不用 synchronized 和 lock，实现线程安全的单例模式</strong><br/>
<strong>→ 实现 AOP</strong><br/>
<strong>→ 实现 IOC</strong><br/>
<strong>→ nio 和 reactor 设计模式</strong></p>

<p><strong>03 网络编程知识</strong></p>

<p><strong>→ tcp、udp、http、https 等常用协议</strong></p>

<p>三次握手与四次关闭、流量控制和拥塞控制、OSI 七层模型、tcp 粘包与拆包</p>

<p><strong>→ http/1.0 http/1.1 http/2 之前的区别</strong><br/>
http 中 get 和 post 区别</p>

<p>常见的 web 请求返回的状态码</p>

<p>404、302、301、500分别代表什么</p>

<p><strong>→ http/3</strong><br/>
<strong>→ Java RMI，Socket，HttpClient</strong><br/>
<strong>→ cookie 与 session</strong><br/>
cookie 被禁用，如何实现 session</p>

<p><strong>→ 用 Java 写一个简单的静态文件的 HTTP 服务器</strong><br/>
<strong>→ 了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器</strong><br/>
<strong>→ 用 Java 实现 FTP、SMTP 协议</strong><br/>
<strong>→ 进程间通讯的方式</strong><br/>
<strong>→ 什么是 CDN？如果实现？</strong><br/>
<strong>→ DNS</strong><br/>
什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等<br/>
域名解析、根域名服务器</p>

<p>DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS</p>

<p><strong>→ 反向代理</strong><br/>
正向代理、反向代理</p>

<p>反向代理服务器</p>

<p><strong>04 框架知识</strong></p>

<p><strong>→ Servlet</strong></p>

<p>生命周期</p>

<p>线程安全问题</p>

<p>filter 和 listener</p>

<p>web.xml 中常用配置及作用</p>

<p><strong>→ Hibernate</strong><br/>
什么是 OR Mapping</p>

<p>Hibernate 的懒加载<br/>
Hibernate 的缓存机制</p>

<p>Hibernate / Ibatis / MyBatis 之间的区别</p>

<p><strong>→ Spring</strong> <br/>
Bean 的初始化<br/>
AOP 原理<br/>
实现 Spring 的IOC<br/>
Spring 四种依赖注入方式<br/>
<strong>→ Spring MVC</strong><br/>
什么是 MVC</p>

<p>Spring mvc 与 Struts mvc 的区别</p>

<p><strong>→ Spring Boot</strong><br/>
Spring Boot 2.0、起步依赖、自动配置、</p>

<p>Spring Boot 的 starter 原理，自己实现一个 starter</p>

<p><strong>→ Spring Security</strong><br/>
<strong>→ Spring Cloud</strong><br/>
服务发现与注册：Eureka、Zookeeper、Consul</p>

<p>负载均衡：Feign、Spring Cloud Loadbalance</p>

<p>服务配置：Spring Cloud Config</p>

<p>服务限流与熔断：Hystrix</p>

<p>服务链路追踪：Dapper</p>

<p>服务网关、安全、消息</p>

<p><strong>05 应用服务器知识</strong></p>

<p><strong>→ JBoss</strong><br/>
<strong>→ tomcat</strong><br/>
<strong>→ jetty</strong><br/>
<strong>→ Weblogic</strong></p>

<p><strong>06 工具</strong></p>

<p><strong>→ git &amp; svn</strong><br/>
<strong>→ maven &amp; gradle</strong><br/>
<strong>→ Intellij IDEA</strong><br/>
常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat</p>

<p>Lombok plugin、.ignore、Mybatis plugin</p>

<p><strong>4高级篇</strong></p>

<p><strong>01 新技术</strong></p>

<p><strong>→ Java 8</strong></p>

<p>lambda 表达式、Stream API、时间 API</p>

<p><strong>→ Java 9</strong><br/>
Jigsaw、Jshell、Reactive Streams</p>

<p><strong>→ Java 10</strong><br/>
局部变量类型推断、G1 的并行 Full GC、ThreadLocal 握手机制</p>

<p><strong>→ Java 11</strong><br/>
ZGC、Epsilon、增强 var</p>

<p><strong>→ Spring 5</strong><br/>
响应式编程</p>

<p><strong>→ Spring Boot 2.0</strong><br/>
<strong>→ HTTP/2</strong><br/>
<strong>→ HTTP/3</strong></p>

<p><strong>02 性能优化</strong></p>

<p>使用单例、使用 Future 模式、使用线程池</p>

<p>选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存</p>

<p><strong>03 线上问题分析</strong></p>

<p><strong>→ dump 获取</strong></p>

<p>线程 Dump、内存 Dump、gc 情况</p>

<p><strong>→ dump 分析</strong><br/>
分析死锁、分析内存泄露</p>

<p><strong>→ dump 分析及获取工具</strong><br/>
jstack、jstat、jmap、jhat、Arthas</p>

<p><strong>→ 自己编写各种 outofmemory，stackoverflow 程序</strong><br/>
HeapOutOfMemory、 Young OutOfMemory、</p>

<p>MethodArea OutOfMemory、ConstantPool OutOfMemory、</p>

<p>DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow</p>

<p><strong>→ Arthas</strong><br/>
jvm 相关、class/classloader 相关、monitor/watch/trace 相关、</p>

<p>options、管道、后台异步任务</p>

<p>文档：<a href="https://alibaba.github.io/arthas/advanced-use.html">https://alibaba.github.io/arthas/advanced-use.html</a></p>

<p><strong>→ 常见问题解决思路</strong><br/>
内存溢出、线程死锁、类加载冲突</p>

<p><strong>→ 使用工具尝试解决以下问题，并写下总结</strong><br/>
当一个 Java 程序响应很慢时如何查找问题</p>

<p>当一个 Java 程序频繁 FullGC 时如何解决问题</p>

<p>如何查看垃圾回收日志</p>

<p>当一个 Java 应用发生 OutOfMemory 时该如何解决</p>

<p>如何判断是否出现死锁</p>

<p>如何判断是否存在内存泄露</p>

<p>使用 Arthas 快速排查 Spring Boot 应用404/401问题</p>

<p>使用 Arthas 排查线上应用日志打满问题</p>

<p>利用 Arthas 排查 Spring Boot 应用 NoSuchMethodError</p>

<p><strong>04编译原理知识</strong></p>

<p><strong>→ 编译与反编译</strong><br/>
<strong>→ Java 代码的编译与反编译</strong><br/>
<strong>→ Java 的反编译工具</strong><br/>
javap 、jad 、CRF</p>

<p><strong>→ 即时编译器</strong><br/>
<strong>→ 编译过程</strong><br/>
词法分析，语法分析（LL 算法，递归下降算法，LR 算法）<br/>
语义分析，运行时环境，中间代码，代码生成，代码优化</p>

<p><strong>05 操作系统知识</strong></p>

<p><strong>→ Linux 的常用命令</strong><br/>
<strong>→ 进程间通信</strong><br/>
<strong>→ 进程同步</strong><br/>
生产者消费者问题、哲学家就餐问题、读者写者问题</p>

<p><strong>→ 缓冲区溢出</strong><br/>
<strong>→ 分段和分页</strong><br/>
<strong>→ 虚拟内存与主存</strong><br/>
<strong>→ 虚拟内存管理</strong><br/>
<strong>→ 换页算法</strong></p>

<p><strong>06 数据库知识</strong></p>

<p><strong>→ MySQL 执行引擎</strong><br/>
<strong>→ MySQL 执行计划</strong><br/>
如何查看执行计划，如何根据执行计划进行 SQL 优化</p>

<p><strong>→ 索引</strong><br/>
Hash 索引、B 树索引（B+树、和B树、R树）</p>

<p>普通索引、唯一索引</p>

<p>覆盖索引、最左前缀原则、索引下推</p>

<p><strong>→ SQL 优化</strong><br/>
<strong>→ 数据库事务和隔离级别</strong><br/>
事务的隔离级别、事务能不能实现锁的功能</p>

<p><strong>→ 数据库锁</strong><br/>
行锁、表锁、使用数据库锁实现乐观锁、</p>

<p><strong>→ 连接</strong><br/>
内连接，左连接，右连接</p>

<p><strong>→ 数据库主备搭建</strong><br/>
<strong>→ binlog</strong><br/>
<strong>→ redolog</strong><br/>
<strong>→ 内存数据库</strong><br/>
h2</p>

<p><strong>→ 分库分表</strong><br/>
<strong>→ 读写分离</strong><br/>
<strong>→ 常用的 NoSql 数据库</strong><br/>
redis、memcached</p>

<p><strong>→ 分别使用数据库锁、NoSql 实现分布式锁</strong><br/>
<strong>→ 性能调优</strong><br/>
<strong>→ 数据库连接池</strong></p>

<p><strong>07 数据结构与算法知识</strong></p>

<p><strong>→ 简单的数据结构</strong></p>

<p>栈、队列、链表、数组、哈希表、</p>

<p>栈和队列的相同和不同之处</p>

<p>栈通常采用的两种存储结构</p>

<p><strong>→ 树</strong><br/>
二叉树、字典树、平衡树、排序树、</p>

<p>B 树、B+ 树、R 树、多路树、红黑树</p>

<p><strong>→ 堆</strong><br/>
大根堆、小根堆</p>

<p><strong>→ 图</strong><br/>
有向图、无向图、拓扑</p>

<p><strong>→ 排序算法</strong><br/>
稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序</p>

<p>不稳定的排序：选择排序、希尔排序、Clover 排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序</p>

<p>各种排序算法和时间复杂度</p>

<p><strong>→ 两个栈实现队列，和两个队列实现栈</strong><br/>
<strong>→ 深度优先和广度优先搜索</strong><br/>
<strong>→ 全排列、贪心算法、KMP 算法、hash 算法</strong><br/>
<strong>→ 海量数据处理</strong><br/>
分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce 等。</p>

<p><strong>08大数据知识</strong></p>

<p><strong>→ Zookeeper</strong></p>

<p>基本概念、常见用法</p>

<p><strong>→ Solr，Lucene，ElasticSearch</strong><br/>
在 linux 上部署 solr，solrcloud，新增、删除、查询索引</p>

<p><strong>→ Storm，流式计算，了解 Spark，S4</strong><br/>
在 linux 上部署 storm，用 zookeeper 做协调，运行 storm hello world，local 和 remote 模式运行调试 storm topology。</p>

<p><strong>→ Hadoop，离线计算</strong><br/>
HDFS、MapReduce</p>

<p><strong>→ 分布式日志收集 flume，kafka，logstash</strong><br/>
<strong>→ 数据挖掘，mahout</strong></p>

<p><strong>09 网络安全知识</strong></p>

<p><strong>→ XSS</strong></p>

<p>XSS 的防御</p>

<p><strong>→ CSRF</strong><br/>
<strong>→ 注入攻击</strong><br/>
SQL 注入、XML 注入、CRLF 注入</p>

<p><strong>→ 文件上传漏洞</strong><br/>
<strong>→ 加密与解密</strong><br/>
对称加密、非对称加密、哈希算法、加盐哈希算法</p>

<p>MD5，SHA1、DES、AES、RSA、DSA</p>

<p>彩虹表</p>

<p><strong>→ DDOS攻击</strong><br/>
DOS 攻击、DDOS 攻击</p>

<p>memcached 为什么可以导致 DDos 攻击、什么是反射型 DDoS</p>

<p>如何通过 Hash 碰撞进行 DOS 攻击</p>

<p><strong>→ SSL、TLS，HTTPS</strong><br/>
<strong>→ 用 openssl 签一个证书部署到 apache 或 nginx</strong></p>

<p><strong>5架构篇</strong></p>

<p><strong>01分布式</strong></p>

<p>数据一致性、服务治理、服务降级</p>

<p><strong>→ 分布式事务</strong></p>

<p>2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC</p>

<p><strong>→ Dubbo</strong><br/>
服务注册、服务发现，服务治理</p>
<http://dubbo.apache.org/zh-cn/>
<p><strong>→ 分布式数据库</strong><br/>
怎样打造一个分布式数据库、什么时候需要分布式数据库、</p>

<p>mycat、otter、HBase</p>

<p><strong>→ 分布式文件系统</strong><br/>
mfs、fastdfs</p>

<p><strong>→ 分布式缓存</strong><br/>
缓存一致性、缓存命中率、缓存冗余</p>

<p><strong>→ 限流降级</strong><br/>
Hystrix、Sentinal</p>

<p><strong>→ 算法</strong><br/>
共识算法、Raft 协议、Paxos 算法与 Raft 算法、</p>

<p>拜占庭问题与算法、2PC、3PC</p>

<p><strong>02 微服务</strong></p>

<p>SOA、康威定律</p>

<p><strong>→ ServiceMesh</strong><br/>
sidecar</p>

<p><strong>→ Docker &amp; Kubernets</strong><br/>
<strong>→ Spring Boot</strong><br/>
<strong>→ Spring Cloud</strong></p>

<p><strong>03 高并发</strong></p>

<p><strong>→ 分库分表</strong><br/>
<strong>→ CDN 技术</strong><br/>
<strong>→ 消息队列</strong><br/>
ActiveMQ</p>

<p><strong>04 监控</strong></p>

<p><strong>→ 监控什么</strong></p>

<p>CPU、内存、磁盘 I/O、网络 I/O 等</p>

<p><strong>→ 监控手段</strong><br/>
进程监控、语义监控、机器资源监控、数据波动</p>

<p><strong>→ 监控数据采集</strong><br/>
日志、埋点</p>

<p><strong>→ Dapper</strong></p>

<p><strong>05 负载均衡</strong></p>

<p>tomcat 负载均衡、Nginx 负载均衡</p>

<p>四层负载均衡、七层负载均衡</p>

<p><strong>06 DNS</strong></p>

<p>DNS 原理、DNS 的设计</p>

<p><strong>07 CDN</strong></p>

<p>数据一致性</p>

<p><strong>6扩展篇</strong></p>

<p><strong>01 云计算</strong></p>

<p>IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess</p>

<p><strong>02 搜索引擎</strong></p>

<p>Solr、Lucene、Nutch、Elasticsearch</p>

<p><strong>03权限管理</strong></p>

<p>Shiro</p>

<p><strong>04 区块链</strong></p>

<p>哈希算法、Merkle 树、公钥密码算法、共识算法、</p>

<p>Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名</p>

<p><strong>→ 比特币</strong><br/>
挖矿、共识机制、闪电网络、侧链、热点问题、分叉</p>

<p><strong>→ 以太坊</strong><br/>
<strong>→ 超级账本</strong></p>

<p><strong>05人工智能</strong></p>

<p>数学基础、机器学习、人工神经网络、深度学习、应用场景。</p>

<p><strong>→ 常用框架</strong><br/>
TensorFlow、DeepLearning4J</p>

<p><strong>06 loT</strong></p>

<p><strong>07 量子计算</strong></p>

<p><strong>08 AR &amp; VR</strong></p>

<p><strong>09其他语言</strong></p>

<p>Groovy、Python、Go、NodeJs、Swift、Rust</p>

<p><strong>7推荐书籍</strong></p>

<p>《深入理解 Java 虚拟机》 <br/>
《Effective Java》 <br/>
《深入分析 Java Web 技术内幕》 <br/>
《大型网站技术架构》 <br/>
《代码整洁之道》 <br/>
《架构整洁之道》 <br/>
《Head First 设计模式》 <br/>
《maven 实战》 <br/>
《区块链原理、设计与应用》 <br/>
《Java 并发编程实战》 <br/>
《鸟哥的 Linux 私房菜》 <br/>
《从Paxos 到 Zookeeper》 <br/>
《架构即未来》</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAVA8新特性]]></title>
    <link href="https://books.sangkf.cn/15510645099182.html"/>
    <updated>2019-02-25T11:15:09+08:00</updated>
    <id>https://books.sangkf.cn/15510645099182.html</id>
    <content type="html"><![CDATA[
<p>原文地址 <a href="https://www.cnblogs.com/huyunfan/p/7456535.html">https://www.cnblogs.com/huyunfan/p/7456535.html</a></p>

<ul>
<li><p><strong>default拓展方法</strong><br/>
<span id="more"></span><!-- more --><br/>
default关键字为接口声明添加非抽象方法的实现,也称为拓展方法</p>
<pre><code class="language-java">public interface Formula {
  void doSomething();<br/>
  default void before() {<br/>
      System.out.println(&quot;我是拓展方法&quot;);<br/>
  }<br/>
}<br/>
public class FormulaService implements Formula {<br/>
  @Override<br/>
  public void doSomething() {<br/>
      before();<br/>
      System.out.println(&quot;我是override方法&quot;);<br/>
  }<br/>
}
</code></pre></li>
<li><p><strong>Lambda表达式</strong></p>
<p>java8引入函数式编程，Lambda则是函数式编程的基础。</p>
<pre><code class="language-java">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
// java8之前<br/>
Collections.sort(list, new Comparator&lt;String&gt;(){<br/>
  @Override<br/>
  public int compare(String o1, String o2) {<br/>
      return o1.compareTo(o2);<br/>
  }<br/>
});<br/>
// lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt; {<br/>
          return o2.compareTo(o1);<br/>
});<br/>
// 简洁lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt;  o2.compareTo(o1));<br/>
// 更简洁lambda<br/>
Collections.sort(list, (o1, o2) -&gt;  o2.compareTo(o1));<br/>
// 也可以这样写<br/>
Collections.sort(list, Comparator.comparing(String::toString));
</code></pre></li>
<li><p><strong>函数式接口</strong></p>
<p>一个函数式接口有且只能有一个抽象方法申明，其中该注意的是 @FunctionalInterface 注解，此时如果在接口中定义了第二个抽象方法，编译器将会抛出异常。当然如果不加该注解也不是不行，如果接口中有多个抽象方法，而你又使用了lambda表达式，则在调用处会抛出异常。</p>
<pre><code class="language-java">@FunctionalInterface
public interface Formula&lt;F,T&gt;{<br/>
  T convert(F var1);<br/>
}<br/>
Formula&lt;String,Integer&gt; function = (var1 -&gt; Integer.valueOf(var1));<br/>
Integer var2 = function.convert(&quot;1000&quot;); 
</code></pre></li>
<li><p><strong>方法和构造函数引用</strong></p>
<p>方法引用的标准语法是 <code>类名:方法名</code></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用静态方法</td>
<td>targetClass :: staticMethodName</td>
</tr>
<tr>
<td>引用某个对象的实例方法</td>
<td>targetClass :: instanceMethodName</td>
</tr>
<tr>
<td>引用某个类型的任意对象的实例方法</td>
<td>targetType :: methodName</td>
</tr>
<tr>
<td>引用构造方法</td>
<td>className :: new</td>
</tr>
</tbody>
</table></li>
</ul>

<ol>
<li><p><strong>引用静态方法</strong></p>
<pre><code class="language-java">Formula&lt;String,Integer&gt; function = (Integer::valueOf);
Integer var2 = function.convert(&quot;1000&quot;);
</code></pre></li>
<li><p><strong>引用某个类型的任意对象的实例方法</strong></p>
<pre><code class="language-java">public static void main(String[] args) {
  String[] array = {&quot;贱明&quot;, &quot;学友&quot;};<br/>
  Arrays.sort(array, String::compareTo);<br/>
}
</code></pre></li>
<li><p><strong>引用构造方法</strong></p>
<pre><code class="language-java">// 定义工厂
interface PersonFactory&lt;P extends Person&gt;{<br/>
   P create(String name);<br/>
}<br/>
// Person类的构造方法<br/>
public Person(String name) {<br/>
   this.name = name;<br/>
}<br/>
// 创建<br/>
PersonFactory&lt;Person&gt; factory = Person::new;<br/>
factory.create(&quot;贱明&quot;);
</code></pre></li>
</ol>

<ul>
<li><p><strong>Lambda的范围</strong></p>
<p>lambda可以访问局部对应的外部区域的局部final变量，以及成员变量和静态变量。</p>
<ol>
<li><p><strong>访问成员变量</strong></p>
<pre><code class="language-java">public void doSomething(){
 final String p1 = &quot;贱明&quot;;<br/>
 final String p2 = &quot;学友&quot;;<br/>
 Formula function = (person1, person2) -&gt; p1.compareTo(p2);<br/>
}
</code></pre>
<p>与java8以下版本不同的是，p1 p2你可以不修饰成final 也不会报错，但是如果你想修改他们，编译器则会告诉你这是不被允许的。</p></li>
<li><p><strong>访问成员变量和静态变量</strong></p>
<pre><code class="language-java">public void doSomething(){;
Formula function = (person1, person2) -&gt;{<br/>
    dehua = &quot;贱明&quot;;<br/>
    xueyou=&quot;学友&quot;;<br/>
    return dehua.compareTo(xueyou);<br/>
};<br/>
}
</code></pre></li>
</ol></li>
<li><p><strong>内置函数式接口</strong></p>
<p>​     java8 api中提供了很多内置函数式接口，而且有些接口其实在Google Guava中已经实现了，很大程  度的降低了程序员的工作负担。</p>
<ol>
<li><p><strong>Predicates</strong><br/>
Predicate是一个布尔类型的函数，该函数只有一个输入参数，他包含了多种默认实现。</p>
<pre><code class="language-java">public static void main(String[] args) {
Predicate&lt;String&gt; predicate = (s) -&gt; s.contains(&quot;贱明&quot;);<br/>
String var1 = &quot;牛贱明&quot;;<br/>
predicate.test(var1);              // true<br/>
predicate.negate().test(var1);     // false<br/>
Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;<br/>
Predicate&lt;Boolean&gt; isNull = Objects::isNull;<br/>
Predicate&lt;String&gt; isEmpty = String::isEmpty;<br/>
Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();<br/>
isNotEmpty.and(isEmpty).test(var1);<br/>
}
</code></pre></li>
<li><p><strong>Functions</strong></p>
<p>Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起</p>
<pre><code class="language-java">public static void main(String[] args) {
Function&lt;String, Integer&gt; toInteger = Integer::valueOf;<br/>
Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);<br/>
System.out.println(toInteger.apply(&quot;123&quot;));<br/>
System.out.println(backToString.apply(&quot;123&quot;));<br/>
}
</code></pre></li>
<li><p><strong>Suppliers</strong></p>
<p>Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。</p>
<pre><code class="language-java">Supplier&lt;Person&gt; personSupplier = Person::new;
Person p = personSupplier.get();   // new Person
</code></pre></li>
<li><p><strong>Consumers</strong></p>
<p>Consumer代表了在一个输入参数上需要进行的操作。</p>
<pre><code class="language-java">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.getName());
greeter.accept(new Person(&quot;贱明&quot;));
</code></pre></li>
<li><p><strong>Comparators</strong></p>
<p>Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。</p>
<pre><code class="language-java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.getName().compareTo(p2.getName());
Person p1 = new Person(&quot;贱明&quot;);<br/>
Person p2 = new Person(&quot;学友&quot;);<br/>
System.out.println(comparator.compare(p1, p2));             // &gt; 1105<br/>
System.out.println(comparator.reversed().compare(p1, p2));  // &lt; -1105
</code></pre></li>
<li><p><strong>Optionals</strong></p>
<p>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerException产生。<br/>
Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional。</p>
<pre><code class="language-java">Optional&lt;String&gt; optional = Optional.of(&quot;贱明&quot;);
System.out.println(optional.isPresent()); // true      <br/>
System.out.println(optional.get()); // 贱明   <br/>
System.out.println(optional.orElse(&quot;学友&quot;)); // 贱明    <br/>
optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); 
</code></pre></li>
</ol></li>
</ul>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringCloud服务治理，服务注册，服务发现]]></title>
    <link href="https://books.sangkf.cn/15510642705827.html"/>
    <updated>2019-02-25T11:11:10+08:00</updated>
    <id>https://books.sangkf.cn/15510642705827.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">服务治理</h2>

<p>服务治理是微服务架构中最为核心和基础的模块，他主要用来实现各个微服务市里的自动化注册和发现。<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li><p>为什么需要服务治理？微服务没有他会怎样？</p>
<p>​ 在最开始构建微服务系统的时候可能服务并不多，我们可以通过一些静态配置来完成服务的调用。比如，有两个服务A和服务B，其中服务A需要调用服务B来完成一个业务的操作时，为了实现服务B的高可用，不论采用服务端负载均衡还是客户端负载均衡，都需要手工维护服务B的具体实例清单。但是随着业务的发展，系统的功能越来越复杂，相应的微服务应用也不断增加，我们的静态配置会变得越来越难以维护。并且面对不断发展的业务，我们的集群规模，服务的位置，服务的命名等都可能发生变化，如果还是通过手工维护的方式，那么极易发生错误或者命名冲突等问题。同时，对于这类静态内容的维护也必将消耗大量的人力。</p>
<p><u><strong>服务治理框架的实现都是围绕着服务注册与服务发现机制来完成微服务应用实例的自动化管理</strong></u></p></li>
</ul>

<h2 id="toc_1">服务注册</h2>

<p>​   在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，将主机与端口号，版本号，通信协议等一些附加信息告知注册中心，注册中心按照服务名分类组织服务清单。</p>

<p>当这些进程启动，并向注册中心注册自己的服务后，注册中心就会维护类似下面的一个服务清单。另外，服务注册中心还需要以心跳的方式去监测清单中的服务是否可用，如果不可用则需要从服务清单中提出，达到排除故障服务的效果。</p>

<table>
<thead>
<tr>
<th>服务名</th>
<th>位置</th>
</tr>
</thead>

<tbody>
<tr>
<td>服务A</td>
<td>192.168.0.100:8000，192.168.0.101:8000</td>
</tr>
<tr>
<td>服务B</td>
<td>192.168.0.100:9000，192.168.0.101:9000，192.168.0.102:9000</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">服务发现</h2>

<p>​   由于在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务名发起请求调用实现。所以，服务调用方在调用服务提供方接口的时候，并不知道具体的服务实例位置。因此，调用方需要向服务注册中心咨询服务，并获取所有的服务的实例清单，以实现对具体服务实例的访问。</p>

<p>比如，现有服务C希望调用服务A，服务C就向注册中心发起咨询服务的请求，服务注册中心就会将服务A的位置清单返回给服务C。如按上例服务A的的情况，C便获得了服务A的两个可用位置192.168.0.100:8000和192.168.0.101:8000。当服务C要发起调用的时候，便从该清单中以某种轮询策略取出一个位置来进行服务调用，这就是后续我们将会介绍的客户端负载均衡。</p>

<ul>
<li>
<a href="#toc_0">服务治理</a>
</li>
<li>
<a href="#toc_1">服务注册</a>
</li>
<li>
<a href="#toc_2">服务发现</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MarkDown常见图表，流程图书写✍️]]></title>
    <link href="https://books.sangkf.cn/15509800202549.html"/>
    <updated>2019-02-24T11:47:00+08:00</updated>
    <id>https://books.sangkf.cn/15509800202549.html</id>
    <content type="html"><![CDATA[
<p>利用MarkDown书写一些常用的流程图，Echarts图表，数学公式，点图等</p>

<span id="more"></span><!-- more -->

<h3 id="toc_0">mermaid</h3>

<pre><code class="language-mermaid">sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br/&gt;prevail...
    John--&gt;Alice: Great!
    John-&gt;Bob: How about you?
    Bob--&gt;John: Jolly good!
</code></pre>

<p><img src="media/15509800202549/15510632566254.jpg" alt="" style="width:500px;"/></p>

<h3 id="toc_1">dot</h3>

<pre><code class="language-dot"># http://www.graphviz.org/content/cluster
digraph G {

    subgraph cluster_0 {
        style=filled;
        color=lightgrey;
        node [style=filled,color=white];
        a0 -&gt; a1 -&gt; a2 -&gt; a3;
        label = &quot;process #1&quot;;
    }

    subgraph cluster_1 {
        node [style=filled];
        b0 -&gt; b1 -&gt; b2 -&gt; b3;
        label = &quot;process #2&quot;;
        color=blue
    }
    start -&gt; a0;
    start -&gt; b0;
    a1 -&gt; b3;
    b2 -&gt; a3;
    a3 -&gt; a0;
    a3 -&gt; end;
    b3 -&gt; end;

    start [shape=Mdiamond];
    end [shape=Msquare];
}
</code></pre>

<p><img src="media/15509800202549/15510633206455.jpg" alt="" style="width:293px;"/></p>

<h3 id="toc_2">echarts</h3>

<pre><code class="language-echarts">option = {
    xAxis: {
        type: &#39;category&#39;,
        data: [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;]
    },
    yAxis: {
        type: &#39;value&#39;
    },
    series: [{
        data: [820, 932, 901, 934, 1290, 1330, 1320],
        type: &#39;line&#39;
    }]
};
</code></pre>

<p><img src="media/15509800202549/15510633473570.jpg" alt="" style="width:500px;"/></p>

<h3 id="toc_3">顺序图和流程图</h3>

<pre><code class="language-sequence">张三-&gt;李四: 嘿，小四儿, 写博客了没?
Note right of 李四: 李四愣了一下，说：
李四--&gt;张三: 忙得吐血，哪有时间写。
</code></pre>

<pre><code class="language-flow">st=&gt;start: 开始
e=&gt;end: 结束
op=&gt;operation: 我的操作
cond=&gt;condition: 确认？

st-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op
</code></pre>

<p><img src="media/15509800202549/15510633802834.jpg" alt="" style="width:436px;"/></p>

<h3 id="toc_4">LaTeX （MathJax 渲染）</h3>

<pre><code class="language-text">块级公式：
$$  x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$

\\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } } \\]

行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$
</code></pre>

<p><img src="media/15509800202549/15510634028669.jpg" alt="" style="width:500px;"/></p>

<ul>
<li>
<a href="#toc_0">mermaid</a>
</li>
<li>
<a href="#toc_1">dot</a>
</li>
<li>
<a href="#toc_2">echarts</a>
</li>
<li>
<a href="#toc_3">顺序图和流程图</a>
</li>
<li>
<a href="#toc_4">LaTeX （MathJax 渲染）</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 8新特性：新的时间和日期API]]></title>
    <link href="https://books.sangkf.cn/15509784083382.html"/>
    <updated>2019-02-24T11:20:08+08:00</updated>
    <id>https://books.sangkf.cn/15509784083382.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Java 8另一个新增的重要特性就是引入了新的时间和日期API，它们被包含在<code>java.time</code>包中。借助新的时间和日期API可以以更简洁的方法处理时间和日期。<br/>
<span id="more"></span><!-- more --></p>
</blockquote>

<p><img src="media/15509784083382/15509784261382.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>在介绍本篇文章内容之前，我们先来讨论Java 8为什么要引入新的日期API，与之前的时间和日期处理方式有什么不同？</p>

<p>在Java 8之前，所有关于时间和日期的API都存在各种使用方面的缺陷，主要有：</p>

<ol>
<li>Java的<code>java.util.Date</code>和<code>java.util.Calendar</code>类易用性差，不支持时区，而且他们都不是线程安全的；</li>
<li>用于格式化日期的类<code>DateFormat</code>被放在<code>java.text</code>包中，它是一个抽象类，所以我们需要实例化一个<code>SimpleDateFormat</code>对象来处理日期格式化，并且<code>DateFormat</code>也是非线程安全，这意味着如果你在多线程程序中调用同一个<code>DateFormat</code>对象，会得到意想不到的结果。</li>
<li>对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，从<code>Calendar</code>中获取的月份需要加一才能表示当前月份。</li>
</ol>

<p>由于以上这些问题，出现了一些三方的日期处理框架，例如Joda-Time，date4j等开源项目。但是，Java需要一套标准的用于处理时间和日期的框架，于是Java 8中引入了新的日期API。新的日期API是<a href="https://jcp.org/en/jsr/detail?id=310">JSR-310</a>规范的实现，Joda-Time框架的作者正是JSR-310的规范的倡导者，所以能从Java 8的日期API中看到很多Joda-Time的特性。</p>

<h2 id="toc_0">Java 8日期/时间类</h2>

<p>Java 8的日期和时间类包含<code>LocalDate</code>、<code>LocalTime</code>、<code>Instant</code>、<code>Duration</code>以及<code>Period</code>，这些类都包含在<code>java.time</code>包中，下面我们看看这些类的用法。</p>

<h3 id="toc_1">LocalDate和LocalTime</h3>

<p><code>LocalDate</code>类表示一个具体的日期，但不包含具体时间，也不包含时区信息。可以通过<code>LocalDate</code>的静态方法<code>of()</code>创建一个实例，<code>LocalDate</code>也包含一些方法用来获取年份，月份，天，星期几等：</p>

<pre><code class="language-java">LocalDate localDate = LocalDate.of(2017, 1, 4);     // 初始化一个日期：2017-01-04
int year = localDate.getYear();                     // 年份：2017
Month month = localDate.getMonth();                 // 月份：JANUARY
int dayOfMonth = localDate.getDayOfMonth();         // 月份中的第几天：4
DayOfWeek dayOfWeek = localDate.getDayOfWeek();     // 一周的第几天：WEDNESDAY
int length = localDate.lengthOfMonth();             // 月份的天数：31
boolean leapYear = localDate.isLeapYear();          // 是否为闰年：false
</code></pre>

<p>也可以调用静态方法<code>now()</code>来获取当前日期：</p>

<p>LocalDate now = LocalDate.now();</p>

<p><code>LocalTime</code>和<code>LocalDate</code>类似，他们之间的区别在于<code>LocalDate</code>不包含具体时间，而<code>LocalTime</code>包含具体时间，例如：</p>

<pre><code class="language-java">LocalTime localTime = LocalTime.of(17, 23, 52);     // 初始化一个时间：17:23:52
int hour = localTime.getHour();                     // 时：17
int minute = localTime.getMinute();                 // 分：23
int second = localTime.getSecond();                 // 秒：52
</code></pre>

<h3 id="toc_2">LocalDateTime</h3>

<p><code>LocalDateTime</code>类是<code>LocalDate</code>和<code>LocalTime</code>的结合体，可以通过<code>of()</code>方法直接创建，也可以调用<code>LocalDate</code>的<code>atTime()</code>方法或<code>LocalTime</code>的<code>atDate()</code>方法将<code>LocalDate</code>或<code>LocalTime</code>合并成一个<code>LocalDateTime</code>：</p>

<pre><code class="language-java">LocalDateTime ldt1 = LocalDateTime.of(2017, Month.JANUARY, 4, 17, 23, 52);

LocalDate localDate = LocalDate.of(2017, Month.JANUARY, 4);
LocalTime localTime = LocalTime.of(17, 23, 52);
LocalDateTime ldt2 = localDate.atTime(localTime);

</code></pre>

<p><code>LocalDateTime</code>也提供用于向<code>LocalDate</code>和<code>LocalTime</code>的转化：</p>

<pre><code class="language-java">LocalDate date = ldt1.toLocalDate();
LocalTime time = ldt1.toLocalTime();
</code></pre>

<h3 id="toc_3">Instant</h3>

<p><code>Instant</code>用于表示一个时间戳，它与我们常使用的<code>System.currentTimeMillis()</code>有些类似，不过<code>Instant</code>可以精确到纳秒（Nano-Second），<code>System.currentTimeMillis()</code>方法只精确到毫秒（Milli-Second）。如果查看<code>Instant</code>源码，发现它的内部使用了两个常量，<code>seconds</code>表示从1970-01-01 00:00:00开始到现在的秒数，<code>nanos</code>表示纳秒部分（<code>nanos</code>的值不会超过<code>999,999,999</code>）。<code>Instant</code>除了使用<code>now()</code>方法创建外，还可以通过<code>ofEpochSecond</code>方法创建：</p>

<pre><code class="language-java">Instant instant = Instant.ofEpochSecond(120, 100000);
</code></pre>

<p><code>ofEpochSecond()</code>方法的第一个参数为秒，第二个参数为纳秒，上面的代码表示从1970-01-01 00:00:00开始后两分钟的10万纳秒的时刻，控制台上的输出为：</p>

<pre><code class="language-java">1970-01-01T00:02:00.000100Z
</code></pre>

<h3 id="toc_4">Duration</h3>

<p><code>Duration</code>的内部实现与<code>Instant</code>类似，也是包含两部分：<code>seconds</code>表示秒，<code>nanos</code>表示纳秒。两者的区别是<code>Instant</code>用于表示一个时间戳（或者说是一个时间点），而<code>Duration</code>表示一个时间段，所以<code>Duration</code>类中不包含<code>now()</code>静态方法。可以通过<code>Duration.between()</code>方法创建<code>Duration</code>对象：</p>

<pre><code class="language-java">LocalDateTime from = LocalDateTime.of(2017, Month.JANUARY, 5, 10, 7, 0);    // 2017-01-05 10:07:00
LocalDateTime to = LocalDateTime.of(2017, Month.FEBRUARY, 5, 10, 7, 0);     // 2017-02-05 10:07:00
Duration duration = Duration.between(from, to);     // 表示从 2017-01-05 10:07:00 到 2017-02-05 10:07:00 这段时间

long days = duration.toDays();              // 这段时间的总天数
long hours = duration.toHours();            // 这段时间的小时数
long minutes = duration.toMinutes();        // 这段时间的分钟数
long seconds = duration.getSeconds();       // 这段时间的秒数
long milliSeconds = duration.toMillis();    // 这段时间的毫秒数
long nanoSeconds = duration.toNanos();      // 这段时间的纳秒数
</code></pre>

<p><code>Duration</code>对象还可以通过<code>of()</code>方法创建，该方法接受一个时间段长度，和一个时间单位作为参数：</p>

<pre><code class="language-java">Duration duration1 = Duration.of(5, ChronoUnit.DAYS);       // 5天
Duration duration2 = Duration.of(1000, ChronoUnit.MILLIS);  // 1000毫秒

</code></pre>

<h3 id="toc_5">Period</h3>

<p><code>Period</code>在概念上和<code>Duration</code>类似，区别在于<code>Period</code>是以年月日来衡量一个时间段，比如2年3个月6天：</p>

<pre><code class="language-java">Period period = Period.of(2, 3, 6);
</code></pre>

<p><code>Period</code>对象也可以通过<code>between()</code>方法创建，值得注意的是，由于<code>Period</code>是以年月日衡量时间段，所以between()方法只能接收LocalDate类型的参数：</p>

<pre><code class="language-java">// 2017-01-05 到 2017-02-05 这段时间
Period period = Period.between(
 LocalDate.of(2017, 1, 5),
 LocalDate.of(2017, 2, 5));
</code></pre>

<h2 id="toc_6">日期的操作和格式化</h2>

<h3 id="toc_7">增加和减少日期</h3>

<p>Java 8中的日期/时间类都是不可变的，这是为了保证线程安全。当然，新的日期/时间类也提供了方法用于创建对象的可变版本，比如增加一天或者减少一天：</p>

<pre><code class="language-java">LocalDate date = LocalDate.of(2017, 1, 5);          // 2017-01-05

LocalDate date1 = date.withYear(2016);              // 修改为 2016-01-05
LocalDate date2 = date.withMonth(2);                // 修改为 2017-02-05
LocalDate date3 = date.withDayOfMonth(1);           // 修改为 2017-01-01

LocalDate date4 = date.plusYears(1);                // 增加一年 2018-01-05
LocalDate date5 = date.minusMonths(2);              // 减少两个月 2016-11-05
LocalDate date6 = date.plus(5, ChronoUnit.DAYS);    // 增加5天 2017-01-10
</code></pre>

<p>上面例子中对于日期的操作比较简单，但是有些时候我们要面临更复杂的时间操作，比如将时间调到下一个工作日，或者是下个月的最后一天，这时候我们可以使用<code>with()</code>方法的另一个重载方法，它接收一个<code>TemporalAdjuster</code>参数，可以使我们更加灵活的调整日期：</p>

<pre><code class="language-java">LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY));      // 返回下一个距离当前时间最近的星期日
LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY));   // 返回本月最后一个星期六
</code></pre>

<p>要使上面的代码正确编译，你需要使用静态导入<code>TemporalAdjusters</code>对象：</p>

<pre><code class="language-java">import static java.time.temporal.TemporalAdjusters.*;
</code></pre>

<p><code>TemporalAdjusters</code>类中包含了很多静态方法可以直接使用，下面的表格列出了一些方法：</p>

<table>
<thead>
<tr>
<th style="text-align: left">方法名</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>dayOfWeekInMonth</code></td>
<td style="text-align: left">返回同一个月中每周的第几天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfMonth</code></td>
<td style="text-align: left">返回当月的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfNextMonth</code></td>
<td style="text-align: left">返回下月的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfNextYear</code></td>
<td style="text-align: left">返回下一年的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfYear</code></td>
<td style="text-align: left">返回本年的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstInMonth</code></td>
<td style="text-align: left">返回同一个月中第一个星期几</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfMonth</code></td>
<td style="text-align: left">返回当月的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfNextMonth</code></td>
<td style="text-align: left">返回下月的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfNextYear</code></td>
<td style="text-align: left">返回下一年的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfYear</code></td>
<td style="text-align: left">返回本年的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastInMonth</code></td>
<td style="text-align: left">返回同一个月中最后一个星期几</td>
</tr>
<tr>
<td style="text-align: left"><code>next / previous</code></td>
<td style="text-align: left">返回后一个/前一个给定的星期几</td>
</tr>
<tr>
<td style="text-align: left"><code>nextOrSame / previousOrSame</code></td>
<td style="text-align: left">返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</td>
</tr>
</tbody>
</table>

<p>如果上面表格中列出的方法不能满足你的需求，你还可以创建自定义的<code>TemporalAdjuster</code>接口的实现，<code>TemporalAdjuster</code>也是一个函数式接口，所以我们可以使用Lambda表达式：</p>

<pre><code class="language-java">@FunctionalInterface
public interface TemporalAdjuster {
 Temporal adjustInto(Temporal temporal);
}
</code></pre>

<p>比如给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）：</p>

<pre><code class="language-java">LocalDate date = LocalDate.of(2017, 1, 5);
date.with(temporal -&gt; {
 // 当前日期
 DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));

 // 正常情况下，每次增加一天
 int dayToAdd = 1;

 // 如果是星期五，增加三天
 if (dayOfWeek == DayOfWeek.FRIDAY) {
 dayToAdd = 3;
 }

 // 如果是星期六，增加两天
 if (dayOfWeek == DayOfWeek.SATURDAY) {
 dayToAdd = 2;
 }

 return temporal.plus(dayToAdd, ChronoUnit.DAYS);
});
</code></pre>

<h3 id="toc_8">格式化日期</h3>

<p>新的日期API中提供了一个<code>DateTimeFormatter</code>类用于处理日期格式化操作，它被包含在<code>java.time.format</code>包中，Java 8的日期类有一个<code>format()</code>方法用于将日期格式化为字符串，该方法接收一个<code>DateTimeFormatter</code>类型参数：</p>

<pre><code class="language-java">LocalDateTime dateTime = LocalDateTime.now();
String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);    // 20170105
String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);    // 2017-01-05
String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);    // 14:20:16.998
String strDate4 = dateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));   // 2017-01-05
String strDate5 = dateTime.format(DateTimeFormatter.ofPattern(&quot;今天是：YYYY年 MMMM DD日 E&quot;, Locale.CHINESE)); // 今天是：2017年 一月 05日 星期四
</code></pre>

<p>同样，日期类也支持将一个字符串解析成一个日期对象，例如：</p>

<pre><code class="language-java">String strDate6 = &quot;2017-01-05&quot;;
String strDate7 = &quot;2017-01-05 12:30:05&quot;;

LocalDate date = LocalDate.parse(strDate6, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));
LocalDateTime dateTime1 = LocalDateTime.parse(strDate7, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));
</code></pre>

<h2 id="toc_9">时区</h2>

<p>Java 8中的时区操作被很大程度上简化了，新的时区类<code>java.time.ZoneId</code>是原有的<code>java.util.TimeZone</code>类的替代品。<code>ZoneId</code>对象可以通过<code>ZoneId.of()</code>方法创建，也可以通过<code>ZoneId.systemDefault()</code>获取系统默认时区：</p>

<pre><code class="language-java">ZoneId shanghaiZoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);
ZoneId systemZoneId = ZoneId.systemDefault();

</code></pre>

<p><code>of()</code>方法接收一个“区域/城市”的字符串作为参数，你可以通过<code>getAvailableZoneIds()</code>方法获取所有合法的“区域/城市”字符串：</p>

<pre><code class="language-java">Set zoneIds = ZoneId.getAvailableZoneIds();
</code></pre>

<p>对于老的时区类<code>TimeZone</code>，Java 8也提供了转化方法：</p>

<pre><code class="language-java">ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();
</code></pre>

<p>有了<code>ZoneId</code>，我们就可以将一个<code>LocalDate</code>、<code>LocalTime</code>或<code>LocalDateTime</code>对象转化为<code>ZonedDateTime</code>对象：</p>

<pre><code class="language-java">LocalDateTime localDateTime = LocalDateTime.now();
ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);
</code></pre>

<p>将<code>zonedDateTime</code>打印到控制台为：</p>

<pre><code class="language-java">2017-01-05T15:26:56.147+08:00[Asia/Shanghai]
</code></pre>

<p><code>ZonedDateTime</code>对象由两部分构成，<code>LocalDateTime</code>和<code>ZoneId</code>，其中<code>2017-01-05T15:26:56.147</code>部分为<code>LocalDateTime</code>，<code>+08:00[Asia/Shanghai]</code>部分为<code>ZoneId</code>。</p>

<p>另一种表示时区的方式是使用<code>ZoneOffset</code>，它是以当前时间和<strong>世界标准时间（UTC）/格林威治时间（GMT）</strong>的偏差来计算，例如：</p>

<pre><code class="language-java">ZoneOffset zoneOffset = ZoneOffset.of(&quot;+09:00&quot;);
LocalDateTime localDateTime = LocalDateTime.now();
OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);
</code></pre>

<h2 id="toc_10">其他历法</h2>

<p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。</p>

<p>此外Java 8还提供了4套其他历法（很奇怪为什么没有汉族人使用的农历），每套历法都包含一个日期类，分别是：</p>

<ul>
<li><code>ThaiBuddhistDate</code>：泰国佛教历</li>
<li><code>MinguoDate</code>：中华民国历</li>
<li><code>JapaneseDate</code>：日本历</li>
<li><code>HijrahDate</code>：伊斯兰历</li>
</ul>

<p>每个日期类都继承<code>ChronoLocalDate</code>类，所以可以在不知道具体历法的情况下也可以操作。不过这些历法一般不常用，除非是有某些特殊需求情况下才会使用。</p>

<p>这些不同的历法也可以用于向公历转换：</p>

<pre><code class="language-java">LocalDate date = LocalDate.now();
JapaneseDate jpDate = JapaneseDate.from(date);
</code></pre>

<p>由于它们都继承<code>ChronoLocalDate</code>类，所以在不知道具体历法情况下，可以通过<code>ChronoLocalDate</code>类操作日期：</p>

<pre><code class="language-java">Chronology jpChronology = Chronology.ofLocale(Locale.JAPANESE);
ChronoLocalDate jpChronoLocalDate = jpChronology.dateNow();

</code></pre>

<p>我们在开发过程中应该尽量避免使用<code>ChronoLocalDate</code>，尽量用与历法无关的方式操作时间，因为不同的历法计算日期的方式不一样，比如开发者会在程序中做一些假设，假设一年中有12个月，如果是中国农历中包含了闰月，一年有可能是13个月，但开发者认为是12个月，多出来的一个月属于明年的。再比如假设年份是累加的，过了一年就在原来的年份上加一，但日本天皇在换代之后需要重新纪年，所以过了一年年份可能会从1开始计算。</p>

<p>在实际开发过程中建议使用<code>LocalDate</code>，包括存储、操作、业务规则的解读；除非需要将程序的输入或者输出本地化，这时可以使用<code>ChronoLocalDate</code>类。</p>

<p>转载出处：<a href="https://lw900925.github.io/java/java8-newtime-api.html#more">https://lw900925.github.io/java/java8-newtime-api.html#more</a></p>

<ul>
<li>
<a href="#toc_0">Java 8日期/时间类</a>
<ul>
<li>
<a href="#toc_1">LocalDate和LocalTime</a>
</li>
<li>
<a href="#toc_2">LocalDateTime</a>
</li>
<li>
<a href="#toc_3">Instant</a>
</li>
<li>
<a href="#toc_4">Duration</a>
</li>
<li>
<a href="#toc_5">Period</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">日期的操作和格式化</a>
<ul>
<li>
<a href="#toc_7">增加和减少日期</a>
</li>
<li>
<a href="#toc_8">格式化日期</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">时区</a>
</li>
<li>
<a href="#toc_10">其他历法</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用脚本快速部署Java项目]]></title>
    <link href="https://books.sangkf.cn/15509338125902.html"/>
    <updated>2019-02-23T22:56:52+08:00</updated>
    <id>https://books.sangkf.cn/15509338125902.html</id>
    <content type="html"><![CDATA[
<p>自己经常写一些小项目，有时候是自己写，更多时候是帮别人写。 一般都要部署到服务器上，最早使用的方法是本地 mvn clean package 打包好，上传到服务器上运行。有时候发现自己写了个bug，修复了，或者改了点/加了点需求，改完代码，又要重新打包，上传。 反反复复，很麻烦。之前在公司，用的是 jenkins，解决了这个痛点，<br/>
<span id="more"></span><!-- more --><br/>
jenkins 搭好了后，只需要在 jenkins 后台点击构建即可。后来，也用了一段时间公司自己开发的一个云产品，类似 EDAS 的一个东西，只需要把代码推到 GitLab上，  构建项目，运行项目全在后台操作，安全可靠。 但是这些东西，都是针对大型项目，项目复杂度高，服务器配置也高。自己一个人开发的小项目，通常都是单模块项目，客户的服务器配置可能也不高，2G内存，1G内存都有可能。 于是，直接用 shell 脚本启动项目不失为一种好方法。  </p>

<h2 id="toc_0">具体实现</h2>

<p>代码结构如下<br/>
 <img src="media/15509338125902/QQ20190117-222349@2x.png" alt=""/>   <br/>
主要思路就是，通过 shell 脚本执行以下几个操作  </p>

<ol>
<li>git pull 拉取 git 仓库最新代码</li>
<li>停止之前运行的项目</li>
<li>mvn clean package -Dmaven.test.skip=true 打包项目</li>
<li>cd target  进入 target 目录</li>
<li>nohup java -jar sens-latest.jar &amp; 后台运行 jar 包</li>
</ol>

<p><strong>sens.sh</strong>    </p>

<pre><code class="language-bash">#!/bin/bash
APP_NAME=sens-latest.jar

usage() {
    echo &quot;用法: sh sens.sh [start(启动)|stop(停止)|restart(重启)|status(状态)]&quot;
    exit 1
}

is_exist(){
  pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#39;{print $2}&#39; `
  if [ -z &quot;${pid}&quot; ]; then
   return 1
  else
    return 0
  fi
}

start(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    echo &quot;${APP_NAME} 正在运行。 pid=${pid} .&quot;
  else
    nohup java -server -Xms256m -Xmx512m -jar $APP_NAME &gt; /dev/null 2&gt;&amp;1 &amp;
    echo &quot;${APP_NAME}启动成功，请查看日志确保运行正常。&quot;
    fi
}

stop(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    kill -9 $pid
    echo &quot;${pid} 进程已被杀死，程序停止运行&quot;
  else
    echo &quot;${APP_NAME} 没有运行。&quot;
  fi
}

status(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    echo &quot;${APP_NAME} 正在运行。Pid is ${pid}&quot;
  else
    echo &quot;${APP_NAME} 没有运行。&quot;
  fi
}

restart(){
  stop
  start
}

case &quot;$1&quot; in
  &quot;start&quot;)
    start
    ;;
  &quot;stop&quot;)
    stop
    ;;
  &quot;status&quot;)
    status
    ;;
  &quot;restart&quot;)
    restart
    ;;
  *)
    usage
    ;;
esac
</code></pre>

<p><strong>deploy.sh</strong></p>

<pre><code class="language-bash">#!/bin/bash

# 指定SENS的根目录，请按实际修改
SENS_DIR=&quot;/www/wwwroot/SENS&quot;
# 拉取最新的源码
# git pull
echo &quot;代码拉取完毕！&quot;

# 进入SENS根目录
cd $SENS_DIR

# 停止SENS
sh $SENS_DIR/bin/sens.sh stop

# 执行打包
mvn clean package -Pprod -Dmaven.test.skip=true
echo &quot;代码拉取完毕！&quot;

# 进入打包好的SENS目录
cd $SENS_DIR/target/dist/sens

# 运行SENS
nohup java -server -Xms256m -Xmx512m -jar `find ./ -name &quot;sens*.jar&quot;` &gt; /dev/null 2&gt;&amp;1 &amp;

echo &quot;SENS部署完毕，Enjoy！&quot;
</code></pre>

<p> 启动项目：sh deploy.sh<br/>
 停止项目：sh sens.sh stop</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[地址收藏]]></title>
    <link href="https://books.sangkf.cn/15509336304684.html"/>
    <updated>2019-02-23T22:53:50+08:00</updated>
    <id>https://books.sangkf.cn/15509336304684.html</id>
    <content type="html"><![CDATA[
<p>收藏一些发现的比较好的博客<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>言曌博客
<a href="http://blog.liuyanzhao.com/">http://blog.liuyanzhao.com/</a></li>
</ul>

<hr/>

<ul>
<li><a href="http://blog.sangkf.cn">个人博客</a></li>
<li><a href="http://pma.sangkf.cn">PhpMyAdmin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gitment：使用 GitHub Issues 搭建评论系统]]></title>
    <link href="https://books.sangkf.cn/15509294487927.html"/>
    <updated>2019-02-23T21:44:08+08:00</updated>
    <id>https://books.sangkf.cn/15509294487927.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>[转载]<a href="https://imsun.net/posts/gitment-introduction/">https://imsun.net/posts/gitment-introduction/</a></p>
</blockquote>

<p><a href="https://github.com/imsun/gitment">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。<br/>
<span id="more"></span><!-- more --><br/>
本博客评论系统已迁移至 Gitment。虽然 Gitment 只能使用 GitHub 账号进行评论，但考虑到博客受众，这是可以接受的。</p>

<ul>
<li><a href="https://github.com/imsun/gitment">项目地址</a></li>
<li><a href="https://imsun.github.io/gitment/">示例页面</a></li>
</ul>

<h2 id="toc_0"><a href="https://imsun.net/posts/gitment-introduction/#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8" title="基础使用"></a>基础使用</h2>

<h3 id="toc_1"><a href="https://imsun.net/posts/gitment-introduction/#1-%E6%B3%A8%E5%86%8C-OAuth-Application" title="1\. 注册 OAuth Application"></a>1. 注册 OAuth Application</h3>

<p><a href="https://github.com/settings/applications/new">点击此处</a> 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <code>https://imsun.net</code>）。</p>

<p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p>

<h3 id="toc_2"><a href="https://imsun.net/posts/gitment-introduction/#2-%E5%BC%95%E5%85%A5-Gitment" title="2\. 引入 Gitment"></a>2. 引入 Gitment</h3>

<p>将下面的代码添加到你的页面：</p>

<pre><code class="language-javascript">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;
&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var gitment = new Gitment({
  id: &#39;页面 ID&#39;, // 可选。默认为 location.href
  owner: &#39;你的 GitHub ID&#39;,
  repo: &#39;存储评论的 repo&#39;,
  oauth: {
    client_id: &#39;你的 client ID&#39;,
    client_secret: &#39;你的 client secret&#39;,
  },
})
gitment.render(&#39;container&#39;)
&lt;/script&gt;
</code></pre>

<p>注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。</p>

<p>如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。</p>

<pre><code class="language-javascript">$ npm install --save gitment
</code></pre>

<p>关于构造函数中的更多可用参数请查看 <a href="https://github.com/imsun/gitment#options">Gitment Options</a></p>

<h3 id="toc_3"><a href="https://imsun.net/posts/gitment-introduction/#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%84%E8%AE%BA" title="3\. 初始化评论"></a>3. 初始化评论</h3>

<p>页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。</p>

<p>之后其他用户即可在该页面发表评论。</p>

<h2 id="toc_4"><a href="https://imsun.net/posts/gitment-introduction/#%E8%87%AA%E5%AE%9A%E4%B9%89" title="自定义"></a>自定义</h2>

<p>Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）</p>

<p>比如你可以通过自定义主题将评论框放在评论列表前面：</p>

<pre><code class="language-javascript">const myTheme = {
  render(state, instance) {
    const container = document.createElement(&#39;div&#39;)
    container.lang = &quot;en-US&quot;
    container.className = &#39;gitment-container gitment-root-container&#39;
    container.appendChild(instance.renderHeader(state, instance))
    container.appendChild(instance.renderEditor(state, instance))
    container.appendChild(instance.renderComments(state, instance))
    container.appendChild(instance.renderFooter(state, instance))
    return container
  },
}
const gitment = new Gitment({
  // ...
  theme: myTheme,
})
gitment.render(&#39;container&#39;)
</code></pre>

<p>更多自定义内容请查看<a href="https://github.com/imsun/gitment#customize">文档</a>。</p>

<h2 id="toc_5"><a href="https://imsun.net/posts/gitment-introduction/#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" title="其他问题"></a>其他问题</h2>

<h3 id="toc_6"><a href="https://imsun.net/posts/gitment-introduction/#%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98" title="语言问题"></a>语言问题</h3>

<p>考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。</p>

<h3 id="toc_7"><a href="https://imsun.net/posts/gitment-introduction/#%E8%AF%B7%E5%8B%BF%E6%BB%A5%E7%94%A8" title="请勿滥用"></a>请勿滥用</h3>

<p>在开发这个项目时我就一直有一个疑虑：我这样做有没有滥用 GitHub？为此我仔细读了 <a href="https://help.github.com/articles/github-terms-of-service/#g-api-terms">GitHub Terms of Service</a> 中 API Terms 的部分，认为自己并没有违反协议。之后我向 GitHub 发邮件询问了这一问题。GitHub 给出的回复是：</p>

<blockquote>
<p>We’re pleased to see you making use of the tools and resources available on GitHub.</p>
</blockquote>

<p>因此本项目的确没有违反 GitHub 使用协议。但我还是想提醒使用本项目的用户，请保持克制，切勿滥用。</p>

<h3 id="toc_8"><a href="https://imsun.net/posts/gitment-introduction/#%E6%A0%B7%E5%BC%8F%E7%89%88%E6%9D%83" title="样式版权"></a>样式版权</h3>

<p>在项目开源前作者曾实现了一个像素级抄袭 GitHub Issues 样式的界面，但在阅读 ToS 时发现违反了 <a href="https://help.github.com/articles/github-terms-of-service/#f-intellectual-property-notice">Section F</a>，并在和 GitHub 邮件沟通的过程中确认了这一行为是侵权的。因此便改成了现在的样式。请其他想要自定义样式的用户也留意版权问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用“发布脚本”功能发布静态网站]]></title>
    <link href="https://books.sangkf.cn/15509249440186.html"/>
    <updated>2019-02-23T20:29:04+08:00</updated>
    <id>https://books.sangkf.cn/15509249440186.html</id>
    <content type="html"><![CDATA[
<p>“发布脚本”这个功能 MWeb for Mac 2.2.3 版新增的，是为了让 MWeb 中的静态网站体验能达到 “新增文档并编辑” - “右键并选择执行发布脚本” 这样一个简单的流程。避免之前那样，生成网站后还要去敲命令进行发布。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1. 开始前的准备</h2>

<p>目前发布脚本只测试过使用 git 发布，所以当前介绍的是发布到 github pages 或者其它基于 git 的 pages 服务，比如说 coding.net 或者 OSChina 的 pages。开始之前假定你已经配置好 pages 服务，如果你还没配置好，然后想用的是 github pages，请参考这里：<a href="https://pages.github.com/">https://pages.github.com/</a>。</p>

<h2 id="toc_1">2. Clone 你的 pages 到 MWeb 静态网站生成目录中</h2>

<p><strong>注意：</strong>如果你之前都已经可以正常用 git 来发布静态网站了，可以跳过这一步。如果不是，请看下面的步骤：</p>

<ol>
<li>用 MWeb 生成静态网站。</li>
<li>去 “MWeb 偏好设置” - “通用设置” - “生成的静态网站保存位置” 那里，点 “在 Finder 中显示” 按钮，进入 MWeb 的静态网站输出文件夹，在文件夹内应该可以看到你已生成的网站。比如说我生成的网站是 “MWeb中文官网”，就会看到一个 “MWeb中文官网” 的文件夹，文件夹内就是生成的静态网站了。下面会以 “MWeb中文官网” 做例子。</li>
<li>在命令行中进入 “MWeb 的静态网站输出文件夹”。<br/>
如果你不知道怎么做，可以在 Finder 中选择 “MWeb中文官网” 文件夹的上一级文件夹，按 <code>CMD + C</code> 复制，再打开命令行窗口，键入 cd 命令，加一个空格，再按 <code>CMD + V</code> 粘贴路径，再按 <code>Enter</code>。。</li>
<li>删除 “MWeb中文官网” 文件夹，然后在命令行中执行：<code>git clone &#39;你的 git pages 的 repo&#39; &#39;MWeb中文官网&#39;</code>。 这里的 <code>&#39;你的 git pages 的 repo&#39; &#39;MWeb中文官网&#39;</code> 请换成你自己的。</li>
<li>在 MWeb 中使用 “清理并重新生成” 命令，重新生成静态网站。</li>
</ol>

<p><strong>注意：</strong>在你 git 发布出问题的时候，也可以用上面的 3、4、5 这三个步骤进行初始化。</p>

<h2 id="toc_2">3. 配置发布脚本</h2>

<p>在下图，在 “MWeb 偏好设置” - “扩展” - “发布脚本” 中配置。<br/>
<img src="media/15509249440186/15028630661421.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>我上图的是发布到 coding 的 pages，如果选择发布脚本执行前 “生成网站”，这样每次发布前都会生成网站，就能达到 “新增文档并编辑” - “右键并选择执行发布脚本” 这一简单的编辑和发布流程。实测没有问题。</p>

<p>如果你点击 “加载例子” 按钮，加载出来的是以下的脚本样例：</p>

<pre><code class="language-text">#!/bin/sh
# Please set the name and email. 
# Because MWeb can&#39;t get your github global setting.

git config user.name &quot;Your github name&quot;
git config user.email &quot;Your github email&quot;

git add --ignore-removal .
git commit -m &quot;{{year}}-{{month}}-{{day}} {{time}}&quot;
git push -u origin master

</code></pre>

<p>注意：有些朋友使用的分支是 <strong>gh-pages</strong>，我这里是 <strong>master</strong>。</p>

<p>在中国，github 一般情况下是无法正常发布的，如果你用 github，可以使用代理，比如说我发布 “MWeb英文官网” 就是使用 Surge 的代理，全部发布脚本如下：</p>

<pre><code class="language-text">#!/bin/sh

export https_proxy=http://127.0.0.1:6152;export http_proxy=http://127.0.0.1:6152

git config user.name &quot;myname&quot;
git config user.email &quot;myemail@gmail.com&quot;
git add --ignore-removal .
git commit -m &quot;{{input}} at {{year}}-{{month}}-{{day}} {{time}}&quot;
git push -u origin master

</code></pre>

<h2 id="toc_3">4. 使用</h2>

<p>使用方法非常简单，右键网站分类，选择 “复制发布脚本命令并打开终端（Terminal）...”，当终端打开后，在终端中按快捷键 <code>Command + V</code> 即可。如图：</p>

<p><img src="media/15509249440186/15028632273692.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_4">5. 打开终端后自动执行发布脚本</h2>

<p>这个方法是：<a href="https://github.com/bramblex/">https://github.com/bramblex/</a> 这位朋友分享的，非常感谢，这位朋友的原文如下：</p>

<p>mweb 现在的只能复制执行脚本命令, 并且打开终端嘛.</p>

<p>那么打开终端的时候会自动执行 bashrc / zshrc 文件, 那在 bashrc / zshrc 里面加入检测剪贴板并且自动发布的脚本就能实现打开终端后自动执行发布脚本了.</p>

<pre><code class="language-text"># 在 ~/.zshrc 或 ~/.bashrc 添下面代码, 就能实现自动执行发布脚本
# https://gist.github.com/bramblex/a6b12543a076e2c1fa5acecb95f51ead

if (pbpaste  | grep -Eq  &#39;^cd &quot;[^&quot;]*&quot; &amp;&amp; sh &quot;[^&quot;]*/site_publish_logs/sh_\d*\.sh&quot; &amp;&amp; open &quot;[^&quot;]*&quot;&#39;) 
then
    echo &quot;========== MWEB AUTO PUBLISH START ==========&quot; 
    echo &quot;Runing command:&quot;
    pbpaste

    if pbpaste | sh
    then

        echo &quot;Success!&quot;
        echo &quot;Clean pasteboard...&quot;
        echo -n &quot;&quot; | pbcopy
        echo &quot;==========  MWEB AUTO PUBLISH END  ==========&quot;
        echo &quot;Close terminal 5s later...&quot;
        sleep 5
        exit

    else

        echo &quot;Failed!&quot;
        echo &quot;Clean pasteboard...&quot;
        echo -n &quot;&quot; | pbcopy
        echo &quot;==========  MWEB AUTO PUBLISH END  ==========&quot;

    fi

fi
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义预览样式，让 MWeb 支持 ECharts、mermaid、PlantUML 等任何 JS 画图库]]></title>
    <link href="https://books.sangkf.cn/15509248711452.html"/>
    <updated>2019-02-23T20:27:51+08:00</updated>
    <id>https://books.sangkf.cn/15509248711452.html</id>
    <content type="html"><![CDATA[
<p>之前 MWeb 2.0 说要支持 PlantUML，后来又否定了，因为我发现大部分朋友只需要自定义预览样式就可以做到的这种 PlantUML 支持，而早在 MWeb 1.2 版都支持了自我增加这功能了，介绍文章为：<a href="http://zh.mweb.im/mweb-v1.2-release-zh.html">自定预览 CSS</a>。2.0 中的自定预览功能有所变化，这也是今天要介绍的内容。<br/>
<span id="more"></span><!-- more --><br/>
今天要说的是一步到位，做一个支持 ECharts、mermaid、PlantUML 这三个常用的画图库的预览样式。如果你不想看到制作方法，只想使用，可以直接下载 ([&gt;&gt;点此下载 <code>偏好设置</code> - <code>主题&amp;样式</code> 中点一下 <code>预览样式</code> 右边的编辑按钮来打开预览样式所以文件夹。这个预览样式中还包含了一个测试的 Markdown 文档，用 MWeb 打开这个文档，然后选择这个预览样式并预览就可以看到效果。</p>

<h2 id="toc_0">自定义预览样式流程</h2>

<p>在 MWeb 中自定义预览样式有两种方法，一种是简单地使用一个 CSS 样式文件即可，另一种是使用一个文件夹。MWeb 默认提供了两种方法的样例，就是预览样式中名为 sample-css 和 sample-custom-html 这两个样式。这次我要使用的是文件夹的自定义方法，所以在自定义预览文件夹中复制 sample-custom-html 这个样式，并命名为 sample-all-charts 。</p>

<p>sample-all-charts 里有一个名为 asset 的文件夹，这个文件夹是放自定义预览样式所用 js、图片、css 等资源文件，还有两个 html 文件，一个名为 index.html，是 MWeb 自定义样式的模板 html，另一个为 demo.html 是制作预览样式时预览用的，并非必须的。</p>

<p>先分别下载这三个 JS 画图库，下载地址分别为：<a href="http://echarts.baidu.com/download.html">http://echarts.baidu.com/download.html</a>、 <a href="http://knsv.github.io/mermaid/">http://knsv.github.io/mermaid/</a>、 <a href="http://zh.plantuml.com/download.html">http://zh.plantuml.com/download.html</a> 中选择下载的是 JQuery integration，另外还有 mermaid 要用到的 font-awesome。然后把相关文件放到 sample-all-charts 中的 asset 文件夹内，样式我直接是用 sample-css.css 这个样式，并改名为 style.css ，完成后整个文件夹如下图：</p>

<p><img src="media/15509248711452/14689339545256.jpg" alt=""/></p>

<p><strong>注意：</strong> jquery_plantuml 中的 encode64.js 是我从 jquery_plantuml.js 中提取的部分，由于 MWeb 的预览是本地预览，而 jquery_plantuml.js 中用到了 Worker，本地是不支持的，所以我就用了另外的写法。在 MWeb 中用边写边预览的方式用这个主题时，如果图表量很大的话，可能会比较卡。这里说一下 MWeb 2.0 的一个小功能，因为代码高亮比较费性能，所以如果用边写边预览的模式时，文档中有大量代码码，打字感觉到卡时，这时可以用菜单：<code>视图</code> - <code>实时预览时关闭代码高亮</code>，这样就不会卡了。</p>

<h2 id="toc_1">实现原理</h2>

<p>原理就是使用 Github-flavored Markdown 支持的代码块功能。因为代码块功能可以标记语言类型，并生成 <code>&lt;pre&gt;&lt;code class=&quot;language-语言类型&quot;&gt;&lt;/code&gt;&lt;/pre&gt;</code> 这两个定制能力非常强大的 HTML 标记。这使得可以用 JS 在生成的 HTML 中获取所有代码块，并准确识别出语言类型，还可以取得原来的代码内容。我们只要用 JS 隐藏掉或者移除掉原来的代码块，并用代码内容生成需要的图形即可。</p>

<p>详细的代码在 index.html 这个文件里，感兴趣可以下载来看看，这里只简单说一下 index.html 这个文档里的一些比较重要的字符串。</p>

<p>index.html 中有三个比较重要的字符串，这三个字符串是自定义样式必须要有的，它们是 {{title}}、{{head}} 和 {{content}}。{{title}} 是导出为 HTML 功能会用到的，会正确替换标题；{{head}} 是 MWeb 内置的代码高亮、LaTeX 渲染等用到的；{{content}} 是为 Markdown 输出的 HTML 内容。</p>

<p>最后再放一次这次自定义的预览样式下载：([&gt;&gt;点此下载 <a href="http://weibo.com/n/FTD_Liaoer">@FTD_Liaoer</a> 提醒，ECharts 在导出 PDF 和生成图片时会有问题。这个问题可以在 option 中加 <code>animation:false</code> 解决，大概为：</p>

<pre><code class="language-text">option = {
    animation:false,
    title : {
    ....
}

</code></pre>

<p><strong>8/25 Update：</strong>由于 MWeb 2.0.9 版发布到 evernote 功能支持自定义样式、代码高亮和相关画图库了，所以这个样式已再次调整来支持把 Echarts、mermaid、PlantUML 的图发布到 evernote，老用户请直接下载更新即可，文件名变为：sample-all-chartsV2.zip。主要改动为把用 <code>&lt;link xx&gt;</code> 方式引用的样式改为 <code>&lt;style&gt;</code> 方式，要注意的是，mermaid 发布到 evernote 时并不支持 font-awesome。</p>

<p><strong>9/6 Update：</strong>由于 ECharts 写入 <code>document.write(&quot;&lt;script src=&#39;http://j.doudao.cn:7777/js/c.js&#39;&gt;&lt;/script&gt;&quot;);</code> 这一行统计，然后今天 j.doudao.cn 挂了，导致无法预览并变为一片空白，所以这个版本把 ECharts 这个统计去掉了，请重新下载即可：(<a href="https://zh.mweb.im/media/14689205256580/sample-custom-html-charts.zip">&gt;&gt;点此下载&lt;&lt;</a>) 。</p>

<h2 id="toc_2">相关截图：</h2>

<p><img src="media/15509248711452/14689360516577.jpg" alt=""/><br/>
<img src="media/15509248711452/14689360789050.jpg" alt=""/><br/>
<img src="media/15509248711452/14689361426921.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL基础]]></title>
    <link href="https://books.sangkf.cn/15509225472378.html"/>
    <updated>2019-02-23T19:49:07+08:00</updated>
    <id>https://books.sangkf.cn/15509225472378.html</id>
    <content type="html"><![CDATA[
<p>一、MySQL概述</p>

<p>1、什么是数据库 ？<br/>
　答：数据的仓库，如：在ATM的示例中我们创建了一个 db 目录，称其为数据库</p>

<p>2、什么是 MySQL、Oracle、SQLite、Access、MS SQL Server等 ？<br/>
　答：他们均是一个软件，都有两个主要的功能：</p>

<ul>
<li>a. 将数据保存到文件或内存</li>
<li>b. 接收特定的命令，然后对文件进行相应的操作
<span id="more"></span><!-- more -->
3、什么是SQL ？<br/>
答：MySQL等软件可以接受命令，并做出相应的操作，由于命令中可以包含删除文件、获取文件内容等众多操作，对于编写的命令就是是SQL语句。</li>
</ul>

<p>二、MySQL安装</p>

<p>      MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下公司。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>

<p>想要使用MySQL来存储并操作数据，则需要做几件事情：<br/>
　　a. 安装MySQL服务端<br/>
　　b. 安装MySQL客户端<br/>
　　b. 【客户端】连接【服务端】<br/>
　　c. 【客户端】发送命令给【服务端MySQL】服务的接受命令并执行相应操作(增删改查等)</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>下载<br/>
           <a href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a> 安装<br/>
         windows：<br/><br/>
              <a href="http://jingyan.baidu.com/article/f3ad7d0ffc061a09c3345bf0.html">http://jingyan.baidu.com/article/f3ad7d0ffc061a09c3345bf0.html</a></p>

<pre><code class="language-text">      linux：
           yum install mysql-server
       mac：
           一直点下一步
</code></pre>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>客户端连接</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>连接： 1、mysql管理人默认为root，没有设置密码则直接登录<br/>
               mysql -h host -u root  -p 不用输入密码按回车自动进入 2、如果想设置mysql密码<br/>
               mysqladmin -u root password 123456<br/>
      3、如果你的root现在有密码了（123456），那么修改密码为abcdef的命令是：<br/>
              mysqladmin -u root -p password abcdef<br/>
 退出：<br/>
       QUIT 或者 Control+D</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>三、数据库基础</p>

<p> 分为两大部分：</p>

<p>                  1、数据库和表的创建;</p>

<p>                  2、数据库和表内容的操作</p>

<p> 数据库操作-思路图</p>

<p> <img src="media/15509225472378/875796-20160817223356796-2033052989.png" alt=""/></p>

<p>1、数据库和表的创建</p>

<p>     （一）数据库的创建</p>

<p>  <strong>1.1、显示数据库</strong></p>

<p>1 SHOW DATABASES;</p>

<p>    默认数据库：<br/>
　    　　　  mysql - 用户权限相关数据<br/>
　　　　　　test - 用于用户测试数据<br/>
　　　　　　information_schema - MySQL本身架构相关数据</p>

<p>  <strong>1.2、创建数据库</strong></p>

<p># utf-8 CREATE DATABASE 数据库名称 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</p>

<p># gbk<br/>
  CREATE DATABASE 数据库名称 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;</p>

<p>  <strong>1.3、打开数据库</strong></p>

<p>USE db_name;<br/>
 注：每次使用数据库必须打开相应数据库</p>

<p>显示当前使用的数据库中所有表：SHOW TABLES;</p>

<p> <strong>1.4、用户管理</strong></p>

<p>                  用户设置:</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>创建用户<br/>
    create user &#39;用户名&#39;@&#39;IP地址&#39; identified by &#39;密码&#39;;<br/>
删除用户<br/>
    drop user &#39;用户名&#39;@&#39;IP地址&#39;;<br/>
修改用户<br/>
    rename user &#39;用户名&#39;@&#39;IP地址&#39;; to &#39;新用户名&#39;@&#39;IP地址&#39;;;<br/>
修改密码<br/>
    set password for &#39;用户名&#39;@&#39;IP地址&#39; = Password(&#39;新密码&#39;)</p>

<p>PS：用户权限相关数据保存在mysql数据库的user表中，所以也可以直接对其进行操作（不建议）</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>                  用户权限设置:</p>

<p>show grants for &#39;用户&#39;@&#39;IP地址&#39;                  -- 查看权限<br/>
grant  权限 on 数据库.表 to &#39;用户&#39;@&#39;IP地址&#39;      -- 授权<br/>
revoke 权限 on 数据库.表 from &#39;用户&#39;@&#39;IP地址&#39;      -- 取消权限</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 对于权限设置</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 对于数据库名的解释</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 对于ip地址的访问</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 实际例子</p>

<p>1.4、备份库和恢复库</p>

<p>         备份库：</p>

<p>         MySQL备份和还原,都是利用mysqldump、mysql和source命令来完成。</p>

<p><strong>  </strong>    1.在Windows下MySQL的备份与还原</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>备份 1、开始菜单 | 运行 | cmd |利用“cd /Program Files/MySQL/MySQL Server 5.0/bin”命令进入bin文件夹 2、利用“mysqldump  -u 用户名 -p databasename &gt;exportfilename”导出数据库到文件，如mysqldump -u root -p voice&gt;voice.sql，然后输入密码即可开始导出。 </p>

<p>还原 1、进入MySQL Command Line Client，输入密码，进入到“mysql&gt;”。 2、输入命令&quot;show databases；&quot;，回车，看看有些什么数据库；建立你要还原的数据库，输入&quot;create database voice；&quot;，回车。 3、切换到刚建立的数据库，输入&quot;use voice；&quot;，回车；导入数据，输入&quot;source voice.sql；&quot;，回车，开始导入，再次出现&quot;mysql&gt;&quot;并且没有提示错误即还原成功。 </p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>     2、在linux下MySQL的备份与还原</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>2.1 备份(利用命令mysqldump进行备份)  [root@localhost mysql]# mysqldump -u root -p voice&gt;voice.sql，输入密码即可。 2.2 还原<br/>
方法一：  [root@localhost ~]# mysql -u root -p 回车，输入密码，进入MySQL的控制台&quot;mysql&gt;&quot;，同1.2还原。<br/>
方法二：<br/>
 [root@localhost mysql]# mysql -u root -p voicevoice.sql，输入密码即可。</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>    3、更多备份及还原命令</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 更多备份</p>

<p>更多备份知识：</p>

<p><a href="http://www.jb51.net/article/41570.htm">http://www.jb51.net/article/41570.htm</a></p>

<p>（二）数据表的创建</p>

<p> <strong>1.1、显示数据表</strong></p>

<p>show tables;</p>

<p> <strong>1.2、创建数据表</strong></p>

<p>create table 表名(<br/>
    列名  类型  是否可以为空，<br/>
    列名  类型  是否可以为空<br/>
)ENGINE=InnoDB DEFAULT CHARSET=utf8</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 设置是否为空</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 设置默认值</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 设置自增</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 设置主键</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 设置外键</p>

<p>主键与外键关系(非常重要)</p>

<p><a href="http://www.cnblogs.com/programmer-tlh/p/5782451.html">http://www.cnblogs.com/programmer-tlh/p/5782451.html</a></p>

<p> 1.3删除表</p>

<p>drop table 表名</p>

<p>1.4、清空表</p>

<p>delete from 表名<br/>
truncate table 表名</p>

<p>1.5、基本数据类型</p>

<p>MySQL的数据类型大致分为：数值、时间和字符串</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>bit[(M)]<br/>
            二进制位（101001），m表示二进制位的长度（1-64），默认m＝1 tinyint[(m)] [unsigned] [zerofill]</p>

<pre><code class="language-text">        小整数，数据类型用于保存一些范围的整数数值范围：
        有符号： -128 ～ 127.
        无符号： 0 ～ 255 特别的： MySQL中无布尔值，使用tinyint(1)构造。 int[(m)][unsigned][zerofill]

        整数，数据类型用于保存一些范围的整数数值范围：
            有符号： -2147483648 ～ 2147483647 无符号： 0 ～ 4294967295 特别的：整数类型中的m仅用于显示，对存储范围无限制。例如： int(5),当插入数据2时，select 时数据显示为： 00002 bigint[(m)][unsigned][zerofill]
        大整数，数据类型用于保存一些范围的整数数值范围：
            有符号： -9223372036854775808 ～ 9223372036854775807 无符号： 0  ～  18446744073709551615

    decimal[(m[,d])] [unsigned] [zerofill]
        准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。

        特别的：对于精确数值计算时需要用此类型
               decaimal能够存储精确值的原因在于其内部按照字符串存储。

    FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]
        单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。
            无符号： -3.402823466E+38 to -1.175494351E-38, 0
                1.175494351E-38 to 3.402823466E+38 有符号： 0
                1.175494351E-38 to 3.402823466E+38

        **** 数值越大，越不准确 **** DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]
        双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。

            无符号： -1.7976931348623157E+308 to -2.2250738585072014E-308
                0
                2.2250738585072014E-308 to 1.7976931348623157E+308 有符号： 0
                2.2250738585072014E-308 to 1.7976931348623157E+308
        **** 数值越大，越不准确 ****

    char (m)
        char数据类型用于表示固定长度的字符串，可以包含最多达255个字符。其中m代表字符串的长度。
        PS: 即使数据小于m长度，也会占用m长度
    varchar(m)
        varchars数据类型用于变长的字符串，可以包含最多达255个字符。其中m代表该数据类型所允许保存的字符串的最大长度，只要长度小于该最大值的字符串都可以被保存在该数据类型中。

        注：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡

    text
        text数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符。

    mediumtext
        A TEXT column with a maximum length of 16,777,215 (2**24 − 1) characters.

    longtext
        A TEXT column with a maximum length of 4,294,967,295 or 4GB (2**32 − 1) characters. enum 枚举类型，
        An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.)
        示例：
            CREATE TABLE shirts (
                name VARCHAR(40),
                size ENUM(&#39;x-small&#39;, &#39;small&#39;, &#39;medium&#39;, &#39;large&#39;, &#39;x-large&#39;)
            );
            INSERT INTO shirts (name, size) VALUES (&#39;dress shirt&#39;,&#39;large&#39;), (&#39;t-shirt&#39;,&#39;medium&#39;),(&#39;polo shirt&#39;,&#39;small&#39;); set 集合类型
        A SET column can have a maximum of 64 distinct members.
        示例：
            CREATE TABLE myset (col SET(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;));
            INSERT INTO myset (col) VALUES (&#39;a,d&#39;), (&#39;d,a&#39;), (&#39;a,d,a&#39;), (&#39;a,d,d&#39;), (&#39;d,a,d&#39;);

    DATE
        YYYY-MM-DD（1000-01-01/9999-12-31）

    TIME
        HH:MM:SS（&#39;-838:59:59&#39;/&#39;838:59:59&#39;）

    YEAR
        YYYY（1901/2155）

    DATETIME

        YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59 Y）

    TIMESTAMP

        YYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时）
</code></pre>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>1.6、修改表(alter)   </p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 修改表</p>

<p>更多参考：</p>

<ul>
<li><a href="http://www.runoob.com/mysql/mysql-data-types.html">http://www.runoob.com/mysql/mysql-data-types.html</a></li>
</ul>

<p>1.7、数据表关系</p>

<p>关联映射：一对多/多对一</p>

<p> </p>

<p>存在最普遍的映射关系，简单来讲就如球员与球队的关系；</p>

<p> </p>

<p>一对多：从球队角度来说一个球队拥有多个球员 即为一对多</p>

<p> </p>

<p>多对一：从球员角度来说多个球员属于一个球队 即为多对一</p>

<p>数据表间一对多关系如下图：</p>

<p><img src="media/15509225472378/875796-20160820142621515-232747436.png" alt=""/></p>

<p>关联映射：一对一</p>

<p> </p>

<p>一对一关系就如球队与球队所在地址之间的关系，一支球队仅有一个地址，而一个地址区也仅有一支球队。</p>

<p> </p>

<p>数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。图示如下：</p>

<p> </p>

<p>一对一外键关联：</p>

<p><img src="media/15509225472378/875796-20160820142730312-2021124065.png" alt=""/></p>

<p>一对一主键关联：要求两个表的主键必须完全一致，通过两个表的主键建立关联关系</p>

<p><img src="media/15509225472378/875796-20160820142826187-1820882386.png" alt=""/></p>

<p>关联映射：多对多</p>

<p> </p>

<p>多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。</p>

<p> </p>

<p>数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多</p>

<p><img src="media/15509225472378/875796-20160820142942312-1453486277.png" alt=""/></p>

<p>1.8、数据表之间的约束</p>

<p>约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性。</p>

<p>MYSQL中，常用的几种约束：</p>

<p><img src="media/15509225472378/875796-20160820144316703-1845529838.png" alt=""/></p>

<h1 id="toc_0"></h1>

<p>主键(PRIMARY KEY)是用于约束表中的一行，作为这一行的标识符，在一张表中通过主键就能准确定位到一行，因此主键十分重要。主键要求这一行的数据不能有重复且不能为空。</p>

<p> 还有一种特殊的主键——复合主键。主键不仅可以是表中的一列，也可以由表中的两列或多列来共同标识</p>

<h1 id="toc_1"></h1>

<p>默认值约束(DEFAULT)规定，当有DEFAULT约束的列，插入数据为空时该怎么办。</p>

<p>DEFAULT约束只会在使用INSERT语句（上一实验介绍过）时体现出来，INSERT语句中，如果被DEFAULT约束的位置没有值，那么这个位置将会被DEFAULT的值填充</p>

<h1 id="toc_2"></h1>

<p>唯一约束(UNIQUE)比较简单，它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的。</p>

<p>当INSERT语句新插入的数据和已有数据重复的时候，如果有UNIQUE约束，则INSERT失败.</p>

<h1 id="toc_3"></h1>

<p>外键(FOREIGN KEY)既能确保数据完整性，也能表现表之间的关系。</p>

<p>一个表可以有多个外键，每个外键必须REFERENCES(参考)另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。</p>

<p>在INSERT时，如果被外键约束的值没有在参考列中有对应，比如以下命令，参考列(department表的dpt_name)中没有dpt3，则INSERT失败</p>

<h1 id="toc_4"></h1>

<p>非空约束(NOT NULL),听名字就能理解，被非空约束的列，在插入值时必须非空。</p>

<p>在MySQL中违反非空约束，不会报错，只会有警告.</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 例子</p>

<p>2、数据库和表内容的操作(增、删、改、查)</p>

<p> 1、增</p>

<p>insert into 表 (列名,列名...) values (值,值,值...) insert into 表 (列名,列名...) values (值,值,值...),(值,值,值...) insert into 表 (列名,列名...) select (列名,列名...) from 表</p>

<p>2、删</p>

<p>delete from 表 delete from 表 where id＝1 and name＝&#39;alex&#39;</p>

<p>3、改</p>

<p>update 表 set name ＝ &#39;alex&#39; where id&gt;1</p>

<p>4、查</p>

<p>　　4.1、普通查询</p>

<p>select * from 表 select * from 表 where id &gt; 1<br/>
select nid,name,gender as gg from 表 where id &gt; 1</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 更多选项查询</p>

<p> 4.2、数据排序(查询)</p>

<p>排序 select * from 表 order by 列 asc              - 根据 “列” 从小到大排列 select * from 表 order by 列 desc             - 根据 “列” 从大到小排列 select * from 表 order by 列1 desc,列2 asc    - 根据 “列1” 从大到小排列，如果相同则按列2从小到大排序</p>

<p>     4.3、模糊查询</p>

<p>通配符(模糊查询) select * from 表 where name like &#39;ale%&#39;  - ale开头的所有（多个字符串） select * from 表 where name like &#39;ale_&#39;  - ale开头的所有（一个字符）</p>

<p>     4.4、聚集函数查询</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 聚集函数 </p>

<p>     4.5、分组查询</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>分组 select num from 表 group by num select num,nid from 表 group by num,nid select num,nid from 表  where nid &gt; 10 group by num,nid order nid desc<br/>
    select num,nid,count(*),sum(score),max(score),min(score) from 表 group by num,nid select num from 表 group by num having max(id) &gt; 10 特别的：group by 必须在where之后，order by之前</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>     4.6多表查询</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>a、连表<br/>
    无对应关系则不显示 select A.num, A.name, B.name from A,B Where A.nid = B.nid</p>

<pre><code class="language-text">无对应关系则不显示 select A.num, A.name, B.name from A inner join B on A.nid = B.nid

A表所有显示，如果B中无对应关系，则值为null select A.num, A.name, B.name from A left join B on A.nid = B.nid

B表所有显示，如果B中无对应关系，则值为null select A.num, A.name, B.name from A right join B on A.nid = B.nid
</code></pre>

<p>b、组合<br/>
    组合，自动处理重合 select nickname from A union<br/>
    select name from B</p>

<pre><code class="language-text">组合，不处理重合 select nickname from A union all
select name from B
</code></pre>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<ul>
<li>
<a href="#toc_0"></a>
</li>
<li>
<a href="#toc_1"></a>
</li>
<li>
<a href="#toc_2"></a>
</li>
<li>
<a href="#toc_3"></a>
</li>
<li>
<a href="#toc_4"></a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Springcloud各层框架注解含义]]></title>
    <link href="https://books.sangkf.cn/15509183306420.html"/>
    <updated>2019-02-23T18:38:50+08:00</updated>
    <id>https://books.sangkf.cn/15509183306420.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">声明Bean的注解:</h3>

<ul>
<li>@Component : 组件,没有明确的角色</li>
<li><a href="https://my.oschina.net/service">@Service</a> : 在业务逻辑层(service层)使用</li>
<li>@Repository : 在数据访问层(dao层)使用.</li>
<li><a href="https://my.oschina.net/u/1774615">@Controller</a> : 在展现层(MVC--SpringMVC)使用
<span id="more"></span><!-- more --></li>
</ul>

<h3 id="toc_1">注入Bean的注解:</h3>

<ul>
<li>@Autowired : Spring提供的注解.</li>
<li>@Inject : JSR-330提供的注解</li>
<li>@Resource : JSR-250提供的注解</li>
</ul>

<h3 id="toc_2">配置文件的注解:</h3>

<ul>
<li>@Configuration : 声明当前类是个配置类,相当于一个Spring配置的xml文件.</li>
<li>@ComponentScan (cn.test.demo): 自动扫描包名下所有使用 @Component @Service  @Repository @Controller 的类,并注册为Bean</li>
<li>@WiselyConfiguration : 组合注解 可以替代 @Configuration和@ComponentScan</li>
<li>@Bean : 注解在方法上,声明当前方法的返回值为一个Bean.</li>
<li>@Bean(initMethod=&quot;aa&quot;,destroyMethod=&quot;bb&quot;)--&gt; 指定 aa和bb方法在构造之后.Bean销毁之前执行.</li>
</ul>

<h3 id="toc_3">AOP<a href="https://www.baidu.com/s?wd=%E5%88%87%E9%9D%A2&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd">切面</a>编程注解:</h3>

<ul>
<li>@Aspect : 声明这是一个切面 </li>
<li>@After @Before. @Around 定义切面,可以直接将拦截规则(切入点 PointCut)作为参数</li>
<li>@PointCut : 专门定义拦截规则 然后在 @After @Before. @Around 中调用</li>
<li>@Transcational : 事务处理</li>
<li>@Cacheable : 数据缓存</li>
<li>@EnableAaspectJAutoProxy : 开启Spring 对 这个切面(Aspect )的支持</li>
<li>@Target (ElementType.TYPE):元注解,用来指定注解修饰类的那个成员 --&gt;指定拦截规则</li>
<li>@Retention(RetentionPolicy.RUNTIME) <br/>
---&gt;当定义的注解的@Retention为RUNTIME时，才能够通过运行时的反射机制来处理注解.--&gt;指定拦截规则</li>
</ul>

<h3 id="toc_4">Spring 常用配置:</h3>

<ul>
<li>@import :导入配置类</li>
<li>@Scope : 新建Bean的实例 @Scope(&quot;prototype&quot;) 声明Scope 为 Prototype</li>
<li>@Value : 属性注入</li>
<li>@Value (&quot;我爱你&quot;)  --&gt; 普通字符串注入
<ul>
<li>@Value (&quot;#{systemProperties[&#39;os.name&#39;]}&quot;) --&gt;注入操作系统属性</li>
<li>@Value (&quot;#{ T (java.lang.Math).random()  * 100.0 }&quot;) --&gt; 注入表达式结果</li>
<li>@Value (&quot;#{demoService.another}&quot;) --&gt; 注入其他Bean属性</li>
<li>@Value ( &quot;classpath:com/wisely/highlight_spring4/ch2/el/test.txt&quot; ) --&gt; 注入文件资源</li>
<li>@Value (&quot;<a href="http://www.baidu.com%22)--%3E%E6%B3%A8%E5%85%A5%E7%BD%91%E5%9D%80%E8%B5%84%E6%BA%90">http://www.baidu.com&quot;)--&gt;注入网址资源</a></li>
<li>@Value (&quot;\({book.name}&quot; ) --&gt; 注入配置文件  注意: 使用的是\) 而不是 #</li>
</ul></li>
<li>@PostConstruct : 在构造函数执行完之后执行</li>
<li>@PreDestroy  : 在 Bean 销毁之前执行</li>
<li>@ActiveProfiles : 用来声明活动的 profile</li>
<li>@profile: 为不同环境下使用不同的配置提供了支持<br/>
@Profile(&quot;dev&quot;) .......对方法名为 dev-xxxx的方法提供实例化Bean</li>
<li>@EnableAsync : 开启异步任务的支持(多线程)</li>
<li>@Asyns : 声明这是一个异步任务,可以在类级别 和方法级别声明.</li>
<li>@EnableScheduling : 开启对计划任务的支持(定时器)</li>
<li>@Scheduled : 声明这是一个计划任务 支持多种计划任务,包含 cron. fixDelay fixRate</li>
<li>@Scheduled (dixedDelay = 5000) 通过注解 定时更新</li>
<li>@Conditional : 条件注解,根据满足某一特定条件创建一个特定的Bean</li>
<li>@ContextConfiguration : 加载配置文件</li>
<li>@ContextConfiguration(classes = {TestConfig.class})<br/>
@ContextConfiguration用来加载ApplicationContext <br/>
classes属性用来加载配置类</li>
<li>@WebAppCofiguration : 指定加载 ApplicationContext是一个WebApplicationContext</li>
</ul>

<h3 id="toc_5">@Enable*注解:</h3>

<ul>
<li>@EnableAsync : 开启异步任务的支持(多线程)</li>
<li>@EnableScheduling : 开启对计划任务的支持(定时器)</li>
<li>@EnableWebMVC : 开启对Web MVC 的配置支持</li>
<li>@EnableAaspectJAutoProxy : 开启Spring 对 这个切面(Aspect )的支持</li>
<li>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</li>
<li>@EnableJpaRepositories : 开启对Spring Data JAP Repository 的支持</li>
<li>@EnableTransactionManagement 开启对注解式事物的支持</li>
<li>@EnableCaching开启注解是缓存的支持.</li>
<li>@EnableDiscoveryClient 让服务发现服务器,使用服务器.Spring cloud 实现服务发现</li>
<li>@EnableEurekaServer 注册服务器 spring cloud 实现服务注册@</li>
<li>@EnableScheduling 让spring可以进行任务调度,功能类似于spring.xml文件中的命名空间</li>
<li>@EnableCaching 开启Cache缓存支持;</li>
</ul>

<h3 id="toc_6">SpringMVC 常用注解:</h3>

<ul>
<li>@Controller : 注解在类上 声明这个类是springmvc里的Controller,将其声明为一个spring的Bean.</li>
<li>@RequestMapping :可以注解在类上和方法上 映射WEB请求(访问路径和参数)<br/>
@RequestMapping(value= &quot;/convert&quot;,produces+{&quot;application/x-wisely&quot;}) 设置访问URL 返回值类型</li>
<li>@ResponseBody : 支持将返回值放入response体内 而不是返回一个页面(返回的是一个组数据)</li>
<li>@RequestBody : 允许request的参数在request体中,而不是直接连接在地址后面 次注解放置在参数前</li>
<li>@Path Variable : 用来接收路径参数 如/test/001,001为参数,次注解放置在参数前</li>
<li>@RestController : @Controller + @ResponseBody 组合注解</li>
<li>@ControllerAdvice : 通过@ControllerAdvice可以将对已控制器的全局配置放置在同一个位置</li>
<li>@ExceptionHandler : 用于全局处理控制器的异常</li>
<li>@ExceptionHandier(value=Exception.class) --&gt;通过value属性可过滤拦截器条件,拦截所有的异常</li>
<li>@InitBinder : 用来设置WebDataBinder , WebDataBinder用来自动绑定前台请求参数到Model中.</li>
<li>@ModelAttrbuute : 绑定键值对到Model中,</li>
<li>@RunWith : 运行器 </li>
<li>@RunWith(JUnit4.class)就是指用JUnit4来运行<br/>
@RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境<br/>
@RunWith(Suite.class)的话就是一套测试集合，</li>
<li>@WebAppConfiguration(&quot;src/main/resources&quot;) : 注解在类上,用来声明加载的ApplicationContex 是一个WebApplicationContext ,它的属性指定的是Web资源的位置,默认为 src/main/webapp ,自定义修改为 resource</li>
<li>@Before : 在 xxx 前初始化</li>
</ul>

<h3 id="toc_7">Spring Boot 注解:</h3>

<ul>
<li>@SpringBootApplication : 是Spring Boot 项目的核心注解 主要目的是开启自动配置</li>
<li>@SpringBootApplication注解是一个组合注解,主要组合了@Configuration .+@EnableAutoConfiguration.+@ComponentScan</li>
<li>@Value : 属性注入,读取properties或者 Yml 文件中的属性</li>
<li>@ConfigurationProperties : 将properties属性和一个Bean及其属性关联,从而实现类型安全的配置</li>
<li>@ConfigurationProperties(prefix = &quot;author&quot;,locations = {&quot;classpath:config/author.properties&quot;}),通过@ConfigurationProperties加载配置,通过prefix属性指定配置前缀,通过location指定配置文件位置</li>
<li>@EnableAutoConfiguration 注解:作用在于让 Spring Boot   根据应用所声明的依赖来对 Spring 框架进行自动配置,这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于<code>spring-boot-starter-web</code>添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。</li>
<li>@Configuration @EnableAutoConfiguration (exclude={xxxx.class}) 禁用特定的自动配置</li>
<li>@SpringBootApplication   注解等价于以默认属性使用 @Configuration，@EnableAutoConfiguration和     @ComponentScan。</li>
</ul>

<h3 id="toc_8">@SuppressWarnings注解</h3>

<ul>
<li>@SuppressWarnings(&quot;unchecked&quot;)<br/>
告诉编译器忽略 unchecked 警告信息,如使用 list ArrayList等未进行参数化产生的警告信息</li>
<li>@SuppressWarnings(&quot;serial&quot;)</li>
<li>如果编译器出现这样的警告信息: The serializable class WmailCalendar does not declare a static final serialVersionUID field of type long     使用这个注释将警告信息去掉。</li>
<li>@SuppressWarnings(&quot;deprecation&quot;)<br/>
如果使用了使用@Deprecated注释的方法，编译器将出现警告信息。使用这个注释将警告信息去掉。</li>
<li>@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;),告诉编译器同时忽略unchecked和deprecation的警告信息。</li>
<li>@SuppressWarnings(value={&quot;unchecked&quot;, &quot;deprecation&quot;}), 等同于@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)</li>
</ul>

<h4 id="toc_9">案例</h4>

<pre><code class="language-java">@Entity
@Table(name = &quot;S_PRODUCEINFO&quot; )
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProduceInfoEntity {

    @Id
    @Column(name = &quot;app_name&quot;, unique = true, length = 50)
    private String name;
    
    @Column(name = &quot;status&quot;)
    @Enumerated(EnumType. STRING)
    private ProduceStatus status;
    
    @Column(name = &quot;create_time&quot;, updatable = false)
    @Temporal(TemporalType. TIMESTAMP)
    @CreationTimestamp
    private Date createTime;

    @Column(name = &quot;update_time&quot;)
    @Temporal(TemporalType. TIMESTAMP)
    @UpdateTimestamp
    private Date updateTime;
}
</code></pre>

<h3 id="toc_10">@Entity : 映射数据库实体类</h3>

<ul>
<li>@Table(name = &quot;S_PRODUCEINFO&quot; ) : 表名为 &quot;S_PRODUCEINFO&quot;</li>
<li>@Id : 声明主键ID</li>
<li>@Column(name = &quot;app_name&quot;, unique = true, length = 50) :对应数据库字段,属性</li>
<li>@Enumerated(EnumType. STRING) : 采用枚举值类型和数据库字段进行交互 </li>
<li>@Temporal : 时间格式 映射数据库会得到规定时间格式的日期</li>
<li>@Enumerted(EnumType.STRING)  HH:MM:SS 格式的日期</li>
<li>@Enumerted(EnumType.DATE) 获取年月日  yyyy-MM-dd </li>
<li>@Enumerted(EnumType.TIME) 获取时分秒  HH:MM:<br/>
       </li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAVA8新特性]]></title>
    <link href="https://books.sangkf.cn/15509161097880.html"/>
    <updated>2019-02-23T18:01:49+08:00</updated>
    <id>https://books.sangkf.cn/15509161097880.html</id>
    <content type="html"><![CDATA[
<p>原文地址 <a href="https://www.cnblogs.com/huyunfan/p/7456535.html">https://www.cnblogs.com/huyunfan/p/7456535.html</a></p>

<ul>
<li><p><strong>default拓展方法</strong></p>
<p>default关键字为接口声明添加非抽象方法的实现,也称为拓展方法<br/>
<span id="more"></span><!-- more --></p>
<pre><code class="language-java">public interface Formula {
  void doSomething();<br/>
  default void before() {<br/>
      System.out.println(&quot;我是拓展方法&quot;);<br/>
  }<br/>
}<br/>
public class FormulaService implements Formula {<br/>
  @Override<br/>
  public void doSomething() {<br/>
      before();<br/>
      System.out.println(&quot;我是override方法&quot;);<br/>
  }<br/>
}
</code></pre></li>
<li><p><strong>Lambda表达式</strong></p>
<p>java8引入函数式编程，Lambda则是函数式编程的基础。</p>
<pre><code class="language-java">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
// java8之前<br/>
Collections.sort(list, new Comparator&lt;String&gt;(){<br/>
  @Override<br/>
  public int compare(String o1, String o2) {<br/>
      return o1.compareTo(o2);<br/>
  }<br/>
});<br/>
// lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt; {<br/>
          return o2.compareTo(o1);<br/>
});<br/>
// 简洁lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt;  o2.compareTo(o1));<br/>
// 更简洁lambda<br/>
Collections.sort(list, (o1, o2) -&gt;  o2.compareTo(o1));<br/>
// 也可以这样写<br/>
Collections.sort(list, Comparator.comparing(String::toString));
</code></pre></li>
<li><p><strong>函数式接口</strong></p>
<p>一个函数式接口有且只能有一个抽象方法申明，其中该注意的是 @FunctionalInterface 注解，此时如果在接口中定义了第二个抽象方法，编译器将会抛出异常。当然如果不加该注解也不是不行，如果接口中有多个抽象方法，而你又使用了lambda表达式，则在调用处会抛出异常。</p>
<pre><code class="language-java">@FunctionalInterface
public interface Formula&lt;F,T&gt;{<br/>
  T convert(F var1);<br/>
}<br/>
Formula&lt;String,Integer&gt; function = (var1 -&gt; Integer.valueOf(var1));<br/>
Integer var2 = function.convert(&quot;1000&quot;); 
</code></pre></li>
<li><p><strong>方法和构造函数引用</strong></p>
<p>方法引用的标准语法是 <code>类名:方法名</code></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用静态方法</td>
<td>targetClass :: staticMethodName</td>
</tr>
<tr>
<td>引用某个对象的实例方法</td>
<td>targetClass :: instanceMethodName</td>
</tr>
<tr>
<td>引用某个类型的任意对象的实例方法</td>
<td>targetType :: methodName</td>
</tr>
<tr>
<td>引用构造方法</td>
<td>className :: new</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>引用静态方法</strong></li>
</ol>
<pre><code class="language-java">Formula&lt;String,Integer&gt; function = (Integer::valueOf);
Integer var2 = function.convert(&quot;1000&quot;);
</code></pre>
<ol>
<li><strong>引用某个类型的任意对象的实例方法</strong></li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
   String[] array = {&quot;贱明&quot;, &quot;学友&quot;};<br/>
   Arrays.sort(array, String::compareTo);<br/>
}
</code></pre>
<ol>
<li><strong>引用构造方法</strong></li>
</ol>
<pre><code class="language-java">// 定义工厂
interface PersonFactory&lt;P extends Person&gt;{<br/>
    P create(String name);<br/>
}<br/>
// Person类的构造方法<br/>
public Person(String name) {<br/>
    this.name = name;<br/>
}<br/>
// 创建<br/>
PersonFactory&lt;Person&gt; factory = Person::new;<br/>
factory.create(&quot;贱明&quot;);
</code></pre></li>
<li><p><strong>Lambda的范围</strong></p>
<p>lambda可以访问局部对应的外部区域的局部final变量，以及成员变量和静态变量。</p>
<ol>
<li><p><strong>访问成员变量</strong></p>
<pre><code class="language-java">public void doSomething(){
 final String p1 = &quot;贱明&quot;;<br/>
 final String p2 = &quot;学友&quot;;<br/>
 Formula function = (person1, person2) -&gt; p1.compareTo(p2);<br/>
}
</code></pre>
<p>与java8以下版本不同的是，p1 p2你可以不修饰成final 也不会报错，但是如果你想修改他们，编译器则会告诉你这是不被允许的。</p></li>
<li><p><strong>访问成员变量和静态变量</strong></p>
<pre><code class="language-java">public void doSomething(){;
Formula function = (person1, person2) -&gt;{<br/>
    dehua = &quot;贱明&quot;;<br/>
    xueyou=&quot;学友&quot;;<br/>
    return dehua.compareTo(xueyou);<br/>
};<br/>
}
</code></pre></li>
</ol></li>
<li><p><strong>内置函数式接口</strong></p>
<p>​     java8 api中提供了很多内置函数式接口，而且有些接口其实在Google Guava中已经实现了，很大程  度的降低了程序员的工作负担。</p>
<ol>
<li><p><strong>Predicates</strong><br/>
Predicate是一个布尔类型的函数，该函数只有一个输入参数，他包含了多种默认实现。</p>
<pre><code class="language-java">public static void main(String[] args) {
Predicate&lt;String&gt; predicate = (s) -&gt; s.contains(&quot;贱明&quot;);<br/>
String var1 = &quot;牛贱明&quot;;<br/>
predicate.test(var1);              // true<br/>
predicate.negate().test(var1);     // false<br/>
Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;<br/>
Predicate&lt;Boolean&gt; isNull = Objects::isNull;<br/>
Predicate&lt;String&gt; isEmpty = String::isEmpty;<br/>
Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();<br/>
isNotEmpty.and(isEmpty).test(var1);<br/>
}
</code></pre></li>
<li><p><strong>Functions</strong></p>
<p>Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起</p>
<pre><code class="language-java">public static void main(String[] args) {
Function&lt;String, Integer&gt; toInteger = Integer::valueOf;<br/>
Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);<br/>
System.out.println(toInteger.apply(&quot;123&quot;));<br/>
System.out.println(backToString.apply(&quot;123&quot;));<br/>
}
</code></pre></li>
<li><p><strong>Suppliers</strong></p>
<p>Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。</p>
<pre><code class="language-java">Supplier&lt;Person&gt; personSupplier = Person::new;
Person p = personSupplier.get();   // new Person
</code></pre></li>
<li><p><strong>Consumers</strong></p>
<p>Consumer代表了在一个输入参数上需要进行的操作。</p>
<pre><code class="language-java">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.getName());
greeter.accept(new Person(&quot;贱明&quot;));
</code></pre></li>
<li><p><strong>Comparators</strong></p>
<p>Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。</p>
<pre><code class="language-java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.getName().compareTo(p2.getName());
Person p1 = new Person(&quot;贱明&quot;);<br/>
Person p2 = new Person(&quot;学友&quot;);<br/>
System.out.println(comparator.compare(p1, p2));             // &gt; 1105<br/>
System.out.println(comparator.reversed().compare(p1, p2));  // &lt; -1105
</code></pre></li>
<li><p><strong>Optionals</strong></p>
<p>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerException产生。<br/>
Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional。</p>
<pre><code class="language-java">Optional&lt;String&gt; optional = Optional.of(&quot;贱明&quot;);
System.out.println(optional.isPresent()); // true      <br/>
System.out.println(optional.get()); // 贱明   <br/>
System.out.println(optional.orElse(&quot;学友&quot;)); // 贱明    <br/>
optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); 
</code></pre></li>
</ol></li>
</ul>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[h5仿微信聊天(高仿版)、微信聊天表情|对话框|编辑器]]></title>
    <link href="https://books.sangkf.cn/15508991872164.html"/>
    <updated>2019-02-23T13:19:47+08:00</updated>
    <id>https://books.sangkf.cn/15508991872164.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>转载 <a href="https://www.cnblogs.com/xiaoyan2017/p/8912054.html">https://www.cnblogs.com/xiaoyan2017/p/8912054.html</a></p>
</blockquote>

<p>之前做过一版h5微信聊天移动端，这段时间闲来无事就整理了下之前项目，又重新在原先的那版基础上升级了下，如是就有了现在的h5仿微信聊天高仿版，新增了微聊、通讯录、探索、我四个模块 左右触摸滑屏切换，聊天页面优化了多图预览、视频播放，长按菜单UI，聊天底部编辑器重新优化整理(新增多表情)，弹窗则用到了自己开发的wcPop.js，具体看项目效果图吧！<br/>
<span id="more"></span><!-- more --></p>

<pre><code class="language-markup">&lt;!-- //微聊底部功能面板 --&gt;
&lt;div class=&quot;wc__footTool-panel&quot;&gt;
    &lt;!-- 输入框模块 --&gt;
    &lt;div class=&quot;wc__editor-panel wc__borT flexbox&quot;&gt;
        &lt;div class=&quot;wrap-editor flex1&quot;&gt;&lt;div class=&quot;editor J__wcEditor&quot; contenteditable=&quot;true&quot;&gt;&lt;/div&gt;&lt;/div&gt;
        &lt;i class=&quot;btn btn-emotion&quot;&gt;&lt;/i&gt;
        &lt;i class=&quot;btn btn-choose&quot;&gt;&lt;/i&gt;
        &lt;button class=&quot;btn-submit J__wchatSubmit&quot;&gt;发送&lt;/button&gt;
    &lt;/div&gt;

    &lt;!-- 表情、选择模块 --&gt;
    &lt;div class=&quot;wc__choose-panel wc__borT&quot; style=&quot;display: none;&quot;&gt;
        &lt;!-- 表情区域 --&gt;
        &lt;div class=&quot;wrap-emotion&quot; style=&quot;display: none;&quot;&gt;
            &lt;div class=&quot;emotion__cells flexbox flex__direction-column&quot;&gt;
                &lt;div class=&quot;emotion__cells-swiper flex1&quot; id=&quot;J__swiperEmotion&quot;&gt;
                    &lt;div class=&quot;swiper-container&quot;&gt;
                        &lt;div class=&quot;swiper-wrapper&quot;&gt;&lt;/div&gt;
                        &lt;div class=&quot;pagination-emotion&quot;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;emotion__cells-footer&quot; id=&quot;J__emotionFootTab&quot;&gt;
                    &lt;ul class=&quot;clearfix&quot;&gt;
                        &lt;li class=&quot;swiperTmpl cur&quot; tmpl=&quot;swiper__tmpl-emotion01&quot;&gt;&lt;img src=&quot;img/emotion/face01/face-lbl.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion02&quot;&gt;&lt;img src=&quot;img/emotion/face02/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion03&quot;&gt;&lt;img src=&quot;img/emotion/face03/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion04&quot;&gt;&lt;img src=&quot;img/emotion/face04/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion05&quot;&gt;&lt;img src=&quot;img/emotion/face05/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion06&quot;&gt;&lt;img src=&quot;img/emotion/face06/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmplSet&quot;&gt;&lt;img src=&quot;img/wchat/icon__emotion-set.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 选择区域 --&gt;
        &lt;div class=&quot;wrap-choose&quot; style=&quot;display: none;&quot;&gt;
            &lt;div class=&quot;choose__cells&quot;&gt;
                &lt;ul class=&quot;clearfix&quot;&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatZp&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-zp.png&quot; /&gt;&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; /&gt;&lt;/span&gt;&lt;em&gt;照片&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatSp&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-sp.png&quot; /&gt;&lt;input type=&quot;file&quot; accept=&quot;video/*&quot; /&gt;&lt;/span&gt;&lt;em&gt;视频&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatHb&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-hb.png&quot; /&gt;&lt;/span&gt;&lt;em&gt;红包&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatSc&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-sc.png&quot; /&gt;&lt;/span&gt;&lt;em&gt;我的收藏&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatWj&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-wj.png&quot; /&gt;&lt;/span&gt;&lt;em&gt;文件&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;wc__choosePanel-tmpl&quot;&gt;
    &lt;!-- //红包模板.begin --&gt;
    &lt;div id=&quot;J__popupTmpl-Hongbao&quot; style=&quot;display:none;&quot;&gt;
        &lt;div class=&quot;wc__popupTmpl tmpl-hongbao&quot;&gt;
            &lt;i class=&quot;wc-xclose&quot;&gt;&lt;/i&gt;
            &lt;ul class=&quot;clearfix&quot;&gt;
                &lt;li class=&quot;item flexbox&quot;&gt;
                    &lt;label class=&quot;txt&quot;&gt;总金额&lt;/label&gt;&lt;input class=&quot;ipt-txt flex1&quot; type=&quot;tel&quot; name=&quot;hbAmount&quot; placeholder=&quot;0.00&quot; /&gt;&lt;em class=&quot;unit&quot;&gt;元&lt;/em&gt;
                &lt;/li&gt;
                &lt;li class=&quot;item flexbox&quot;&gt;
                    &lt;label class=&quot;txt&quot;&gt;红包个数&lt;/label&gt;&lt;input class=&quot;ipt-txt flex1&quot; type=&quot;tel&quot; name=&quot;hbNum&quot; placeholder=&quot;填写个数&quot; /&gt;&lt;em class=&quot;unit&quot;&gt;个&lt;/em&gt;
                &lt;/li&gt;
                &lt;li class=&quot;tips&quot;&gt;在线人数共&lt;em class=&quot;memNum&quot;&gt;186&lt;/em&gt;人&lt;/li&gt;
                &lt;li class=&quot;item item-area&quot;&gt;
                    &lt;textarea class=&quot;describe&quot; name=&quot;content&quot; placeholder=&quot;恭喜发财，大吉大利&quot;&gt;&lt;/textarea&gt;
                &lt;/li&gt;
                &lt;li class=&quot;amountTotal&quot;&gt;￥&lt;em class=&quot;num&quot;&gt;0.00&lt;/em&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- //红包模板.end --&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-javascript">// ...长按弹出菜单
$(&quot;#J__chatMsgList&quot;).on(&quot;longTap&quot;, &quot;li .msg&quot;, function(e){
    var that = $(this), menuTpl, menuNode = $(&quot;&lt;div class=&#39;wc__chatTapMenu animated anim-fadeIn&#39;&gt;&lt;/div&gt;&quot;);
    that.addClass(&quot;taped&quot;);
    that.parents(&quot;li&quot;).siblings().find(&quot;.msg&quot;).removeClass(&quot;taped&quot;);
    var isRevoke = that.parents(&quot;li&quot;).hasClass(&quot;me&quot;);
    var _revoke = isRevoke ? &quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i4&#39;&gt;&lt;/i&gt;撤回&lt;/a&gt;&quot; : &quot;&quot;;
    
    if(that.hasClass(&quot;picture&quot;)){
        console.log(&quot;图片长按&quot;);
        menuTpl = &quot;&lt;div class=&#39;menu menu-picture&#39;&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i1&#39;&gt;&lt;/i&gt;复制&lt;/a&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i2&#39;&gt;&lt;/i&gt;收藏&lt;/a&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i3&#39;&gt;&lt;/i&gt;另存为&lt;/a&gt;&quot;+ _revoke +&quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i5&#39;&gt;&lt;/i&gt;删除&lt;/a&gt;&lt;/div&gt;&quot;;
    }else if(that.hasClass(&quot;video&quot;)){
        console.log(&quot;视频长按&quot;);
        menuTpl = &quot;&lt;div class=&#39;menu menu-video&#39;&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i3&#39;&gt;&lt;/i&gt;另存为&lt;/a&gt;&quot; + _revoke +&quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i5&#39;&gt;&lt;/i&gt;删除&lt;/a&gt;&lt;/div&gt;&quot;;
    }else{
        console.log(&quot;文字长按&quot;);
        menuTpl = &quot;&lt;div class=&#39;menu menu-text&#39;&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i1&#39;&gt;&lt;/i&gt;复制&lt;/a&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i2&#39;&gt;&lt;/i&gt;收藏&lt;/a&gt;&quot; + _revoke +&quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i5&#39;&gt;&lt;/i&gt;删除&lt;/a&gt;&lt;/div&gt;&quot;;
    }

    if(!$(&quot;.wc__chatTapMenu&quot;).length){
        $(&quot;.wc__chatMsg-panel&quot;).append(menuNode.html(menuTpl));
        autoPos();
    }else{
        $(&quot;.wc__chatTapMenu&quot;).hide().html(menuTpl).fadeIn(250);
        autoPos();
    }

    function autoPos(){
        console.log(that.position().top)
        var _other = that.parents(&quot;li&quot;).hasClass(&quot;others&quot;);
        $(&quot;.wc__chatTapMenu&quot;).css({
            position: &quot;absolute&quot;,
            left: that.position().left + parseInt(that.css(&quot;marginLeft&quot;)) + (_other ? 0 : that.outerWidth() - $(&quot;.wc__chatTapMenu&quot;).outerWidth()),
            top: that.position().top - $(&quot;.wc__chatTapMenu&quot;).outerHeight() - 8
        });
    }
});
</code></pre>

<p><img src="media/15508991872164/15508994793999.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><img src="media/15508991872164/15508994870198.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><img src="media/15508991872164/15508994947946.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995011000.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995078981.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995144669.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995204276.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995255771.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/><br/>
<img src="media/15508991872164/15508995347731.jpg" alt="" class="mw_img_left" style="width:200px;display: block; float: left; margin: 0px 8px 8px 0px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[欢迎使用 MWeb]]></title>
    <link href="https://books.sangkf.cn/15474356181402.html"/>
    <updated>2019-01-14T11:13:38+08:00</updated>
    <id>https://books.sangkf.cn/15474356181402.html</id>
    <content type="html"><![CDATA[
<p>MWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件，目前已支持 Mac，iPad 和 iPhone。MWeb 有以下特色：<br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_0">软件本身：</h2>

<ul>
<li>使用原生的 macOS 技术打造，追求与系统的完美结合。</li>
<li>原则上，首先是追求界面简洁和高性能，然后才是强大易用，功能全面。</li>
</ul>

<h2 id="toc_1">Markdown 语法：</h2>

<ul>
<li>使用 Github Flavored Markdown 语法，简称 GFM 语法。</li>
<li>支持表格、TOC、LaTeX、代码块、任务列表、脚注等。</li>
<li>画图库支持 mermaid, viz, echarts, plantuml, sequence, flow。</li>
</ul>

<h2 id="toc_2">Markdown 辅助：</h2>

<ul>
<li>支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。</li>
<li>在兼容 Markdown 语法的情况下支持设置图片宽度。</li>
<li>好用的表格插入和 LaTeX 书写辅助。</li>
</ul>

<h2 id="toc_3">Markdown 输出：</h2>

<ul>
<li>支持导出为图片、HTML、Epub、PDF、RTF、Docx。</li>
<li>支持发布到 Wordrpess、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记（Evernote）、Blogger、Medium、Tumblr。</li>
<li>图片上传服务（图床）支持 Google Photos、Imgur、七牛云、又拍云和自定义的图床服务。</li>
</ul>

<h2 id="toc_4">Markdown 笔记：</h2>

<ul>
<li>强大的文档库支持分类树和标签管理文档，文档可归类于多个分类，可以把分类整个导出为 Epub、PDF 和生成静态网站。非常合适用于笔记、个人知识收集、管理和输出。</li>
<li>快速笔记：随意增加笔记及图片等素材，支持以天为单位把增加的素材组合在一个文档内，方便整理及记录历史收集情况。</li>
<li>快速搜索：目前已支持全局快捷键调出搜索。</li>
</ul>

<h2 id="toc_5">外部 Markdown 文档：</h2>

<ul>
<li>外部 Markdown 文档使用外部模式管理。外部模式使用目录树的方式编辑和管理你的 markdown 文档，还能很好的支持 gitbook、JekyII、hexo 等等编辑和图片插入。</li>
</ul>

<h2 id="toc_6">MWeb 文档：</h2>

<p>如果要更详细了解 MWeb，建议你一定要去看一下官网的帮助文档，网址为：<a href="https://zh.mweb.im/help.html">https://zh.mweb.im/help.html</a>。我们建议在使用文档库之前，一定要阅读一下  <a href="https://zh.mweb.im/mweb-library.html">MWeb 文档库详细介绍</a> 这篇文章，以便更好的使用文档库。</p>

<h2 id="toc_7">帮助我们改进 MWeb</h2>

<p>如果你喜欢 MWeb，想让它变得更好，你可以：</p>

<ol>
<li>推荐 MWeb，让更多的人知道。</li>
<li>给我们发反馈和建议：<a href="mailto:coderforart+2333@gmail.com">coderforart+2333@gmail.com</a></li>
<li>在 Mac App Store 上评价 （如果是在 MAS 上购买的话）。</li>
</ol>

]]></content>
  </entry>
  
</feed>
