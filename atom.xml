<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[见课就上的小婊砸]]></title>
  <link href="https://books.sangkf.cn/atom.xml" rel="self"/>
  <link href="https://books.sangkf.cn/"/>
  <updated>2019-05-04T19:34:19+08:00</updated>
  <id>https://books.sangkf.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Java资源大全中文版]]></title>
    <link href="https://books.sangkf.cn/15569696449715.html"/>
    <updated>2019-05-04T19:34:04+08:00</updated>
    <id>https://books.sangkf.cn/15569696449715.html</id>
    <content type="html"><![CDATA[
<p>我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。<a href="https://github.com/akullpp/awesome-java">awesome-java</a> 就是 akullpp 发起维护的 Java 资源列表，内容包括：构建工具、数据库、框架、模板、安全、代码分析、日志、第三方库、书籍、Java 站点等等。伯乐在线已经把 awesome-java 资源列表翻成中文后发布于 <a href="http://www.importnew.com/14429.html">ImportNew</a>。</p>

<p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p>

<hr/>

<h3 id="toc_0">我们要做什么？</h3>

<ul>
<li>基于 awesome-java 资源列表，我们将对各个资源项进行编译整理。</li>
<li><p>整理后的内容，将收录在<a href="http://hao.jobbole.com/">伯乐在线资源频道</a>。可参考已整理的内容：</p>
<ul>
<li>《<a href="http://hao.jobbole.com/owner/">OWNER：Java配置文件解决方案</a>》</li>
<li>《<a href="http://hao.jobbole.com/spring-boot/">Spring Boot：简化Spring应用初始搭建以及开发过程</a>》</li>
<li>《<a href="http://hao.jobbole.com/sonarqube/">SonarQube：开源的代码质量管理工具</a>》</li>
</ul></li>
<li><ul>
<li>*</li>
</ul></li>
</ul>

<h3 id="toc_1">如何参与本项目？</h3>

<p>从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。</p>

<p>不过加入前，有几个小要求：</p>

<ul>
<li>英文还不错，能读懂英文并用自己的话复述；</li>
<li>在用 Java；</li>
</ul>

<p>如有兴趣，请加 QQ：50872495。加 Q 时请注明「Java大全」</p>

<hr/>

<h3 id="toc_2">如何为列表贡献新资源？</h3>

<p>欢迎大家为列表贡献高质量的新资源，提交PR时请参照以下要求：</p>

<ul>
<li>请确保推荐的资源自己使用过</li>
<li>提交PR时请注明推荐理由</li>
</ul>

<p>资源列表管理收到PR请求后，会定期（每周）在微博转发本周提交的PR列表，并在微博上面听取使用过这些资源的意见。确认通过后，会加入资源大全。</p>

<p>感谢您的贡献！</p>

<hr/>

<h3 id="toc_3">本项目的参与者</h3>

<ul>
<li><p>维护者：<a href="https://github.com/tangyouhua">tangyouhua</a></p></li>
<li><p>贡献者：<a href="https://github.com/tangyouhua">tangyouhua</a>、<a href="https://github.com/kingzone">kingzone</a>、<a href="https://github.com/llhua2329">llhua2329</a>、<a href="https://github.com/BadCoderChou">BadCoderChou</a>、<a href="http://www.jobbole.com/members/anankun/">anankun</a>、<a href="http://www.jobbole.com/members/jianghehe/">贺贺</a>、<a href="http://www.jobbole.com/members/petra/">大彭</a>、<a href="https://github.com/wing00yf/">superXiaoFan</a>、<a href="http://www.jobbole.com/members/3951356/">javayrf</a>、<a href="http://www.jobbole.com/members/John%20Smith/">John Smith</a>、<a href="http://www.jobbole.com/members/jaler/">Jaler</a>、<a href="http://www.jobbole.com/members/fdconan/">JM</a>、<a href="http://www.jobbole.com/members/zy124348985/">dreamkidd</a>、<a href="http://www.jobbole.com/members/cheenlie">cheenlie</a>、<a href="http://www.jobbole.com/members/zhangQian1991">zhangQian1991</a>、<a href="http://www.jobbole.com/members/wt726553124/">王涛</a>、<a href="http://www.jobbole.com/members/xun_cui">马</a>、<a href="http://www.jobbole.com/members/xuhf_1988/">vvkee</a>、<a href="http://www.jobbole.com/members/yangxy81118">凝枫</a>、<a href="https://github.com/luhaixun">haixunlu</a>、<a href="http://www.jobbole.com/members/milly/">milly</a>、<a href="http://www.jobbole.com/members/xuhf_1988/">Hodur</a>、<a href="http://www.jobbole.com/members/FakeHank">FakeHank</a>、<a href="http://www.jobbole.com/members/%E8%BF%9E%E4%B9%90/">连乐</a>、<a href="http://www.jobbole.com/members/UncleTim/">UncleTim</a>、<a href="http://www.jobbole.com/members/sunbiaobiao">sunbiaobiao</a>、<a href="http://www.jobbole.com/members/wx2702327993/">zhiguo</a>、<a href="http://www.jobbole.com/members/zhongjianno1/">光光头去打酱油</a>、<a href="http://www.jobbole.com/members/TonyAaron/">云中游</a>、<a href="http://www.jobbole.com/members/zemo/">Zemo</a>、<a href="https://github.com/sdcuike">sdcuike</a>、<a href="https://github.com/danielwii">danielwii</a>、<a href="http://www.jobbole.com/members/q1118024125/">oneDay</a>、<a href="https://github.com/dfghj44444">邢敏</a>、<a href="https://github.com/heikehuan">heikehuan</a>、<a href="https://github.com/fgcui1204">fgcui1204</a>、<a href="https://github.com/wenxueliu">wenxueliu</a>、<a href="https://github.com/node">Gentle Yang</a>、<a href="http://hao.jobbole.com/author/huangxiaofei/">黄小非</a>、<a href="http://www.jobbole.com/members/wtgn1m1/">wangtg</a>、<a href="http://www.jobbole.com/members/2937134480/">百焱</a>、<a href="http://www.jobbole.com/members/2480130384/">胡不GUI</a>、<a href="http://www.jobbole.com/members/mtHzm/">Another_mt</a>、<a href="http://www.jobbole.com/members/adonis/">Rainbow</a>、<a href="http://www.jobbole.com/members/menghuanqiqi">super<sup>糖</sup></a>、<a href="http://www.jobbole.com/members/huangyuliang/">黄余粮</a>、<a href="http://www.jobbole.com/members/sunbojian100/">Sun</a>、You</p></li>
</ul>

<p>注：名单不分排名，不定期补充更新</p>

<hr/>

<h3 id="toc_4">奖励计划</h3>

<p>虽然奖励可能并不是你加入的主要原因，但还是有必要提一下：</p>

<ul>
<li>整理超过 20 个资源后，可在伯乐在线上开通打赏；</li>
<li>每整理 20 个资源，有机会获得技术书籍或各种有意思的创意、极客产品；</li>
<li><p><a href="http://hao.jobbole.com/rewards/">奖励详情</a></p></li>
<li><ul>
<li>*<br/>
### 目录</li>
</ul></li>
<li><p><a href="#awesome-java-cn">Java资源大全中文版</a></p>
<ul>
<li><a href="#ancients">古董级工具</a></li>
<li><a href="#build">构建工具</a></li>
<li><a href="#bytecode-manipulation">字节码操作</a></li>
<li><a href="#cluster-management">集群管理</a></li>
<li><a href="#code-analysis">代码分析</a></li>
<li><a href="#compiler-compiler">编译器生成工具</a></li>
<li><a href="#configuration">外部配置工具</a></li>
<li><a href="#constraint-satisfaction-problem-solver">约束满足问题求解程序</a></li>
<li><a href="#continuous-integration">持续集成</a></li>
<li><a href="#csv">CSV解析</a></li>
<li><a href="#data-structures">数据结构</a></li>
<li><a href="#database">数据库</a></li>
<li><a href="#date-and-time">时间日期工具库</a></li>
<li><a href="#dependency-injection">依赖注入</a></li>
<li><a href="#development">开发流程增强工具</a></li>
<li><a href="#distributed-applications">分布式应用</a></li>
<li><a href="#distributed-databases">分布式数据库</a></li>
<li><a href="#distribution">发布</a></li>
<li><a href="#document-processing">文档处理工具</a></li>
<li><a href="#functional-programming">函数式编程</a></li>
<li><a href="#game-development">游戏开发</a></li>
<li><a href="#gui">GUI</a></li>
<li><a href="#high-performance">高性能计算</a></li>
<li><a href="#ide">IDE</a></li>
<li><a href="#imagery">图像处理</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#jvm-and-jdk">JVM与JDK</a></li>
<li><a href="#languages">基于JVM的语言</a></li>
<li><a href="#logging">日志</a></li>
<li><a href="#machine-learning">机器学习</a></li>
<li><a href="#messaging">消息传递</a></li>
<li><a href="#miscellaneous">杂项</a></li>
<li><a href="#monitoring">应用监控工具</a></li>
<li><a href="#native">原生开发库</a></li>
<li><a href="#natural-language-processing">自然语言处理</a></li>
<li><a href="#networking">网络</a></li>
<li><a href="#orm">ORM</a></li>
<li><a href="#pdf">PDF</a></li>
<li><a href="#performance-analysis">性能分析</a></li>
<li><a href="#reactive-libraries">响应式开发库</a></li>
<li><a href="#rest-frameworks">REST框架</a></li>
<li><a href="#science">科学计算与分析</a></li>
<li><a href="#search">搜索引擎</a></li>
<li><a href="#security">安全</a></li>
<li><a href="#serialization">序列化</a></li>
<li><a href="#server">应用服务器</a></li>
<li><a href="#template-engine">模板引擎</a></li>
<li><a href="#testing">测试</a></li>
<li><a href="#utility">通用工具库</a></li>
<li><a href="#web-crawling">网络爬虫</a></li>
<li><a href="#web-frameworks">Web框架</a></li>
<li><a href="#Business-Process-Management">业务流程管理套件</a></li>
</ul></li>
<li><p><a href="#resources">资源</a></p>
<ul>
<li><a href="#communities">社区</a></li>
<li><a href="#influential-books">有影响力的书</a></li>
<li><a href="#podcasts">播客</a></li>
<li><a href="#weibo-weixin">微博、微信公众号</a></li>
<li><a href="#twitter">Twitter</a></li>
<li><a href="#websites">知名网站</a></li>
</ul></li>
</ul>

<h2 id="ancients">古董级工具</h2>

<p><em>这些工具伴随着Java一起出现，在各自辉煌之后还在一直使用。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-ant/">Apache Ant</a>：基于XML的构建管理工具。<a href="http://ant.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/cglib/">cglib</a>：字节码生成库。<a href="https://github.com/cglib/cglib">官网</a></li>
<li><a href="http://hao.jobbole.com/glassfish/">GlassFish</a>：应用服务器，由Oracle赞助支持的Java EE参考实现。<a href="https://glassfish.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/hudson/">Hudson</a>：持续集成服务器，目前仍在活跃开发。<a href="http://hudson-ci.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/javaserver-faces/">JavaServer Faces</a>：Mojarra是JSF标准的一个开源实现，由Oracle开发。<a href="https://javaserverfaces.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/javaserver-pages/">JavaServer Pages</a>：支持自定义标签库的网站通用模板库。<a href="https://jsp.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/liquibase/">Liquibase</a>：与具体数据库独立的追踪、管理和应用数据库Scheme变化的工具。<a href="http://www.liquibase.org/">官网</a></li>
</ul>

<h3 id="build">构建工具</h3>

<p><em>构建及应用依赖关系处理工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/maven/">Apache Maven</a>：Maven是一款声明式构建及依赖管理工具，采用约定优于配置方式进行管理。相对Apache Ant更推荐使用Maven，前者采用了过程式管理，维护相对困难。<a href="http://maven.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/bazel/">Bazel</a>：来自Google的构建工具，可以快速、可靠地构建代码。<a href="http://bazel.io">官网</a></li>
<li><a href="http://hao.jobbole.com/gradle/">Gradle</a>：使用Groovy（非XML）进行增量构建，可以很好地与Maven依赖管理配合工作。<a href="http://gradle.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/buck/">Buck</a>：Facebook构建工具。<a href="https://buckbuild.com/">官网</a></li>
</ul>

<h3 id="bytecode-manipulation">字节码操作</h3>

<p><em>编程方式操作字节码的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/asm/">ASM</a>：通用底层字节码操作和分析开发库。<a href="http://asm.ow2.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/byte-buddy/">Byte Buddy</a>：使用流式API进一步简化字节码生成。<a href="http://bytebuddy.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/byteman/">Byteman</a>：在运行时通过DSL（规则）操作字节码进行测试和故障排除。<a href="http://byteman.jboss.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/javassist/">Javassist</a>：一个简化字节码编辑尝试。<a href="http://jboss-javassist.github.io/javassist">官网</a></li>
</ul>

<h3 id="cluster-management">集群管理</h3>

<p><em>在集群内动态管理应用程序的框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-aurora/">Apache Aurora</a>：Apache Aurora是一个Mesos框架，用于长时间运行服务和定时任务（cron job）。<a href="http://aurora.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/singularity/">Singularity</a>：Singularity是一个Mesos框架，方便部署和操作。它支持Web Service、后台运行、调度作业和一次性任务。<a href="http://getsingularity.com/">官网</a></li>
</ul>

<h3 id="code-analysis">代码分析</h3>

<p><em>测量代码指标和质量工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/checkstyle/">Checkstyle</a>：代码编写规范和标准静态分析工具。<a href="https://github.com/checkstyle/checkstyle">官网</a></li>
<li><a href="http://hao.jobbole.com/error-prone/">Error Prone</a>：将常见编程错误作为运行时错误报告。<a href="https://github.com/google/error-prone">官网</a></li>
<li>FindBugs：通过字节码静态分析查找隐藏bug。<a href="http://findbugs.sourceforge.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/jqassistant/">jQAssistant</a>：使用基于Neo4J查询语言进行代码静态分析。<a href="http://jqassistant.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/pmd/">PMD</a>：对源代码分析查找不良的编程习惯。<a href="https://github.com/pmd/pmd">官网</a></li>
<li><a href="http://hao.jobbole.com/sonarqube/">SonarQube</a>：通过插件集成其它分析组件，对过去一段时间内的数据进行统计。<a href="http://www.sonarqube.org/">官网</a></li>
</ul>

<h3 id="compiler-compiler">编译器生成工具</h3>

<p><em>用来创建解析器、解释器或编译器的框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/antlr/">ANTLR</a>：复杂的全功能自顶向下解析框架。<a href="http://www.antlr.org/">官网</a></li>
<li><a href="JavaCC%EF%BC%9AJava%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7">JavaCC</a>：JavaCC是更加专门的轻量级工具，易于上手且支持语法超前预测。<a href="https://javacc.java.net/">官网</a></li>
</ul>

<h3 id="configuration">外部配置工具</h3>

<p><em>支持外部配置的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/config/">config</a>：针对JVM语言的配置库。<a href="https://github.com/typesafehub/config">官网</a></li>
<li><a href="http://hao.jobbole.com/owner/">owner</a>：减少冗余配置属性。<a href="https://github.com/lviggiano/owner">官网</a></li>
</ul>

<h3 id="constraint-satisfaction-problem-solver">约束满足问题求解程序</h3>

<p><em>帮助解决约束满足问题的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/choco/">Choco</a>：可直接使用的约束满足问题求解程序，使用了约束规划技术。<a href="http://choco-solver.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jacop/">JaCoP</a>：为FlatZinc语言提供了一个接口，可以执行MiniZinc模型。<a href="https://github.com/radsz/jacop/">官网</a></li>
<li><a href="http://hao.jobbole.com/optaplanner/">OptaPlanner</a>：业务规划与资源调度优化求解程序。<a href="http://www.optaplanner.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/sat4j/">Sat4J</a>：逻辑代数与优化问题最先进的求解程序。<a href="http://www.sat4j.org/">官网</a></li>
</ul>

<h3 id="continuous-integration">持续集成</h3>

<ul>
<li><a href="http://hao.jobbole.com/bamboo/">Bamboo</a>：Atlassian解决方案，可以很好地集成Atlassian的其他产品。可以选择开源许可，也可以购买商业版。<a href="https://www.atlassian.com/software/bamboo">官网</a></li>
<li>CircleCI：提供托管服务，可以免费试用。<a href="https://circleci.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/codeship/">Codeship</a>：提供托管服务，提供有限的免费模式。<a href="https://codeship.com/features">官网</a></li>
<li><a href="hao.jobbole.com/fabric8/">fabric8</a>：容器集成平台。<a href="http://fabric8.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/go/">Go</a>：ThoughtWork开源解决方案。<a href="https://www.gocd.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/jenkins/">Jenkins</a>：支持基于服务器的部署服务。<a href="http://jenkins-ci.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/teamcity/">TeamCity</a>：JetBrain的持续集成解决方案，有免费版。<a href="http://www.jetbrains.com/teamcity/">官网</a></li>
<li><a href="http://hao.jobbole.com/travis/">Travis</a>：通常用作开源项目的托管服务。<a href="https://travis-ci.org">官网</a></li>
<li><a href="http://hao.jobbole.com/buildkite/">Buildkite</a>: 持续集成工具，用简单的脚本就能设置pipeline，而且能快速构建，可以免费试用。<a href="https://buildkite.com/">官网</a></li>
</ul>

<h3 id="csv">CSV解析</h3>

<p><em>简化CSV数据读写的框架与开发库</em></p>

<ul>
<li><a href="http://hao.jobbole.com/univocity-parsers/">uniVocity-parsers</a>：速度最快功能最全的CSV开发库之一，同时支持TSV与固定宽度记录的读写。<a href="https://github.com/uniVocity/univocity-parsers">官网</a></li>
</ul>

<h3 id="database">数据库</h3>

<p><em>简化数据库交互的相关工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-phoenix/">Apache Phoenix</a>：HBase针对低延时应用程序的高性能关系数据库层。<a href="http://phoenix.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/crate/">Crate</a>：实现了数据同步、分片、缩放、复制的分布式数据存储。除此之外还可以使用基于SQL的语法跨集群查询。<a href="https://crate.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/flyway/">Flyway</a>：简单的数据库迁移工具。<a href="http://flywaydb.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/h2/">H2</a>：小型SQL数据库，以可以作为内存数据库使用著称。<a href="http://h2database.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/hikaricp/">HikariCP</a>：高性能JDBC连接工具。<a href="https://github.com/brettwooldridge/HikariCP">官网</a></li>
<li><a href="http://hao.jobbole.com/jdbi/">JDBI</a>：便捷的JDBC抽象。<a href="http://jdbi.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jooq/">jOOQ</a>：为SQL schema生成typesafe代码。<a href="http://www.jooq.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/mapdb/">MapDB</a>：以磁盘或堆内存中并发集合为基础的嵌入式数据库引擎。<a href="http://www.mapdb.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/presto/">Presto</a>：针对大数据的分布式SQL查询引擎。<a href="https://github.com/facebook/presto">官网</a></li>
<li><a href="http://hao.jobbole.com/querydsl/">Querydsl</a>：Typesafe统一查询。<a href="http://www.querydsl.com/">官网</a></li>
</ul>

<h3 id="data-structures">数据结构</h3>

<ul>
<li><a href="http://hao.jobbole.com/apache-parquet/">Apache Parquet</a>：Google Dremel论文中发布的基于组装算法的列式（Columnar）存储格式。<a href="http://parquet.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/protobuf/">Protobuf</a>：Google数据交换格式。<a href="https://github.com/google/protobuf">官网</a></li>
<li><a href="http://hao.jobbole.com/sbe/">SBE</a>：简单二进制编码，是最快速的消息格式之一。<a href="https://github.com/real-logic/simple-binary-encoding">官网</a></li>
<li><a href="http://hao.jobbole.com/wire/">Wire</a>：整洁轻量级协议缓存。<a href="https://github.com/square/wire">官网</a></li>
</ul>

<h3 id="date-and-time">时间日期工具库</h3>

<p><em>处理时间和日期的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/joda-time/">Joda-Time</a>：在Java 8发布前，Joda-Time是实际使用的时间日期库标准。<a href="http://www.joda.org/joda-time/">官网</a></li>
<li><a href="http://hao.jobbole.com/time4j/">Time4J</a>：高级时间和日期库。<a href="https://github.com/MenoData/Time4J">官网</a></li>
<li><a href="http://hao.jobbole.com/ThreeTen/">ThreeTen</a>：JSR-310实现，为JDK提供更具特点的时间和日期API。<a href="http://www.threeten.org">官网</a></li>
</ul>

<h3 id="dependency-injection">依赖注入</h3>

<p><em>帮实现依赖翻转范式的开发库。</em> <a href="https://en.wikipedia.org/wiki/Inversion_of_control">官网</a></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-deltaspike/">Apache DeltaSpike</a>：CDI扩展框架。<a href="https://deltaspike.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/dagger2/">Dagger2</a>：编译时注入框架，不需要使用反射。<a href="http://google.github.io/dagger/">官网</a></li>
<li><a href="http://hao.jobbole.com/guice/">Guice</a>：可以匹敌Dagger的轻量级注入框架。<a href="https://github.com/google/guice">官网</a></li>
<li><a href="http://hao.jobbole.com/hk2/">HK2</a>：轻量级动态依赖注入框架。<a href="https://hk2.java.net">官网</a></li>
</ul>

<h3 id="development">开发流程增强工具</h3>

<p><em>从最基本的层面增强开发流程。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/adt4j/">ADT4J</a>：针对代数数据类型的JSR-269代码生成器。<a href="https://github.com/sviperll/adt4j">官网</a></li>
<li><a href="http://hao.jobbole.com/aspectj/">AspectJ</a>：面向切面编程（AOP）的无缝扩展。<a href="https://eclipse.org/aspectj/">官网</a></li>
<li><a href="http://hao.jobbole.com/auto/">Auto</a>：源代码生成器集合。<a href="https://github.com/google/auto">官网</a></li>
<li><a href="http://hao.jobbole.com/dcevm/">DCEVM</a>：通过修改JVM在运行时支持对已加载的类进行无限次重定义。<a href="http://dcevm.github.io/">官网</a></li>
<li>HotswapAgent：支持无限次重定义运行时类与资源。<a href="https://github.com/HotswapProjects/HotswapAgent">官网</a></li>
<li>Immutables：类似Scala的条件类。<a href="http://immutables.github.io/">官网</a></li>
<li>JHipster：基于Spring Boot与AngularJS应用程序的Yeoman源代码生成器。<a href="https://github.com/jhipster/generator-jhipster">官网</a></li>
<li><a href="http://hao.jobbole.com/jrebel/">JRebel</a>：无需重新部署，可以即时重新加载代码与配置的商业软件。<a href="http://zeroturnaround.com/software/jrebel/">官网</a></li>
<li>Lombok：减少冗余的代码生成器。<a href="https://projectlombok.org/">官网</a></li>
<li>Spring Loaded：类重载代理。<a href="https://github.com/spring-projects/spring-loaded">官网</a></li>
<li><a href="http://hao.jobbole.com/vert-x/">vert.x</a>：多语言事件驱动应用框架。<a href="http://vertx.io/">官网</a></li>
</ul>

<h3 id="distributed-applications">分布式应用</h3>

<p><em>用来编写分布式容错应用的开发库和框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/akka/">Akka</a>：用来编写分布式容错并发事件驱动应用程序的工具和运行时。<a href="http://akka.io">官网</a></li>
<li><a href="http://hao.jobbole.com/storm/">Apache Storm</a>：实时计算系统。<a href="http://storm.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/zookeeper/">Apache ZooKeeper</a>：针对大型分布式系统的协调服务，支持分布式配置、同步和名称注册。<a href="http://zookeeper.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/Hazelcast/">Hazelcast</a>：高可扩展内存数据网格。<a href="http://hazelcast.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/hystrix/">Hystrix</a>：提供延迟和容错。<a href="https://github.com/Netflix/Hystrix">官网</a></li>
<li><a href="http://hao.jobbole.com/jgroups/">JGroups</a>：提供可靠的消息传递和集群创建的工具。<a href="http://www.jgroups.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/orbit/">Orbit</a>：支持虚拟角色（Actor），在传统角色的基础上增加了另外一层抽象。<a href="http://orbit.bioware.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/quasar/">Quasar</a>：为JVM提供轻量级线程和角色。<a href="http://www.paralleluniverse.co/quasar/">官网</a></li>
</ul>

<h3 id="distributed-databases">分布式数据库</h3>

<p><em>对应用程序而言，在分布式系统中的数据库看起来就像是只有一个数据源。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/cassandra/">Apache Cassandra</a>：列式数据库，可用性高且没有单点故障。<a href="http://cassandra.apache.org">官网</a></li>
<li><a href="http://hao.jobbole.com/hbase/">Apache HBase</a>：针对大数据的Hadoop数据库。<a href="http://hbase.apache.org">官网</a></li>
<li><a href="http://hao.jobbole.com/druid/">Druid</a>：实时和历史OLAP数据存储，在聚集查询和近似查询方面表现不俗。<a href="http://druid.io">官网</a></li>
<li><a href="http://hao.jobbole.com/infinispan/">Infinispan</a>：针对缓存的高并发键值对数据存储。<a href="http://infinispan.org/">官网</a></li>
</ul>

<h3 id="distribution">发布</h3>

<p><em>以本机格式发布应用程序的工具。</em></p>

<ul>
<li>Bintray：发布二进制文件版本控制工具。可以于Maven或Gradle一起配合使用。提供开源免费版本和几种商业收费版本。<a href="https://bintray.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/central-repository/">Central Repository</a>：最大的二进制组件仓库，面向开源社区提供免费服务。Apache Maven默认使用Central <a href="http://search.maven.org/">官网</a>Repository，也可以在所有其他构建工具中使用。</li>
<li>IzPack：为跨平台部署建立创作工具（Authoring Tool）。<a href="http://izpack.org/">官网</a></li>
<li>JitPack：打包GitHub仓库的便捷工具。可根据需要构建Maven、Gradle项目，发布可立即使用的组件。<a href="https://jitpack.io/">官网</a></li>
<li>Launch4j：将JAR包装为轻量级本机Windows可执行程序。<a href="http://launch4j.sourceforge.net/">官网</a></li>
<li>Nexus：支持代理和缓存功能的二进制管理工具。<a href="http://www.sonatype.com/nexus">官网</a></li>
<li>packr：将JAR、资源和JVM打包成Windows、Linux和Mac OS X本地发布文件。<a href="https://github.com/libgdx/packr/">官网</a></li>
</ul>

<h3 id="document-processing">文档处理工具</h3>

<p><em>处理Office文档的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/poi/">Apache POI</a>：支持OOXML规范（XLSX、DOCX、PPTX）以及OLE2规范（XLS、DOC、PPT）。<a href="http://poi.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/documents4j/">documents4j</a>：使用第三方转换器进行文档格式转换，转成类似MS Word这样的格式。<a href="http://documents4j.com">官网</a></li>
<li><a href="http://hao.jobbole.com/jopendocument/">jOpenDocument</a>：处理OpenDocument格式（由Sun公司提出基于XML的文档格式）。<a href="http://www.jopendocument.org/">官网</a></li>
</ul>

<h3 id="functional-programming">函数式编程</h3>

<p><em>函数式编程支持库。</em></p>

<ul>
<li>Cyclops：支持一元（Monad）操作和流操作工具类、comprehension（List语法）、模式匹配、trampoline等特性。<a href="https://github.com/aol/cyclops">官网</a></li>
<li>Fugue：Guava的函数式编程扩展。<a href="https://bitbucket.org/atlassian/fugue">官网</a></li>
<li>Functional Java：实现了多种基础和高级编程抽象，用来辅助面向组合开发（composition-oriented development）。<a href="http://www.functionaljava.org">官网</a></li>
<li>Javaslang：一个函数式组件库，提供持久化数据类型和函数式控制结构。<a href="http://javaslang.com">官网</a></li>
<li>jOOλ：旨在填补Java 8 lambda差距的扩展，提供了众多缺失的类型和一组丰富的顺序流API。<a href="https://github.com/jOOQ/jOOL">官网</a></li>
</ul>

<h3 id="game-development">游戏开发</h3>

<p><em>游戏开发框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jmonkeyengine/">jMonkeyEngine</a>：现代3D游戏开发引擎。<a href="http://jmonkeyengine.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/libgdx/">libGDX</a>：全面的跨平台高级框架。<a href="https://libgdx.badlogicgames.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/lwjgl/">LWJGL</a>：对OpenGL/CL/AL等技术进行抽象的健壮框架。<a href="https://www.lwjgl.org/">官网</a></li>
</ul>

<h3 id="gui">GUI</h3>

<p><em>现代图形化用户界面开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/javafx/">JavaFX</a>：Swing的后继者。<a href="http://www.oracle.com/technetwork/java/javase/overview/javafx-overview-2158620.html">官网</a></li>
<li><a href="http://hao.jobbole.com/scene_builder/">Scene Builder</a>：开发JavaFX应用的可视化布局工具。<a href="http://docs.oracle.com/javase/8/scene-builder-2/get-started-tutorial/overview.htm#JSBGS164">官网</a></li>
</ul>

<h3 id="high-performance">高性能计算</h3>

<p><em>涵盖了从集合到特定开发库的高性能计算相关工具。</em></p>

<ul>
<li>Agrona：高性能应用中常见的数据结构和工具方法。<a href="https://github.com/real-logic/Agrona">官网</a></li>
<li>Disruptor：线程间消息传递开发库。<a href="http://lmax-exchange.github.io/disruptor/">官网</a></li>
<li>fastutil：快速紧凑的特定类型集合（Collection）。<a href="http://fastutil.di.unimi.it/">官网</a></li>
<li>GS Collections：受Smalltalk启发的集合框架。<a href="https://github.com/goldmansachs/gs-collections">官网</a></li>
<li><a href="http://hao.jobbole.com/hppc/">HPPC</a>：基础类型集合。<a href="http://labs.carrotsearch.com/hppc.html">官网</a></li>
<li>Javolution：实时和嵌入式系统的开发库。<a href="http://javolution.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jctools/">JCTools</a>：JDK中缺失的并发工具。<a href="https://github.com/JCTools/JCTools">官网</a></li>
<li><a href="http://hao.jobbole.com/koloboke/">Koloboke</a>：Hash set和hash map。<a href="https://github.com/OpenHFT/Koloboke">官网</a></li>
<li>Trove：基础类型集合。<a href="http://trove.starlight-systems.com/">官网</a></li>
<li>High-scale-lib:Cliff Click 个人开发的高性能并发库<a href="https://github.com/stephenc/high-scale-lib">官网</a></li>
</ul>

<h3 id="ide">IDE</h3>

<p><em>简化开发的集成开发环境。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/eclipse/">Eclipse</a>：老牌开源项目，支持多种插件和编程语言。<a href="http://www.eclipse.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/intellij-idea/">IntelliJ IDEA</a>：支持众多JVM语言，是安卓开发者好的选择。商业版主要针对企业客户。<a href="http://www.jetbrains.com/idea/">官网</a></li>
<li><a href="http://hao.jobbole.com/netbeans/">NetBeans</a>：为多种技术提供集成化支持，包括Java SE、Java EE、数据库访问、HTML5等。<a href="https://netbeans.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/scala-ide/">Scala IDE</a>：一款基于Eclipse开源平台打造的Scala集成开发环境。<a href="http://scala-ide.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/springsource-tool-suite/">SpringSource Tool Suite（STS）</a>:一款基于Eclipse开源平台打造的Spring应用开发环境。<a href="http://spring.io/tools/sts/">官网</a></li>
</ul>

<h3 id="imagery">图像处理</h3>

<p><em>创建、评价和操作图片的支持库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/imgscalr/">Imgscalr</a>：纯Java 2D实现，简单、高效、支持硬件加速的图像缩放开发库。<a href="https://github.com/thebuzzmedia/imgscalr">官网</a></li>
<li><a href="http://hao.jobbole.com/picasso/">Picasso</a>：安卓图片下载和图片缓存开发库。<a href="http://square.github.io/picasso/">官网</a></li>
<li><a href="http://hao.jobbole.com/thumbnailator/">Thumbnailator</a>：Thumbnailator是一个高质量Java缩略图开发库。<a href="https://github.com/coobird/thumbnailator">官网</a></li>
<li><a href="http://hao.jobbole.com/zxing/">ZXing</a>：支持多种格式的一维、二维条形码图片处理开发库。<a href="https://github.com/zxing/zxing">官网</a></li>
<li><a href="http://hao.jobbole.com/im4java/">im4java</a>: 基于ImageMagick或GraphicsMagick命令行的图片处理开发库，基本上ImageMagick能够支持的图片格式和处理方式都能够处理。<a href="http://im4java.sourceforge.net/">官网</a></li>
<li>Apache Batik：在Java应用中程序以SVG格式显示、生成及处理图像的工具集，包括SVG解析器、SVG生成器、SVG DOM等模块，可以集成使用也可以单独使用，还可以扩展自定义的SVG标签。<a href="http://xmlgraphics.apache.org/batik/">官网</a></li>
</ul>

<h3 id="json">JSON</h3>

<p><em>简化JSON处理的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/genson/">Genson</a>：强大且易于使用的Java到JSON转换开发库。<a href="http://owlike.github.io/genson">官网</a></li>
<li><a href="http://hao.jobbole.com/gson/">Gson</a>：谷歌官方推出的JSON处理库，支持在对象与JSON之间双向序列化，性能良好且可以实时调用。<a href="https://github.com/google/gson">官网</a></li>
<li><a href="http://hao.jobbole.com/jackson/">Jackson</a>：与GSON类似，在频繁使用时性能更佳。<a href="http://wiki.fasterxml.com/JacksonHome">官网</a></li>
<li><a href="http://hao.jobbole.com/logansquare/">LoganSquare</a>：基于Jackson流式API，提供对JSON解析和序列化。比GSON与Jackson组合方式效果更好。<a href="https://github.com/bluelinelabs/LoganSquare">官网</a></li>
<li><a href="http://hao.jobbole.com/fastjson/">Fastjson</a>：一个Java语言编写的高性能功能完善的JSON库。<a href="https://github.com/Alibaba/fastjson">官网</a></li>
<li>Kyro：快速、高效、自动化的Java对象序列化和克隆库。<a href="https://github.com/EsotericSoftware/kryo">官网</a></li>
</ul>

<h3 id="jvm-and-jdk">JVM与JDK</h3>

<p><em>目前的JVM和JDK实现。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jdk-9/">JDK 9</a>：JDK 9的早期访问版本。<a href="https://jdk9.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/openjdk/">OpenJDK</a>：JDK开源实现。<a href="http://openjdk.java.net/">官网</a></li>
</ul>

<h3 id="languages">基于JVM的语言</h3>

<p><em>除Java外，可以用来编写JVM应用程序的编程语言。</em></p>

<ul>
<li>Scala：融合了面向对象和函数式编程思想的静态类型编程语言。<a href="http://www.scala-lang.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/groovy/">Groovy</a>：类型可选（Optionally typed）的动态语言，支持静态类型和静态编译。目前是一个Apache孵化器项目。<a href="http://www.groovy-lang.org/">官网</a></li>
<li>Clojure：可看做现代版Lisp的动态类型语言。<a href="http://clojure.org/">官网</a></li>
<li>Ceylon：RedHat开发的面向对象静态类型编程语言。<a href="http://ceylon-lang.org/">官网</a></li>
<li>Kotlin：JetBrain针对JVM、安卓和浏览器提供的静态类型编程语言。<a href="http://kotlinlang.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/xtend/">Xtend</a>：一种静态编程语言，能够将其代码转换为简洁高效的Java代码，并基于JVM运行。<a href="http://www.eclipse.org/xtend/">官网</a></li>
</ul>

<h3 id="logging">日志</h3>

<p><em>记录应用程序行为日志的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/log4j2/">Apache Log4j 2</a>：使用强大的插件和配置架构进行完全重写。<a href="http://logging.apache.org/log4j/">官网</a></li>
<li><a href="http://hao.jobbole.com/kibana/">kibana</a>：分析及可视化日志文件。<a href="https://www.elastic.co/products/kibana">官网</a></li>
<li><a href="http://hao.jobbole.com/logback/">Logback</a>：强健的日期开发库，通过Groovy提供很多有趣的选项。<a href="http://logback.qos.ch/">官网</a></li>
<li><a href="http://hao.jobbole.com/logstash/">logstash</a>：日志文件管理工具。<a href="https://www.elastic.co/products/logstash">官网</a></li>
<li><a href="http://hao.jobbole.com/metrics/">Metrics</a>：通过JMX或HTTP发布参数，并且支持存储到数据库。<a href="https://github.com/dropwizard/metrics">官网</a></li>
<li><a href="http://hao.jobbole.com/slf4j/">SLF4J</a>：日志抽象层，需要与具体的实现配合使用。<a href="http://www.slf4j.org/">官网</a></li>
</ul>

<h3 id="machine-learning">机器学习</h3>

<p><em>提供具体统计算法的工具。其算法可从数据中学习。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-flink/">Apache Flink</a>：快速、可靠的大规模数据处理引擎。<a href="https://flink.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-hadoop/">Apache Hadoop</a>：在商用硬件集群上用来进行大规模数据存储的开源软件框架。<a href="http://hadoop.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-mahout/">Apache Mahout</a>：专注协同过滤、聚类和分类的可扩展算法。<a href="https://mahout.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-spark/">Apache Spark</a>：开源数据分析集群计算框架。<a href="http://spark.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/deepdive/">DeepDive</a>：从非结构化数据建立结构化信息并集成到已有数据库的工具。<a href="http://deepdive.stanford.edu">官网</a></li>
<li><a href="http://hao.jobbole.com/deeplearning4j/">Deeplearning4j</a>：分布式多线程深度学习开发库。<a href="http://deeplearning4j.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/h2o/">H2O</a>：用作大数据统计的分析引擎。<a href="http://h2o.ai/">官网</a></li>
<li><a href="http://hao.jobbole.com/weka/">Weka</a>：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。<a href="http://www.cs.waikato.ac.nz/ml/weka/">官网</a></li>
<li><a href="http://hao.jobbole.com/quickml/">QuickML</a>：高效机器学习库。<a href="http://quickml.org/">官网</a>、<a href="https://github.com/sanity/quickml">GitHub</a></li>
</ul>

<h3 id="messaging">消息传递</h3>

<p><em>在客户端之间进行消息传递，确保协议独立性的工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/aeron/">Aeron</a>：高效可扩展的单播、多播消息传递工具。<a href="https://github.com/real-logic/Aeron">官网</a></li>
<li><a href="http://hao.jobbole.com/activemq/">Apache ActiveMQ</a>：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。<a href="http://activemq.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-camel/">Apache Camel</a>：通过企业级整合模式（Enterprise Integration Pattern EIP）将不同的消息传输API整合在一起。<a href="http://camel.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/kafka/">Apache Kafka</a>：高吞吐量分布式消息系统。<a href="http://kafka.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/hermes/">Hermes</a>：快速、可靠的消息代理（Broker），基于Kafka构建。<a href="http://hermes.allegro.tech">官网</a></li>
<li>JBoss HornetQ：清晰、准确、模块化，可以方便嵌入的消息工具。<a href="http://hornetq.jboss.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jeromq/">JeroMQ</a>：ZeroMQ的纯Java实现。<a href="https://github.com/zeromq/jeromq">官网</a></li>
<li><a href="http://hao.jobbole.com/smack/">Smack</a>：跨平台XMPP客户端函数库。<a href="https://github.com/igniterealtime/Smack/">官网</a></li>
<li>Openfire：是开源的、基于XMPP、采用Java编程语言开发的实时协作服务器。 Openfire安装和使用都非常简单，并可利用Web界面进行管理。 <a href="http://www.igniterealtime.org/projects/openfire/index.jsp">官网</a> <a href="https://github.com/igniterealtime/Openfire">GitHub</a></li>
<li>Spark：是一个开源，跨平台IM客户端。它的特性支持集组聊天，电话集成和强大安全性能。如果企业内部部署IM使用Openfire+Spark是最佳的组合。 <a href="http://www.igniterealtime.org/projects/spark/index.jsp">官网</a> <a href="https://github.com/igniterealtime/Spark">GitHub</a></li>
<li>Tigase： 是一个轻量级的可伸缩的 Jabber/XMPP 服务器。无需其他第三方库支持，可以处理非常高的复杂和大量的用户数，可以根据需要进行水平扩展。 <a href="http://www.tigase.net">官网</a></li>
</ul>

<h3 id="miscellaneous">杂项</h3>

<p><em>未分类其它资源。</em></p>

<ul>
<li>Design Patterns：实现并解释了最常见的设计模式。<a href="https://github.com/iluwatar/java-design-patterns">官网</a></li>
<li>Jimfs：内存文件系统。<a href="https://github.com/google/jimfs">官网</a></li>
<li>Lanterna：类似curses的简单console文本GUI函数库。<a href="https://code.google.com/p/lanterna/">官网</a></li>
<li>LightAdmin：可插入式CRUD UI函数库，可用来快速应用开发。<a href="http://lightadmin.org/">官网</a></li>
<li>OpenRefine：用来处理混乱数据的工具，包括清理、转换、使用Web Service进行扩展并将其关联到数据库。<a href="http://openrefine.org/">官网</a></li>
<li>RoboVM：Java编写原生iOS应用。<a href="https://robovm.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/quartz/">Quartz</a>：强大的任务调度库.<a href="http://www.quartz-scheduler.org/">官网</a></li>
</ul>

<h3 id="monitoring">应用监控工具</h3>

<p><em>监控生产环境中应用程序的工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/appdynamics/">AppDynamics</a>：性能监测商业工具。<a href="http://www.appdynamics.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/javamelody/">JavaMelody</a>：性能监测和分析工具。<a href="https://github.com/javamelody/javamelody">官网</a></li>
<li><a href="http://hao.jobbole.com/Kamon/">Kamon</a>：Kamon用来监测在JVM上运行的应用程序。<a href="http://www.kamon.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/new-relic/">New Relic</a>：性能监测商业工具。<a href="http://newrelic.com/">官网</a></li>
<li>SPM：支持对JVM应用程序进行分布式事务追踪的性能监测商业工具。<a href="https://sematext.com/spm/">官网</a></li>
<li><a href="http://hao.jobbole.com/overops_takipi/">OverOps(Takipi)</a>：产品运行时错误监测及调试商业工具。<a href="https://www.takipi.com/">官网</a></li>
</ul>

<h3 id="native">原生开发库</h3>

<p><em>用来进行特定平台开发的原生开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jna/">JNA</a>：不使用JNI就可以使用原生开发库。此外，还为常见系统函数提供了接口。<a href="https://github.com/java-native-access/jna">官网</a></li>
</ul>

<h3 id="natural-language-processing">自然语言处理</h3>

<p><em>用来专门处理文本的函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-opennlp/">Apache OpenNLP</a>：处理类似分词等常见任务的工具。<a href="https://opennlp.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/stanford_corenlp/">CoreNLP</a>：斯坦佛CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。<a href="http://nlp.stanford.edu/software/coenlp.shtml">官网</a></li>
<li><a href="http://hao.jobbole.com/lingpipe/">LingPipe</a>：一组可以处理各种任务的工具集，支持POS标签、情感分析等。<a href="http://alias-i.com/lingpipe/">官网</a></li>
<li><a href="http://hao.jobbole.com/mallet/">Mallet</a>：统计学自然语言处理、文档分类、聚类、主题建模等。<a href="http://mallet.cs.umass.edu/">官网</a></li>
</ul>

<h3 id="networking">网络</h3>

<p><em>网络编程函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/async-http-client/">Async Http Client</a>：异步HTTP和WebSocket客户端函数库。<a href="https://github.com/AsyncHttpClient/async-http-client">官网</a></li>
<li><a href="http://hao.jobbole.com/grizzly/">Grizzly</a>：NIO框架，在Glassfish中作为网络层使用。<a href="https://grizzly.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/netty/">Netty</a>：构建高性能网络应用程序开发框架。<a href="http://netty.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/okhttp/">OkHttp</a>：一个Android和Java应用的HTTP+SPDY客户端。<a href="http://square.github.io/okhttp/">官网</a></li>
<li>Undertow：基于NIO实现了阻塞和非阻塞API的Web服务器，在WildFly中作为网络层使用。<a href="http://undertow.io/">官网</a></li>
</ul>

<h3 id="orm">ORM</h3>

<p><em>处理对象持久化的API。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/ebean/">Ebean</a>：支持快速数据访问和编码的ORM框架。<a href="http://ebean-orm.github.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/eclipselink/">EclipseLink</a>：支持许多持久化标准，JPA、JAXB、JCA和SDO。<a href="https://www.eclipse.org/eclipselink/">官网</a></li>
<li><a href="http://hao.jobbole.com/hibernate/">Hibernate</a>：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。<a href="http://hibernate.org/orm/">官网</a></li>
<li><a href="http://hao.jobbole.com/mybatis/">MyBatis</a>：带有存储过程或者SQL语句的耦合对象（Couples object）。<a href="http://mybatis.github.io/mybatis-3/">官网</a></li>
<li><a href="http://hao.jobbole.com/ormlite/">OrmLite</a>：轻量级开发包，免除了其它ORM产品中的复杂性和开销。<a href="http://ormlite.com/">官网</a></li>
<li>Nutz：另一个SSH。<a href="http://nutzam.com/">官网</a>，<a href="https://github.com/nutzam/nutz">Github</a>，<a href="https://nutz.cn/">论坛</a></li>
<li>JFinal：JAVA WEB + ORM框架。<a href="http://www.jfinal.com">官网</a>，<a href="https://github.com/jfinal/jfinal">Github</a></li>
<li><a href="http://openjpa.apache.org/">Apache OpenJPA</a>: 实现了 EJB 3.0 中的 JPA 标准,为开发者提供功能强大、使用简单的持久化数据管理框架。 <a href="http://openjpa.apache.org/">官网</a></li>
</ul>

<h3 id="pdf">PDF</h3>

<p><em>用来帮助创建PDF文件的资源。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache_fop/">Apache FOP</a>：从XSL-FO创建PDF。<a href="http://xmlgraphics.apache.org/fop/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-pdfbox/">Apache PDFBox</a>：用来创建和操作PDF的工具集。<a href="http://pdfbox.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/dynamicreports/">DynamicReports</a>：JasperReports的精简版。<a href="http://dynamicreports.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/flyingsaucer/">flyingsaucer</a>：XML/XHTML和CSS 2.1渲染器。<a href="https://github.com/flyingsaucerproject/flyingsaucer">官网</a></li>
<li><a href="http://hao.jobbole.com/itext/">iText</a>：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。<a href="http://itextpdf.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/jasperreports/">JasperReports</a>：一个复杂的报表引擎。<a href="http://community.jaspersoft.com/project/jasperreports-library">官网</a></li>
</ul>

<h3 id="performance-analysis">性能分析</h3>

<p><em>性能分析、性能剖析及基准测试工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jhiccup/">jHiccup</a>：提供平台中JVM暂停的日志和记录。<a href="https://github.com/giltene/jHiccup">官网</a></li>
<li><a href="http://hao.jobbole.com/jmh/">JMH</a>：JVM基准测试工具。<a href="http://openjdk.java.net/projects/code-tools/jmh/">官网</a></li>
<li><a href="http://hao.jobbole.com/jprofiler/">JProfiler</a>：商业分析器。<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">官网</a></li>
<li><a href="http://hao.jobbole.com/latencyutils/">LatencyUtils</a>：测量和报告延迟的工具。<a href="https://github.com/LatencyUtils/LatencyUtils">官网</a></li>
<li><a href="http://hao.jobbole.com/visualvm/">VisualVM</a>：对运行中的应用程序信息提供了可视化界面。<a href="http://visualvm.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/yourkit-java-profiler/">YourKit Java Profiler</a>：商业分析器。<a href="https://www.yourkit.com/features/">官网</a></li>
</ul>

<h3 id="reactive-libraries">响应式开发库</h3>

<p><em>用来开发响应式应用程序的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/reactive-streams/">Reactive Streams</a>：异步流处理标准，支持非阻塞式反向压力（backpressure）。<a href="https://github.com/reactive-streams/reactive-streams-jv/">官网</a></li>
<li><a href="http://hao.jobbole.com/reactor/">Reactor</a>：构建响应式快速数据（fast-data）应用程序的开发库。<a href="http://projectreactor.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/rxjava/">RxJava</a>：通过JVM可观察序列（observable sequence）构建异步和基于事件的程序。<a href="https://github.com/ReactiveX/RxJava">官网</a></li>
</ul>

<h3 id="rest-frameworks">REST框架</h3>

<p><em>用来创建RESTful 服务的框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/dropwizard/">Dropwizard</a>：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。<a href="https://dropwizard.github.io/drpwizard/">官网</a></li>
<li><a href="http://hao.jobbole.com/feign/">Feign</a>：受Retrofit、JAXRS-2.0和WebSocket启发的HTTP客户端连接器（binder）。<a href="https://github.com/Netflix/feign">官网</a></li>
<li>Jersey：JAX-RS参考实现。<a href="https://jersey.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/resteasy/">RESTEasy</a>：经过JAX-RS规范完全认证的可移植实现。<a href="http://resteasy.jboss.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/restexpress/">RestExpress</a>：一个Java类型安全的REST客户端。<a href="https://github.com/RestExpress/RestExpress">官网</a></li>
<li><a href="http://hao.jobbole.com/restx/">RestX</a>：基于注解处理和编译时源码生成的框架。<a href="http://restx.io">官网</a></li>
<li><a href="http://hao.jobbole.com/retrofit/">Retrofit</a>：类型安全的REST客户端。<a href="http://square.github.io/retrofit/">官网</a></li>
<li><a href="http://hao.jobbole.com/sparkjava/">Spark</a>：受到Sinatra启发的Java REST框架。<a href="http://sparkjava.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/swagger/">Swagger</a>：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。<a href="http://swagger.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/bladejava/">Blade</a>：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a href="https://github.com/biezhi/blade">官网</a></li>
</ul>

<h3 id="science">科学计算与分析</h3>

<p><em>用于科学计算和分析的函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/datamelt/">DataMelt</a>：用于科学计算、数据分析及数据可视化的开发环境。<a href="http://jwork.org/dmelt/">官网</a></li>
<li><a href="http://hao.jobbole.com/jgrapht/">JGraphT</a>：支持数学图论对象和算法的图形库。<a href="https://github.com/jgrapht/jgrapht">官网</a></li>
<li><a href="http://hao.jobbole.com/jscience/">JScience</a>：用来进行科学测量和单位的一组类。<a href="http://jscience.org/">官网</a></li>
</ul>

<h3 id="search">搜索引擎</h3>

<p><em>文档索引引擎，用于搜索和分析。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/solr/">Apache Solr</a>：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。<a href="http://lucene.apache.org/solr/">官网</a></li>
<li>Elasticsearch：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTful Web接口和无schema的JSON文档。<a href="http://www.elsticsearch.org/">官网</a></li>
<li>Apache Lucene：是一个开放源代码的全文检索引擎工具包，是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。<a href="http://lucene.apache.org/">官网</a></li>
</ul>

<h3 id="security">安全</h3>

<p><em>用于处理安全、认证、授权或会话管理的函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/shiro/">Apache Shiro</a>：执行认证、授权、加密和会话管理。<a href="http://shiro.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/bouncy-castle/">Bouncy Castle</a>，涵盖了从基础的帮助函数到PGP/SMIME操作。<a href="https://www.bouncycastle.org/java.html">官网</a>：多途加密开发库。支持JCA提供者（JCA provider)</li>
<li><a href="http://hao.jobbole.com/cryptomator/">Cryptomator</a>：在云上进行客户端跨平台透明加密。<a href="https://cryptomator.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/keycloak/">Keycloak</a>：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。<a href="http://keycloak.jboss.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/picketlink/">PicketLink</a>：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。<a href="http://picketlink.org/">官网</a></li>
</ul>

<h3 id="serialization">序列化</h3>

<p><em>用来高效处理序列化的函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/flatbuffers/">FlatBuffers</a>：高效利用内存的序列化函数库，无需解包和解析即可高效访问序列化数据。<a href="https://github.com/google/flatbuffers">官网</a></li>
<li><a href="http://hao.jobbole.com/kryo/">Kryo</a>：快速、高效的对象图形序列化框架。<a href="https://github.com/EsotericSoftware/kryo">官网</a></li>
<li><a href="http://hao.jobbole.com/fst/">FST</a>：提供兼容JDK的高性能对象图形序列化。<a href="https://github.com/RuedigerMoeller/fast-serialization">官网</a></li>
<li><a href="http://hao.jobbole.com/messagepack/">MessagePack</a>：一种高效的二进制序列化格式。<a href="https://github.com/msgpack/msgpack-java">官网</a></li>
</ul>

<h3 id="server">应用服务器</h3>

<p><em>用来部署应用程序的服务器。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-tomcat/">Apache Tomcat</a>：针对Servlet和JSP的应用服务器，健壮性好且适用性强。<a href="http://tomcat.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/tomee/">Apache TomEE</a>：Tomcat加Java EE。<a href="http://tomee.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jetty/">Jetty</a>：轻量级、小巧的应用服务器，通常会嵌入到项目中。<a href="http://www.eclipse.org/jetty/">官网</a></li>
<li><a href="http://hao.jobbole.com/websphere-liberty/">WebSphere Liberty</a>：轻量级、模块化应用服务器，由IBM开发。<a href="https://developer.ibm.com/wasdev/">官网</a></li>
<li><a href="http://hao.jobbole.com/wildfly/">WildFly</a>：之前被称作JBoss，由Red Hat开发。支持很多Java EE功能。<a href="http://www.wildfly.org/">官网</a></li>
</ul>

<h3 id="template-engine">模板引擎</h3>

<p><em>在模板中替换表达式的工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/velocity/">Apache Velocity</a>：提供HTML页面模板、email模板和通用开源代码生成器模板。<a href="http://velocity.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/freemarker/">FreeMarker</a>：通用模板引擎，不需要任何重量级或自己使用的依赖关系。<a href="http://freemarker.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/handlebars-java/">Handlebars.java</a>：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semantic Mustache）。<a href="http://jknack.github.io/handlebars.java/">官网</a></li>
<li><a href="http://hao.jobbole.com/thymeleaf/">Thymeleaf</a>：旨在替换JSP，支持XML文件的工具。<a href="http://www.thymeleaf.org/">官网</a></li>
<li><a href="http://ibeetl.com/">Beetl</a>：新一代的模板引擎，功能强大，性能良好，超过当前流行的模板引擎。而且还易学易用。<a href="http://ibeetl.com/">官网</a></li>
</ul>

<h3 id="testing">测试</h3>

<p><em>测试内容从对象到接口，涵盖性能测试和基准测试工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jmeter/">Apache JMeter</a>：功能性测试和性能评测。<a href="http://jmeter.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/arquillian/">Arquillian</a>：集成测试和功能行测试平台，集成Java EE容器。<a href="http://arquillian.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/assertj/">AssertJ</a>：支持流式断言提高测试的可读性。<a href="http://joel-costigliola.github.io/assertj/">官网</a></li>
<li><a href="http://hao.jobbole.com/awaitility/">Awaitility</a>：用来同步异步操作的DSL。<a href="https://github.com/jayway/awaitility">官网</a></li>
<li><a href="http://hao.jobbole.com/cucumber-jvm/">Cucumber</a>：BDD测试框架。<a href="https://github.com/cucumber/cucumber-jvm">官网</a></li>
<li>Gatling：设计为易于使用、可维护的和高性能负载测试工具。<a href="http://gatling.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/hamcrest/">Hamcrest</a>：可用来灵活创建意图（intent）表达式的匹配器。<a href="http://hamcrest.org/JavaHamcrest/">官网</a></li>
<li>JMockit：用来模拟静态、final方法等。<a href="http://jmockit.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/junit/">JUnit</a>：通用测试框架。<a href="http://junit.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/mockito/">Mockito</a>：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。<a href="https://github.com/mockito/mockito">官网</a></li>
<li><a href="http://hao.jobbole.com/powermock/">PowerMock</a>： 支持模拟静态方法、构造函数、final类和方法、私有方法以及移除静态初始化器的模拟工具。<a href="https://github.com/jayway/powermock">官网</a></li>
<li><a href="http://hao.jobbole.com/rest-assured/">REST Assured</a>：为REST/HTTP服务提供方便测试的Java DSL。<a href="https://github.com/jayway/rest-assured">官网</a></li>
<li><a href="http://hao.jobbole.com/selenide/">Selenide</a>：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。<a href="http://selenide.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/selenium/">Selenium</a>：为Web应用程序提供可移植软件测试框架。<a href="http://docs.seleniumhq.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/spock/">Spock</a>：JUnit-compatible framework featuring an expressive Groovy-derived specification language.<a href="http://docs.spockframework.org/">官网</a>兼容JUnit框架，支持衍生的Groovy范的语言。</li>
<li><a href="http://hao.jobbole.com/testng/">TestNG</a>：测试框架。<a href="http://testng.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/truth/">Truth</a>：Google的断言和命题（proposition）框架。<a href="https://github.com/google/truth">官网</a></li>
<li><a href="http://hao.jobbole.com/unitils/">Unitils</a>：模块化测试函数库，支持单元测试和集成测试。<a href="http://www.unitils.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/wiremock/">WireMock</a>：Web Service测试桩（Stub）和模拟函数。<a href="http://wiremock.org/">官网</a></li>
</ul>

<h3 id="utility">通用工具库</h3>

<p><em>通用工具类函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-commons/">Apache Commons</a>：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。<a href="http://commons.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/args4j/">args4j</a>：命令行参数解析器。<a href="http://args4j.kohsuke.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/crash/">CRaSH</a>：为运行进行提供CLI。<a href="http://www.crashub.org">官网</a></li>
<li><a href="http://hao.jobbole.com/gephi/">Gephi</a>：可视化跨平台网络图形化操作程序。<a href="https://github.com/gephi/gephi/">官网</a></li>
<li><a href="http://hao.jobbole.com/guava/">Guava</a>：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I/O等。<a href="https://github.com/google/guava">官网</a></li>
<li><a href="http://hao.jobbole.com/jade/">JADE</a>：构建、调试多租户系统的框架和环境。<a href="http://jade.tilab.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/javatuples/">javatuples</a>：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。<a href="http://www.javatuples.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jcommander/">JCommander</a>：命令行参数解析器。<a href="http://jcommander.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/protege/">Protégé</a>：提供存在论（ontology）编辑器以及构建知识系统的框架。<a href="http://protege.stanford.edu/">官网</a></li>
</ul>

<h3 id="web-crawling">网络爬虫</h3>

<p><em>用于分析网站内容的函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/nutch/">Apache Nutch</a>：可用于生产环境的高度可扩展、可伸缩的网络爬虫。<a href="http://nutch.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/crawler4j/">Crawler4j</a>：简单的轻量级网络爬虫。<a href="https://github.com/yasserg/crawler4j">官网</a></li>
<li><a href="http://hao.jobbole.com/jsoup/">JSoup</a>：刮取、解析、操作和清理HTML。<a href="http://jsoup.org/">官网</a></li>
<li><a href="https://github.com/code4craft/webmagic/">webmagic</a>：一个可扩展的Java爬虫框架，架构类似Python的Scrapy。</li>
</ul>

<h3 id="web-frameworks">Web框架</h3>

<p><em>用于处理Web应用程序不同层次间通讯的框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-tapestry/">Apache Tapestry</a>：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。<a href="http://tapestry.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-wicket/">Apache Wicket</a>：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。<a href="http://wicket.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/gwt/">Google Web Toolkit</a>：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCP <a href="http://www.gwtproject.org/">官网</a>API、JUnit集成、国际化支持和GUI控件。</li>
<li><a href="http://hao.jobbole.com/grails/">Grails</a>：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。<a href="https://grails.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/ninja/">Ninja</a>：Java全栈Web开发框架。非常稳固、快速和高效。<a href="http://www.ninjaframework.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/pippo/">Pippo</a>：小型、高度模块化的类Sinatra框架。<a href="http://www.pippo.ro/">官网</a></li>
<li><a href="http://hao.jobbole.com/play-framework/">Play</a>：使用约定而非配置，支持代码热加载并在浏览器中显示错误。<a href="https://www.playframework.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/primefaces/">PrimeFaces</a>：JSF框架，提供免费和带支持的商业版本。包括若干前端组件。<a href="http://primefaces.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/ratpack/">Ratpack</a>：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。<a href="https://ratpack.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/spring-boot/">Spring Boot</a>：微框架，简化了Spring新程序的开发过程。<a href="http://projects.spring.io/spring-boot/">官网</a></li>
<li><a href="http://hao.jobbole.com/spring-framework/">Spring</a>：旨在简化Java EE的开发过程，提供依赖注入相关组件并支持面向切面编程。<a href="http://projects.spring.io/spring-framework/">官网</a></li>
<li><a href="http://hao.jobbole.com/vaadin/">Vaadin</a>：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。<a href="https://vaadin.com/">官网</a></li>
<li>Blade：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a href="https://github.com/biezhi/blade">官网</a></li>
</ul>

<h3 id="Business-Process-Management">业务流程管理套件</h3>

<p><em>流程驱动的软件系统构建。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jbpm/">jBPM</a>：非常灵活的业务流程管理框架，致力于构建开发与业务分析人员之间的桥梁。<a href="http://www.jbpm.org/">官网</a></li>
<li>Activity：轻量级工作流和业务流程管理框架。<a href="http://www.activiti.org/">官网</a> <a href="https://github.com/Activiti/Activiti">github</a></li>
</ul>

<h2 id="resources">资源</h2>

<h3 id="communities">社区</h3>

<ul>
<li>r/java：Reddit的Java子社区。<a href="https://www.reddit.com/r/java">官网</a></li>
<li>stackoverflow：问答平台。<a href="http://stackoverflow.com/questions/tagged/java">官网</a></li>
<li>vJUG：虚拟Java用户组。<a href="http://virtualjug.com/">官网</a></li>
</ul>

<h3 id="influential-books">有影响力的书</h3>

<p><em>具有广泛影响且值得阅读的Java经典书籍。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/effective-java/">Effective Java (2nd Edition)</a></li>
<li><a href="http://hao.jobbole.com/java-8-in-action/">Java 8 in Action</a></li>
<li><a href="http://hao.jobbole.com/java-concurrency-in-practice/">Java Concurrency in Practice | Java并发编程实战</a></li>
<li><a href="http://hao.jobbole.com/thinking-in-java/">Thinking in Java | Java编程思想</a></li>
<li><a href="http://hao.jobbole.com/java-puzzlers/">Java Puzzlers | Java解惑</a></li>
</ul>

<h3 id="podcasts">播客</h3>

<p><em>可以一边编程一边听的东西。</em></p>

<ul>
<li>Java Council：<a href="http://virtualjug.com/podcast/">官网</a></li>
<li>Java Posse：Discontinued as of 02/2015.<a href="http://www.javaposse.com/">官网</a></li>
</ul>

<h3 id="weibo-weixin">微博、微信公众号</h3>

<ul>
<li>ImportNew：是最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。 
<br><img src="http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg" alt=""/></li>
<li>ImportNew 微博：<a href="http://weibo.com/importnew">@ImportNew</a></li>
</ul>

<h3 id="twitter">Twitter</h3>

<ul>
<li><a href="https://twitter.com/AdamBien/">Adam Bien</a>：自由职业者、作家、JavaONE明星演讲者、顾问、Java Champion。</li>
<li><a href="https://twitter.com/agoncal/">Antonio Goncalves</a>：Java Champion、JUG Leader、Devoxx France、Java EE 6/7、JCP、作家。</li>
<li><a href="https://twitter.com/arungupta/">Arun Gupta</a>：Java Champion、JavaONE明星演讲者、JUG Leader、Devoxx4Kids成员、Red Hatter。</li>
<li><a href="https://twitter.com/brunoborges">Bruno Borges</a>：Oracle产品经理、Java Jock。</li>
<li><a href="https://twitter.com/edburns">Ed Burns</a>：Oracle技术团队顾问。</li>
<li><a href="https://twitter.com/baeldung">Eugen Paraschiv</a>：Spring安全课程作者。</li>
<li><a href="https://twitter.com/JavaFXpert">James Weaver</a>：Java、JavaFX、IoT开发者、作者和演讲者。</li>
<li><a href="https://twitter.com/Java_EE/">Java EE</a>：Java EE Twitter官方账号。</li>
<li><a href="https://twitter.com/Oraclejavamag">Java Magazine</a>：Java杂志官方账号。</li>
<li><a href="https://twitter.com/javanetbuzz/">Java.net</a>：Java.net官方账号。</li>
<li><a href="https://twitter.com/java/">Java</a>：Java Twitter官方账号。</li>
<li><a href="https://twitter.com/javinpaul">Javin Paul</a>：知名Java博客作者。</li>
<li><a href="https://twitter.com/lukaseder">Lukas Eder</a>：Data Geekery（jOOQ）创始人兼CEO。</li>
<li><a href="https://twitter.com/mariofusco">Mario Fusco</a>：RedHatter、JUG协调、活跃讲师和作者。</li>
<li><a href="https://twitter.com/mreinhold">Mark Reinhold</a>：Oracle首席架构师、Java平台开发组。</li>
<li><a href="https://twitter.com/karianna">Martijn Verburg</a>：London JUG co-leader、演讲者、作家、Java Champion等。</li>
<li><a href="https://twitter.com/OpenJDK">OpenJDK</a>：OpenJDK官方账号。</li>
<li><a href="https://twitter.com/reza_rahman">Reza Rahman</a>：Java EE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。</li>
<li><a href="https://twitter.com/sjmaple">Simon Maple</a>：Java Champion、virtualJUG创始人、LJC leader、RebelLabs作者。</li>
<li><a href="https://twitter.com/jodastephen">Stephen Colebourne</a>： Java Champion、演讲者。</li>
<li><a href="https://twitter.com/kablosna">Tim Boudreau</a>：作家、NetBeans大牛。</li>
<li><a href="https://twitter.com/trisha_gee">Trisha Gee</a>：Java Champion、演讲者。</li>
</ul>

<h3 id="weibo-weixin">微博、微信公众号</h3>

<ul>
<li>ImportNew 微博：<a href="http://weibo.com/importnew">@ImportNew</a></li>
<li>ImportNew：最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。
<br><img src="http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg" width=150 height=150></li>
</ul>

<h3 id="websites">知名网站</h3>

<p><em>值得关注的Java技术站点。</em></p>

<h4>中文站点</h4>

<ul>
<li><a href="http://www.importnew.com/">ImportNew</a>（ImportNew 专注 Java 技术）</li>
</ul>

<h4>英文站点</h4>

<ul>
<li><a href="https://android-arsenal.com">Android Arsenal</a></li>
<li><a href="http://hao.jobbole.com/google-java-style/">Google Java Style</a>：<a href="https://google.github.io/styleguide/javaguide.html">官网</a></li>
<li><a href="http://hao.jobbole.com/infoq/">InfoQ</a>：<a href="http://www.infoq.com/">官网</a></li>
<li><a href="http://www.javacodegeeks.com/">Java Code Geeks</a></li>
<li><a href="http://blog.jooq.org/">Java, SQL, and jOOQ</a></li>
<li><a href="http://java.net/">Java.net</a></li>
<li><a href="http://java.dzone.com/">Javalobby</a></li>
<li><a href="http://hao.jobbole.com/javaworld/">JavaWorld</a>：<a href="http://www.javaworld.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/jaxenter/">JAXenter</a>：<a href="https://jaxenter.com/">官网</a></li>
<li><a href="http://zeroturnaround.com/rebellabs/">RebelLabs</a></li>
<li><a href="http://hao.jobbole.com/javaspecialists/">The Java Specialist&#39; Newsletter</a>：<a href="http://www.javaspecialists.eu/archive/archive.jsp">官网</a></li>
<li><a href="http://blog.takipi.com/">The Takipi Blog</a></li>
<li><a href="http://hao.jobbole.com/theserverside/">TheServerSide.com</a>：服务器编程交流平台是一个老牌的IT信息网站，关注服务器端编程的，以Java和.Net周边信息为主。<a href="http://www.theserverside.com/">官网</a></li>
<li><a href="http://www.thoughts-on-java.org/">Thoughts On Java</a></li>
<li><a href="http://vanillajava.blogspot.ch/">Vanilla Java</a></li>
<li><a href="http://vladmihalcea.com/">Vlad Mihalcea on Hibernate</a></li>
<li><a href="https://www.voxxed.com/">Voxxed</a></li>
<li><a href="http://hao.jobbole.com/onjava/">OnJava</a>：O&#39;Reilly Java包含最新的Java技术资讯，优质代码，完全的实例和详解。<a href="http://www.onjava.com/">官网</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[B树]]></title>
    <link href="https://books.sangkf.cn/15534816349223.html"/>
    <updated>2019-03-25T10:40:34+08:00</updated>
    <id>https://books.sangkf.cn/15534816349223.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>B树的目的是为了硬盘快速读取数据(降低IO操作次数)而设计的一种平衡的多路查找树。目前大多数据库及文件索引，都是使用B树或者B树的变形来存储实现。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">为什么B树效率高</h2>

<p>在大规模数据存储操作中，由于无法一次性加载到内存里。所以避免不了发生内外存交换。所以次数越少，效率表现也越高。</p>

<p>来看下面这张图：</p>

<p><img src="media/15534816349223/15534826634243.jpg" alt=""/></p>

<p>这是个典型的b树结构，初始因子为1000，高度仅为3的b树，就可以存储1002001000的数据了。</p>

<p>假设要查询最后一个数据:</p>

<ul>
<li>从硬盘加载根节点搜索，IO一次。</li>
<li>根据根节点的指针信息，去加载第二层的节点， IO一次。</li>
<li>重复2，IO一次。</li>
</ul>

<p>IO只用了3次，就查询了需要的数据，所以说B树效率是非常高的。</p>

<p>B树的节点，在硬盘里表现为：柱面里的页(page)或盘块(block) ，如果把索引持久化到内存，只需要一次就够了。</p>

<p>B树的高效的前提是数据已排序。</p>

<h2 id="toc_1">B树结构</h2>

<p><img src="media/15534816349223/15534828070934.jpg" alt=""/></p>

<p>这是B树存储在硬盘的逻辑结构图。</p>

<p>其中根节点中17，35在称为关键字(key) ，实际中往往附带更多复杂类型数据。</p>

<p>可以看出一个节点包含 keys  ChildNotePointer  2部分信息。</p>

<p><img src="media/15534816349223/15534831629323.jpg" alt=""/></p>

<p>根据这张图介绍下b树的基础定义：</p>

<p>这是颗5阶B树的图，阶简写m。</p>

<ol>
<li>树中每个结点最多含有m个子节点（m&gt;=2）。 </li>
<li>每个内节点至少 [ceil(m / 2)] 个子节点。  内节点即非根节点非页子节点，也可以叫中间节点。</li>
<li>关键字key的数量   [ceil(m / 2)-1]&lt;= n &lt;= m-1，关键字按递增排序。</li>
<li>每个叶节点具有相同的深度，即树的高度h，而且不包含关键字信息。</li>
</ol>

<p>上图也可称为最小度数为3的b树，(degree) ，简写t。<br/><br/>
t其实是上面第二条定义中 [ceil(m / 2)] 的值，即t=[ceil(m/2)], 3=ceil(5/2) 。</p>

<ol>
<li>每个非根节点至少有t-1个关键字，非根内节点至少有t个子节点。 t称为度数(degree)，t&gt;=2  。</li>
<li>每个节点至多有2t-1关键字，每个内节点最多有2t个子节点。</li>
<li>每个叶节点具有相同的深度，即树的高度h，而且不包含关键字信息。</li>
</ol>

<p>度和阶都是描述子节点的数量的。</p>

<p>算法导论译版中是用度来描述的。</p>

<p>数据结构与算法分析是用阶来描述，网上大多也是。</p>

<p>下面简单的描述实现逻辑。</p>

<p>搜索：从根节点搜索，找到返回，找不到递归子节点。一直搜索到叶子节点，找到返回，找不到则说明key不存在。</p>

<pre><code class="language-java">//伪代码
entry BTreeSearch(node, key) {
    if(node == null)
           return null;
    for(int i = 0; i &lt; node.keys.length; i++)
    {
        if(node.keys[i] == key)
               return node.data[i];
    }
    return BTreeSearch(ChildrenNode[i].node,key);
}
 
var  entry = BTreeSearch(root, my_key);
</code></pre>

<p>插入：根节点插入，不满直接插入。节点满进行分裂，再满递归分裂。</p>

<p><img src="media/15534816349223/15534844258361.jpg" alt=""/></p>

<p>删除：查询到节点，然后进行删除操作，不满足B数节点的定义则进行节点合并。</p>

<p><img src="media/15534816349223/15534844510809.jpg" alt=""/></p>

<p>更新：查询到子节点，更新数据。</p>

<h2 id="toc_2">B树缺点</h2>

<p>从上面的得知，在查询单条数据是非常快的。但如果范围查的话，b树每次都要从根节点查询一遍。</p>

<p>所以在实际应用中，往往采用b树的变形，b+树来存储，只有叶子节点存储数据，每个叶子节点都指向下一个。</p>

<p>【转载】<a href="https://www.cnblogs.com/mushroom/p/4100087.html">https://www.cnblogs.com/mushroom/p/4100087.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM原理讲解]]></title>
    <link href="https://books.sangkf.cn/15516889064939.html"/>
    <updated>2019-03-04T16:41:46+08:00</updated>
    <id>https://books.sangkf.cn/15516889064939.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本文从 JVM 结构入手，介绍了 Java 内存管理、对象创建、常量池等基础知识，对面试中 JVM 相关的基础题目进行了讲解。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">基本问题</h2>

<ul>
<li>介绍下Java内存区域（运行时数据区）</li>
<li>Java对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</li>
<li>对象的访问定位的两种方式（句柄和直接指针两种方式）</li>
</ul>

<h2 id="toc_1">拓展问题</h2>

<ul>
<li>String类和常量池</li>
<li>8种基本类型的包装类和常量池</li>
</ul>

<h2 id="toc_2">概述</h2>

<p>对于Java程序员来说，在虚拟机自动内存管理机制下，不再需要像C++程序员这样为每一个new操作去写对应的delete/free操作，不容易出现内存泄漏和内存溢出问题，正是因为Java程序员把内存控制权交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>

<h2 id="toc_3">运行时数据区</h2>

<p>Java虚拟机在执行Java程序的过程中会把它管理的内存分成若干个不同的数据区域。</p>

<p><img src="media/15516889064939/15516900494445.jpg" alt=""/></p>

<p><strong>线程私有的</strong>：<em><u>程序计数器，虚拟机栈，本地方法栈</u></em><br/>
<strong>线程共享的</strong>：<em><u>堆，方法区，直接内存</u></em></p>

<h3 id="toc_4">程序计数器</h3>

<p>程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器来选择去下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等功能都需要依赖这个计数器来完成。</p>

<p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>

<p>从上面的介绍中我们知道程序计数器主要有两个作用:</p>

<ul>
<li>字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如顺序执行，选择，循环，异常处理</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了</li>
</ul>

<p><strong>注意</strong>：程序计数器是唯一不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>

<h3 id="toc_5">Java虚拟机栈</h3>

<p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是Java方法执行的内存模型。</p>

<p>Java内存可以粗糙的区分为堆内存(Heap)和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有局部变量表，操作数栈，动态链接，方法出口信息）</p>

<p>局部变量表主要存放可编译器可知的各种数据类型(boolean, byte, char, short, int, float, long, double)，对象引用（refrence类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>

<p>Java虚拟机栈会出现两种异常: StackOverFlowError 和 OutOfMemoryError。</p>

<ul>
<li>StackOverFlowEror：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li>
<li>OutOfMemoryError: 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li>
</ul>

<p>Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>

<h3 id="toc_6">本地方法栈</h3>

<p>和虚拟机栈发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在HotSpot虚拟机中和Java虚拟机栈合二为一。</p>

<p>本地方法被执行的时候，在本地方法栈会创建一个栈桢，用于存放该本地方法的局部变量表，操作数栈，动态链接，出口信息。</p>

<p>方法执行完毕后相应的栈桢也会出栈并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError两种异常。</p>

<h3 id="toc_7">堆</h3>

<p>Java虚拟机所管理的内存中最大的一块，Java堆使所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。几乎所有的对象实例以及数组都在这里分配内存。</p>

<p>Java堆是垃圾收集管理器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap)。从垃圾回收的角度，由于现在收集器基本采用的分代垃圾收集算法，所以Java堆还可以细分为: 新生代和老年代，再细致一点: Eden空间，From Survivor, To Survivor空间等。进一步划分的目的是更好的回收内存，或者更快的分配内存。</p>

<p><img src="media/15516889064939/15517535928182.jpg" alt=""/></p>

<p>在JDK1.8中移除了整个永久代，取而代之的是一个叫元空间(Metaspace)的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</p>

<p>【参考】<a href="https://www.cnblogs.com/paddix/p/5309550.html">Java8内存模型--永久代(PermGen)和元空间(Metaspace)</a></p>

<h3 id="toc_8">方法区</h3>

<p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是他却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java堆区分开来。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消息队列]]></title>
    <link href="https://books.sangkf.cn/15514282455736.html"/>
    <updated>2019-03-01T16:17:25+08:00</updated>
    <id>https://books.sangkf.cn/15514282455736.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>简单介绍了消息队列的优缺点，以及使用场景，如何保证消息的幂等性和高可用<br/>
<span id="more"></span><!-- more --></p>
</blockquote>

<h2 id="toc_0">为什么使用消息队列</h2>

<p>其实就是问问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景用消息队列的什么</p>

<p>先说一下消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有三个：解耦，异步，削峰。</p>

<h3 id="toc_1">解耦</h3>

<p>看这个场景。A系统发送数据到BCD三个系统，通过接口调用发送。如果E系统也要这个数据呢？那如果C系统现在不需要了呢？A系统负责人几乎崩溃。。。</p>

<p><img src="media/15514282455736/15514297168174.jpg" alt="" style="width:600px;"/></p>

<p>在这个场景中，A系统跟其他各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要A系统将这个数据发送过来。A系统要时时刻刻考虑BCDE四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？</p>

<p>如果使用MQ，A系统产生一条数据，发送到MQ里面，那个系统需要消费数据自己去MQ里面消费。如果新系统需要数据，直接从MQ里面消费即可；如果某个系统不需要这条数据了，就取消对MQ消息的消费即可。这样下来，A系统压根儿不需要去考虑给谁发送数据，不需要维护这个代码，也不需要考虑人家是否带哦用成功，失败超时等情况。</p>

<p><img src="media/15514282455736/15514304696275.jpg" alt="" style="width:600px;"/></p>

<p><strong>总结</strong>：通过一个MQ，Pub/Sub发布订阅这么一个模型，A系统就跟其他系统彻底解耦了。</p>

<p>你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个MQ去进行系统的解耦。</p>

<h3 id="toc_2">异步</h3>

<p>再看一个场景，A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要300ms，450ms，200ms。最终请求总延时是3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么懂你心，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p>

<p><img src="media/15514282455736/15514312973749.jpg" alt="" style="width:600px;"/></p>

<p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p>

<p>如果使用MQ，那么A系统连续发送三条消息到MQ队列中，假如耗时5ms，A系统从接受一个请求到返回响应给用户，时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p>

<p><img src="media/15514282455736/15514315070750.jpg" alt="" style="width:600px;"/></p>

<h3 id="toc_3">削峰</h3>

<p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p>

<p>一般的MySQL，扛到每秒 2K 个请求就差不多了，如果每秒请求到 5K的话，可能直接把 MySQL给打死了，导致系统崩溃，用户也就没法再使用系统了。</p>

<p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p>

<p><img src="media/15514282455736/15514319566756.jpg" alt="" style="width:600px;"/></p>

<p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p>

<p><img src="media/15514282455736/15514322373227.jpg" alt=""/></p>

<p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p>

<h2 id="toc_4">消息队列有什么优缺点</h2>

<p>优点上面已经说了，就是<strong>在特殊场景下有其对应的好处，解耦，异步，削峰</strong>。</p>

<p>缺点有以下几个：</p>

<ul>
<li><p>系统可用性降低<br/>
系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用，可以<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md">点击这里查看</a>。</p></li>
<li><p>系统复杂度提高<br/>
硬生生加个 MQ 进来，你怎么<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed.md">保证消息没有重复消费</a>？怎么<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.md">处理消息丢失的情况</a>？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</p></li>
<li><p>一致性问题<br/>
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p></li>
</ul>

<p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p>

<h3 id="toc_5">Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3>

<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>

<tbody>
<tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody>
</table>

<p>综上，各种对比之后，有如下建议：</p>

<p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p>

<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p>

<p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p>

<p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>

<p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。   </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的volatile关键字解析]]></title>
    <link href="https://books.sangkf.cn/15513224851488.html"/>
    <updated>2019-02-28T10:54:45+08:00</updated>
    <id>https://books.sangkf.cn/15513224851488.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">内存模型的相关概念</h2>

<p>计算机的没一条指令都是在CPU中执行的，执行指令的过程中会涉及到数据的读取和写入。由于程序运行过程中的临时数据是放在主存（物理内存）中的，但是由于CPU的执行速度很快，而从内存读取数据和向内存写入数据的过程相对慢很多，因此任何时候对数据的操作会由于要和内存进行交互而拖慢了指令的执行速度。因此CPU里面就有了高速缓存。</p>

<h3 id="toc_1">高速缓存</h3>

<p>程序运行过程中，会将运算需要的数据从主存中复制一份到CPU的告诉缓存中，那么CPU进行计算时就可以直接从它的高速缓存中读取和写入数据，当运算结束时，再将高速缓存中的数据刷新到主存当中。<br/>
但是，由于每个CPU都有自己的高速缓存，当一个变量存在多个CPU的高速缓存中（即多个线程访问共享变量），就可能出现缓存不一致的情况。</p>

<p>所以就出现了缓存一致性协议。</p>

<h3 id="toc_2">缓存一致性协议</h3>

<p><strong>核心思想</strong>：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发信号通知其他CPU将该变量的缓存行置为无效的状态，因此当其他CPU需要读取这个变量时，发现自己缓存中该变量的缓存行是无效的，那么他就会从内存中重新读取。<br/>
<img src="media/15513224851488/15513240773229.jpg" alt="" style="width:400px;"/></p>

<h2 id="toc_3">并发编程中的三个概念</h2>

<ul>
<li><p><strong>原子性</strong><br/>
即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p></li>
<li><p><strong>可见性</strong><br/>
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></li>
<li><p><strong>有序性</strong><br/>
程序执行的顺序按照代码的先后顺序执行。<br/>
因为处理器为了提高程序的运行效率，可能会对代码进行优化，即指令重排序。它不保证程序中的各个语句的执行顺序同代码一致，但是它会保证程序的最终执行结果和代码顺序执行结果是一致的。</p></li>
</ul>

<h2 id="toc_4">Java内存模型</h2>

<p>在Java虚拟机规范中试图定义一种Java内存模型来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台都达到一致的内存访问效果。</p>

<p>Java内存模型规定了程序中变量的访问规则，往大了说也就是程序执行的次序。为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升执行速度，也就没有限制编译器对指令进行重排序。因此，<strong><em>在Java内存模型中也存在缓存一致性和指令重排序的问题</em></strong>。</p>

<p>Java内存模型规定所有的变量都存在与主存当中（类似前面说的物理内存），每个线程有自己的工作内存（类似前面说的高速缓存），线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>

<p>例：在java中，执行下面这个语句：</p>

<pre><code class="language-java">i = 10
</code></pre>

<p><u>执行线程必须现在自己的工作内存中对变量i所在的缓存行进行赋值操作，然后再写入主存中。而不是直接将数值10写入到主存当中。</u></p>

<p>那么Java语言本身对原子性，可见性以及有序性提供了那些保证呢？</p>

<ul>
<li><p><strong>原子性</strong><br/>
对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被打断的，要么执行，要么不执行</p>
<p>例：请分析下面那些操作是原子性操作</p>
<pre><code class="language-java">x = 10;         //语句1
y = x;         //语句2<br/>
x++;           //语句3<br/>
x = x + 1;     //语句4
</code></pre>
<p>上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说, <u>只有简单的读取，赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</u></p>
<p>注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出，Java内存模型只保证了基本的读取和赋值是原子性操作，如果实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></li>
<li><p><strong>可见性</strong><br/>
<strong>对于可见性，Java提供了volatile关键字来保证可见性。</strong></p>
<p><strong>当一个共享变量被volatile修饰时，它会保证修改的值会立刻被更新到主存，当有其他线程需要读取时，它会从内存中读取新值。</strong></p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，<strong>通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且释放锁之前会将对变量的修改刷新到主存中</strong>，因此保证了可见性。</p></li>
<li><p><strong>有序性</strong><br/>
在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p><strong>volatile关键字可以保证一定的有序性。另外通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然保证了有序性。</strong></p></li>
</ul>

<h2 id="toc_5">深入剖析volatile关键字</h2>

<h3 id="toc_6">volatile关键字的两层语义</h3>

<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>

<ul>
<li><p><strong>保证了不同线程对变量操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</strong></p></li>
<li><p><strong>禁止进行指令重排序。</strong></p></li>
</ul>

<p>先看一段代码，假如线程1先执行，线程2后执行：</p>

<pre><code class="language-java">//线程1
boolean stop = false;
while(!stop){
    doSomething();
}
 
//线程2
stop = true;
</code></pre>

<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>

<p>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>

<p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>

<p>但是用volatile修饰之后就变得不一样了：　　</p>

<ol>
<li><strong>使用volatile关键字会强制将修改的值立即写入主存；</strong></li>
<li><strong>使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效；</strong></li>
<li><strong>由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</strong></li>
</ol>

<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>

<p>那么线程1读取到的就是最新的正确的值。</p>

<h3 id="toc_7">volatile保证原子性吗</h3>

<p>下面看一个例子：</p>

<pre><code class="language-java">public class Test {
    public volatile int inc = 0;
     
    public void increase() {
        inc++;
    }
     
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
         
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>

<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>

<p>　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>

<p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>

<p>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>

<p>　　假如某个时刻变量inc的值为10，</p>

<p>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>

<p>　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>

<p>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>

<p>　　那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>

<p>　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>

<p>　　根源就在这里，<strong>自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</strong></p>

<p>把上面的代码改成以下任何一种都可以达到效果：<br/>
采用synchronized：</p>

<pre><code class="language-java">public class Test {
    public  int inc = 0;
    
    public synchronized void increase() {
        inc++;
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>

<p>采用Lock：</p>

<pre><code class="language-java">public class Test {
    public  int inc = 0;
    Lock lock = new ReentrantLock();
    
    public  void increase() {
        lock.lock();
        try {
            inc++;
        } finally{
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>

<p>采用AtomicInteger：</p>

<pre><code class="language-java">public class Test {
    public  AtomicInteger inc = new AtomicInteger();
     
    public  void increase() {
        inc.getAndIncrement();
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>

<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>

<h3 id="toc_8">volatile能保证有序性吗</h3>

<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性<br/>
volatile关键字禁止指令重排序有两层意思：</p>

<ul>
<li><p><strong>当程序执行到volatile变量的读操作或者写操作时,在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行;</strong></p></li>
<li><p><strong>在进行指令优化是，不能将在volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</strong></p></li>
</ul>

<p>可能上面说的比较绕，举个简单的例子：</p>

<pre><code class="language-java">//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
volatile flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
</code></pre>

<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>

<p>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>

<p>那么我们回到前面举的一个例子：</p>

<pre><code class="language-java">//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
</code></pre>

<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>

<p>　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>

<h3 id="toc_9">volatile的原理和实现机制</h3>

<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>

<p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>

<p>　　1）<strong>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</strong></p>

<p>　　2）<strong>它会强制将对缓存的修改操作立即写入主存；</strong></p>

<p>　　3）<strong>如果是写操作，它会导致其他CPU中对应的缓存行无效。</strong></p>

<h3 id="toc_10">使用volatile关键字的场景</h3>

<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>

<ul>
<li><p>对变量的写操作不依赖于当前值</p></li>
<li><p>对变量没有包含在具有其他变量的不变式中</p></li>
</ul>

<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>

<p>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>

<h4 id="toc_11">volatile使用场景</h4>

<p>下面列举几个Java中使用volatile的几个场景。</p>

<ul>
<li><p><strong>状态标记量</strong></p>
<pre><code class="language-java">volatile boolean flag = false;
while(!flag){<br/>
    doSomething();<br/>
}<br/>
public void setFlag() {<br/>
    flag = true;<br/>
}
</code></pre>
<pre><code class="language-java">volatile boolean inited = false;
//线程1:<br/>
context = loadContext();  <br/>
inited = true;            <br/>
//线程2:<br/>
while(!inited ){<br/>
    sleep()<br/>
}<br/>
doSomethingwithconfig(context);
</code></pre>
<p>将volatile变量作为状态标志使用：线程以volatile变量作为循环控制变量（例如控制线程是否继续执行，控制线程的生命周期），由另外一个线程控制该变量的值（true or false）。这种情况下需要变量具有可见性，volatile变量适合。然而，使用synchnorized块编写循环要比使用volatile状态标志编写麻烦很多。由于volaitle简化了代码，并且状态标志不依赖于程序内任何其他状态，因此此处非常适合使用volatile。</p></li>
<li><p><strong>double check</strong></p>
<pre><code class="language-java">class Singleton{
    private volatile static Singleton instance = null;<br/>
    private Singleton() {<br/>
    }<br/>
    public static Singleton getInstance() {<br/>
        if(instance==null) {<br/>
            synchronized (Singleton.class) {<br/>
                if(instance==null)<br/>
                    instance = new Singleton();<br/>
            }<br/>
        }<br/>
        return instance;<br/>
    }<br/>
}
</code></pre></li>
</ul>

<h4 id="toc_12">正确使用volatile关键字</h4>

<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。</p>

<p>volatile变量具有synchronized的可见性特性，但是不具备原子性。这就是说线程能够自动发现volatile变量的最新值。volatile变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用volatile还不足以实现计数器，互斥锁或任何具有多个变量相关的不变式的类。</p>

<p>出于简易性或可伸缩性的考虑，您可能倾向于使用 volatile 变量而不是锁。当使用 volatile 变量而非锁时，某些习惯用法（idiom）更加易于编码和阅读。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。</p>

<p><strong>使用条件</strong></p>

<p>您只能在有限的一些情形下使用 volatile 变量替代锁。<strong>要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件</strong>：</p>

<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ul>

<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>

<p>第一个条件就是不能是自增自减等操作。第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由（读取－修改－写入）操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。</p>

<p>第二个条件我们来举个例子它包含了一个不变式 ：下界总是小于或等于上界。</p>

<pre><code class="language-java">public class NumberRange {  
    private int lower, upper;  
  
    public int getLower() { return lower; }  
    public int getUpper() { return upper; }  
  
    public void setLower(int value) {   
        if (value &gt; upper)   
            throw new IllegalArgumentException(...);  
        lower = value;  
    }  
  
    public void setUpper(int value) {   
        if (value &lt; lower)   
            throw new IllegalArgumentException(...);  
        upper = value;  
    }  
}  
</code></pre>

<p>这种方式限制了范围的状态变量。因此将 lower 和 upper 字段定义为 volatile 类型不能够充分实现类的线程安全；而仍然需要使用同步——使 setLower() 和 setUpper() 操作原子化。</p>

<p>否则，如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是(0, 5)，同一时间内，线程 A 调用setLower(4) 并且线程 B 调用setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是(4, 3) —— 一个无效值，这显然是不对的。</p>

<h4 id="toc_13">volatile 与 synchronized 的比较</h4>

<p>（1）volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住；</p>

<p>（2）volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的；</p>

<p>（3）volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性；</p>

<p>（4）volatile不会造成线程的阻塞，即volatile不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞；synchronized可能会造成线程的阻塞；</p>

<p>（5）当一个域的值依赖于它之前的值时，volatile就无法工作了，如n=n+1,n++等。如果某个域的值受到其他域的值的限制，那么volatile也无法工作，如Range类的lower和upper边界，必须遵循lower&lt;=upper的限制。</p>

<p>（6）volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>

<p><strong>总结</strong>：</p>

<p>与锁相比，volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件即变量真正独立于其他变量和自己以前的值 ，在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。</p>

<p>[<strong>参考</strong>]  <a href="https://www.cnblogs.com/xiaoxi/p/7251171.html">https://www.cnblogs.com/xiaoxi/p/7251171.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HashMap源码解读(JDK1.7)]]></title>
    <link href="https://books.sangkf.cn/15512563500691.html"/>
    <updated>2019-02-27T16:32:30+08:00</updated>
    <id>https://books.sangkf.cn/15512563500691.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p>

<h2 id="toc_0">什么是哈希表</h2>

<p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p>

<h3 id="toc_1">数据结构</h3>

<ul>
<li><p><strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p></li>
<li><p><strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p></li>
<li><p><strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p></li>
<li><p><strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p></li>
</ul>

<p>　　我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构和链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p>

<p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>

<p>　　<strong>存储位置 = f(关键字)</strong></p>

<p>　　其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p>

<p>　　<img src="media/15512563500691/15512566971728.jpg" alt="" style="width:500px;"/></p>

<p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>

<h3 id="toc_2">哈希冲突</h3>

<p>　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单和散列地址分布均匀</strong>,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式，</p>

<h2 id="toc_3">HashMap实现原理</h2>

<p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>

<pre><code class="language-java">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。
transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;
</code></pre>

<p>Entry是HashMap中的一个静态内部类。代码如下</p>

<pre><code class="language-java">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final K key;
        V value;
        Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构
        int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算

        /**
         * Creates new entry.
         */
        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
            value = v;
            next = n;
            key = k;
            hash = h;
        } 
}
</code></pre>

<p>所以，HashMap的整体结构如下<br/>
<img src="media/15512563500691/15512580662636.jpg" alt="" style="width:700px;"/></p>

<p>简单来说，<strong>HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，只需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p>

<p>其他几个重要字段</p>

<pre><code class="language-java">//实际存储的key-value键值对的个数
transient int size;
//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到
int threshold;
//负载因子，代表了table的填充度有多少，默认是0.75
final float loadFactor;
//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException
transient int modCount;
</code></pre>

<p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值。initialCapacity默认为16，loadFactory默认为0.75</p>

<pre><code class="language-java">public HashMap(int initialCapacity, float loadFactor) {
　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(2的30次方)
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);

        this.loadFactor = loadFactor;
        threshold = initialCapacity;
　　　　　
        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现
    }
</code></pre>

<p>从上面这段代码我们可以看出，<strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong></p>

<p>OK,接下来我们来看看put操作的实现吧</p>

<pre><code class="language-java"> public V put(K key, V value) {
        //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(2的4次方=16)
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
       //如果key为null，存储位置为table[0]或table[0]的冲突链上
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀
        int i = indexFor(hash, table.length);//获取在table中的实际位置
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value
            Object k;
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
        modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败
        addEntry(hash, key, value, i);//新增一个entry
        return null;
    }  
</code></pre>

<p>先来看看inflateTable这个方法</p>

<pre><code class="language-java">private void inflateTable(int toSize) {
        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂
        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1
        table = new Entry[capacity];
        initHashSeedAsNeeded(capacity);
    }
</code></pre>

<p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>

<pre><code class="language-java">private static int roundUpToPowerOf2(int number) {
        // assert number &gt;= 0 : &quot;number must be non-negative&quot;;
        return number &gt;= MAXIMUM_CAPACITY
                ? MAXIMUM_CAPACITY
                : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;    
</code></pre>

<p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>

<h3 id="toc_4">hash函数</h3>

<pre><code class="language-java">//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀
final int hash(Object k) {
        int h = hashSeed;
        if (0 != h &amp;&amp; k instanceof String) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode();

        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    }
</code></pre>

<p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>

<pre><code class="language-java">/**
 * 返回数组下标
 */
static int indexFor(int h, int length) {
    return h &amp; (length-1);
}
</code></pre>

<p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p>

<pre><code class="language-java">    1  0  0  1  0
&amp;   0  1  1  1  1
__________________
    0  0  0  1  0    = 2
</code></pre>

<p>最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p>

<p>所以最终存储位置的确定流程是这样的：</p>

<p><img src="media/15512563500691/15512596171164.jpg" alt="" style="width:700px;"/></p>

<p>再来看看addEntry的实现：</p>

<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }
</code></pre>

<p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>

<h2 id="toc_5">为何HashMap的数组长度一定是2的次幂？</h2>

<p>我们来继续看上面提到的resize方法</p>

<pre><code class="language-java">void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }

        Entry[] newTable = new Entry[newCapacity];
        transfer(newTable, initHashSeedAsNeeded(newCapacity));
        table = newTable;
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    }
</code></pre>

<p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p>

<pre><code class="language-java">void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）
        for (Entry&lt;K,V&gt; e : table) {
            while(null != e) {
                Entry&lt;K,V&gt; next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                int i = indexFor(e.hash, newCapacity);
　　　　　　　　　 //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            }
        }
    }
</code></pre>

<p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p>

<p>　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p>

<p>　　<img src="media/15512563500691/1024555-20161115215812138-679881037.png" alt="" style="width:600px;"/></p>

<p> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p>

<p><img src="media/15512563500691/1024555-20161116001404732-625340289.png" alt="" style="width:600px;"/></p>

<p>　　我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>

<p><img src="media/15512563500691/1024555-20161116001717560-1455096254.png" alt="" style="width:600px;"/></p>

<p>　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。<br/>
　　</p>

<h3 id="toc_6">get方法</h3>

<pre><code class="language-java"> public V get(Object key) {
　　　　 //如果key为null,则直接去table[0]处去检索即可。
        if (key == null)
            return getForNullKey();
        Entry&lt;K,V&gt; entry = getEntry(key);
        return null == entry ? null : entry.getValue();
 }
</code></pre>

<p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p>

<pre><code class="language-java">final Entry&lt;K,V&gt; getEntry(Object key) {
            
        if (size == 0) {
            return null;
        }
        //通过key的hashcode值计算hash值
        int hash = (key == null) ? 0 : hash(key);
        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录
        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp; 
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                return e;
        }
        return null;
    }  
</code></pre>

<p>可以看出，get方法的实现相对简单，key(hashcode)--&gt;hash--&gt;indexFor--&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>

<h2 id="toc_7">重写equals方法需同时重写hashCode方法</h2>

<p>　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p>

<pre><code class="language-java">/**
 * Created by chengxiao on 2016/11/15.
 */
public class MyTest {
    private static class Person{
        int idCard;
        String name;

        public Person(int idCard, String name) {
            this.idCard = idCard;
            this.name = name;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()){
                return false;
            }
            Person person = (Person) o;
            //两个对象是否等值，通过idCard来确定
            return this.idCard == person.idCard;
        }

    }
    public static void main(String []args){
        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();
        Person person = new Person(1234,&quot;乔峰&quot;);
        //put到hashmap中去
        map.put(person,&quot;天龙八部&quot;);
        //get取出，从逻辑上讲应该能输出“天龙八部”
        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));
    }
}
</code></pre>

<p>实际输出结果：</p>

<pre><code class="language-java">结果：null
</code></pre>

<p>　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)--&gt;hash--&gt;indexFor--&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)--&gt;hash--&gt;indexFor--&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p>

<p>　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>

<p>[<strong>转载</strong>]：<a href="https://www.cnblogs.com/chengxiao/p/6059914.html">https://www.cnblogs.com/chengxiao/p/6059914.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HashMap源码解读(JDK1.8)]]></title>
    <link href="https://books.sangkf.cn/15512560778974.html"/>
    <updated>2019-02-27T16:27:57+08:00</updated>
    <id>https://books.sangkf.cn/15512560778974.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>在JDK1.8之前，HashMap采用<code>数组+链表</code>实现，即使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">概述</h2>

<p>在JDK1.8之前，HashMap采用<code>数组+链表</code>实现，即使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用<code>数组+链表+红黑树</code>实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>

<p>下图中代表jdk1.8之前的hashmap结构，左边部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。</p>

<p><img src="media/15512560778974/249993-20170725101800296-127995101.png" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>                jdk1.8之前hashmap结构图</p>

<p>     jdk1.8之前的hashmap都采用上图的结构，都是基于一个数组和多个单链表，hash值冲突的时候，就将对应节点以链表的形式存储。如果在一个链表中查找其中一个节点时，将会花费O（n）的查找时间，会有很大的性能损失。到了jdk1.8，当同一个hash值的节点数不小于8时，不再采用单链表形式存储，而是采用红黑树，如下图所示。</p>

<p><img src="media/15512560778974/249993-20170725102326906-1051203702.png" alt="" style="width:300px;"/></p>

<p><img src="media/15512560778974/249993-20170725102510515-1481424113.png" alt="" style="width:500px;"/><br/>
                jdk1.8 hashmap结构图</p>

<p>说明：上图很形象的展示了HashMap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红黑树，红黑树的引入是为了提高效率。</p>

<h2 id="toc_1">涉及到的数据结构：处理hash冲突的链表和红黑树以及位桶</h2>

<h3 id="toc_2">链表的实现</h3>

<p><img src="media/15512560778974/249993-20170725130741693-207764447.png" alt="" style="width:400px;"/></p>

<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。来看具体代码：</p>

<pre><code class="language-java">//Node是单向链表，它实现了Map.Entry接口
static class Node implements Map.Entry { final int hash; final K key;
    V value;
    Node next; //构造函数Hash值 键 值 下一个节点
    Node(int hash, K key, V value, Node next) { this.hash = hash; this.key = key; this.value = value; this.next = next;
    } public final K getKey()        { return key; } public final V getValue()      { return value; } public final String toString() { return key + = + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value);
    } public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue; return oldValue;
    } //判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true
    public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) {
            Map.Entry e = (Map.Entry)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true;
        } return false;
    }
}
</code></pre>

<p>可以看到，node中包含一个next变量，这个就是链表的关键点，hash结果相同的元素就是通过这个next进行关联的。</p>

<h3 id="toc_3">红黑树</h3>

<pre><code class="language-java">//红黑树
static final class TreeNode extends LinkedHashMap.Entry {
    TreeNode parent;  // 父节点
    TreeNode left; //左子树
    TreeNode right;//右子树
    TreeNode prev;    // needed to unlink next upon deletion
    boolean red;    //颜色属性
    TreeNode(int hash, K key, V val, Node next) { super(hash, key, val, next);
    } //返回当前节点的根节点
    final TreeNode root() { for (TreeNode r = this, p;;) { if ((p = r.parent) == null) return r;
            r = p;
        }
    }
}
</code></pre>

<p>红黑树比链表多了四个变量，parent父节点、left左节点、right右节点、prev上一个同级节点，红黑树内容较多，不在赘述。</p>

<h3 id="toc_4">位桶</h3>

<pre><code class="language-java">transient Node[] table;//存储（位桶）的数组
</code></pre>

<p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。</p>

<p>     有了以上3个数据结构，只要有一点数据结构基础的人，都可以大致联想到HashMap的实现了。首先有一个每个元素都是链表（可能表述不准确）的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。</p>

<h2 id="toc_5">HashMap源码分析</h2>

<h3 id="toc_6">类的继承关系</h3>

<pre><code class="language-java">public class HashMap extends AbstractMap implements Map, Cloneable, Serializable
</code></pre>

<p>     可以看到HashMap继承自父类（AbstractMap），实现了Map、Cloneable、Serializable接口。其中，Map接口定义了一组通用的操作；Cloneable接口则表示可以进行拷贝，在HashMap中，实现的是浅层次拷贝，即对拷贝对象的改变会影响被拷贝的对象；Serializable接口表示HashMap实现了序列化，即可以将HashMap对象保存至本地，之后可以恢复状态。</p>

<h3 id="toc_7">类的属性</h3>

<pre><code class="language-java">public class HashMap extends AbstractMap implements Map, Cloneable, Serializable { // 序列号
    private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16
    static final int DEFAULT_INITIAL_CAPACITY = 1 ; // 最大容量
    static final int MAXIMUM_CAPACITY = 1 ; // 默认的填充因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树
    static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表
    static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小
    static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍
    transient Node[] table; // 存放具体元素的集
    transient Set&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。
    transient int size; // 每次扩容和更改map结构的计数器
    transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容
    int threshold; // 填充因子
    final float loadFactor;
}
</code></pre>

<p>说明：类的数据成员很重要，以上也解释得很详细了。</p>

<h3 id="toc_8">类的构造函数</h3>

<h4 id="toc_9">HashMap(int, float)型构造函数</h4>

<pre><code class="language-java">public HashMap(int initialCapacity, float loadFactor) { // 初始容量不能小于0，否则报错
    if (initialCapacity ) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // 初始容量不能大于最大值，否则为最大值
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY; // 填充因子不能小于或等于0，不能为非数字
    if (loadFactor Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // 初始化填充因子 
    this.loadFactor = loadFactor; // 初始化threshold大小
    this.threshold = tableSizeFor(initialCapacity);    
}
</code></pre>

<p>说明：tableSizeFor(initialCapacity)返回大于initialCapacity的最小的二次幂数值。</p>

<pre><code class="language-java">static final int tableSizeFor(int cap) { int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16; return (n = MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre>

<p>说明：&gt;&gt;&gt; 操作符表示无符号右移，高位取0。</p>

<h4 id="toc_10">HashMap(int)型构造函数</h4>

<pre><code class="language-java">public HashMap(int initialCapacity) { // 调用HashMap(int, float)型构造函数
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
</code></pre>

<h4 id="toc_11">HashMap()型构造函数</h4>

<pre><code class="language-java">public HashMap() { // 初始化填充因子
    this.loadFactor = DEFAULT_LOAD_FACTOR; 
}
</code></pre>

<h4 id="toc_12">HashMap(Map)型构造函数</h4>

<pre><code class="language-java">public HashMap(Mapextends K, ? extends V&gt; m) { // 初始化填充因子
    this.loadFactor = DEFAULT_LOAD_FACTOR; // 将m中的所有元素添加至HashMap中
    putMapEntries(m, false);
}
</code></pre>

<p>说明：putMapEntries(Map m, boolean evict)函数将m的所有元素存入本HashMap实例中。　</p>

<pre><code class="language-java">final void putMapEntries(Mapextends K, ? extends V&gt; m, boolean evict) { int s = m.size(); if (s &gt; 0) { // 判断table是否已经初始化
        if (table == null) { // pre-size // 未初始化，s为m的实际元素个数
            float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值
            if (t &gt; threshold)
                threshold = tableSizeFor(t);
        } // 已初始化，并且m元素个数大于阈值，进行扩容处理
        else if (s &gt; threshold)
            resize(); // 将m中的所有元素添加至HashMap中
        for (Map.Entryextends K, ? extends V&gt; e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        }
    }
}
</code></pre>

<h3 id="toc_13">hash算法</h3>

<p>在JDK 1.8中，hash方法如下：</p>

<pre><code class="language-java">static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>

<p>（1）首先获取对象的hashCode()值，然后将hashCode值右移16位，然后将右移后的值与原来的hashCode做<strong>异或</strong>运算，返回结果。（其中h&gt;&gt;&gt;16，在JDK1.8中，优化了高位运算的算法，使用了零扩展，无论正数还是负数，都在高位插入0）。</p>

<p>（2）在putVal源码中，我们通过(n-1)&amp;hash获取该对象的键在hashmap中的位置。（其中hash的值就是（1）中获得的值）其中n表示的是hash桶数组的长度，并且该长度为2的n次方，这样(n-1)&amp;hash就等价于hash%n。因为&amp;运算的效率高于%运算。</p>

<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    ... 
    if ((p = tab[i = (n - 1) &amp; hash]) == null)//获取位置
        tab[i] = newNode(hash, key, value, null);
    ...
}
</code></pre>

<p>      tab即是table，n是map集合的容量大小，hash是上面方法的返回值。因为通常声明map集合时不会指定大小，或者初始化的时候就创建一个容量很大的map对象，所以这个通过容量大小与key值进行hash的算法在开始的时候只会对低位进行计算，虽然容量的2进制高位一开始都是0，但是key的2进制高位通常是有值的，因此先在hash方法中将key的hashCode右移16位在与自身异或，使得高位也可以参与hash，更大程度上减少了碰撞率。</p>

<p>下面举例说明下，n为table的长度。</p>

<p><img src="media/15512560778974/249993-20170725154200021-869603681.png" alt="" style="width:500px;"/></p>

<h3 id="toc_14">重要方法分析</h3>

<p><strong>（1）putVal方法</strong></p>

<p>首先说明，HashMap并没有直接提供putVal接口给用户调用，而是提供的put方法，而put方法就是通过putVal来插入元素的。</p>

<pre><code class="language-java">public V put(K key, V value) { // 对key的hashCode()做hash 
    return putVal(hash(key), key, value, false, true);  
} 
</code></pre>

<p>putVal方法执行过程可以通过下图来理解：</p>

<p><img src="media/15512560778974/249993-20170725160254943-1515467235.png" alt="" style="width:700px;"/></p>

<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>

<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>

<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>

<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>

<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>

<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>

<p>具体源码如下：</p>

<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node[] tab; Node p; int n, i; // 步骤①：tab为空则创建 // table未初始化或者长度为0，进行扩容
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素
    else {
        Node e; K k; // 步骤③：节点key存在，直接覆盖value // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等
        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 将第一个元素赋值给e，用e来记录
                e = p; // 步骤④：判断该链为红黑树 // hash值不相等，即key不相等；为红黑树结点
        else if (p instanceof TreeNode) // 放入树中
            e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 // 为链表结点
        else { // 在链表最末插入结点
            for (int binCount = 0; ; ++binCount) { // 到达链表的尾部
                if ((e = p.next) == null) { // 在尾部插入新结点
                    p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
 treeifyBin(tab, hash); // 跳出循环
                    break;
                } // 判断链表中结点的key值与插入的元素的key值是否相等
                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循环
                    break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表
                p = e;
            }
        } // 表示在桶中找到key值、hash值与插入元素相等的结点
        if (e != null) { // 记录e的value
            V oldValue = e.value; // onlyIfAbsent为false或者旧值为null
            if (!onlyIfAbsent || oldValue == null) //用新值替换旧值
                e.value = value; // 访问后回调
 afterNodeAccess(e); // 返回旧值
            return oldValue;
        }
    } // 结构性修改
    ++modCount; // 步骤⑥：超过最大容量 就扩容 // 实际大小大于阈值则扩容
    if (++size &gt; threshold)
        resize(); // 插入后回调
 afterNodeInsertion(evict); return null;
}
</code></pre>

<h5 id="toc_15">HashMap的数据存储实现原理</h5>

<p><strong>流程：</strong></p>

<p>1. 根据key计算得到key.hash = (h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)；</p>

<p>2. 根据key.hash计算得到桶数组的索引index = key.hash &amp; (table.length - 1)，这样就找到该key的存放位置了：</p>

<p>① 如果该位置没有数据，用该数据新生成一个节点保存新数据，返回null；</p>

<p>② 如果该位置有数据是一个红黑树，那么执行相应的插入 / 更新操作；</p>

<p>③ 如果该位置有数据是一个链表，分两种情况一是该链表没有这个节点，另一个是该链表上有这个节点，注意这里判断的依据是key.hash是否一样：</p>

<p>如果该链表没有这个节点，那么采用尾插法新增节点保存新数据，返回null；如果该链表已经有这个节点了，那么找到该节点并更新新数据，返回老数据。</p>

<p>注意：</p>

<p>HashMap的put会返回key的上一次保存的数据，比如：</p>

<pre><code class="language-java">HashMap map = new HashMap();
System.out.println(map.put(&quot;a&quot;, &quot;A&quot;)); // 打印null
System.out.println(map.put(&quot;a&quot;, &quot;AA&quot;)); // 打印A
System.out.println(map.put(&quot;a&quot;, &quot;AB&quot;)); // 打印AA
</code></pre>

<p><strong>（2）getNode方法</strong></p>

<p>说明：HashMap同样并没有直接提供getNode接口给用户调用，而是提供的get方法，而get方法就是通过getNode来取得元素的。</p>

<pre><code class="language-java">public V get(Object key) {
    Node e; return (e = getNode(hash(key), key)) == null ? null : e.value;
}
</code></pre>

<pre><code class="language-java">final Node getNode(int hash, Object key) {
    Node[] tab; Node first, e; int n; K k; // table已经初始化，长度大于0，根据hash寻找table中的项也不为空
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 桶中第一项(数组元素)相等
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个结点
        if ((e = first.next) != null) { // 为红黑树结点
            if (first instanceof TreeNode) // 在红黑树中查找
                return ((TreeNode)first).getTreeNode(hash, key); // 否则，在链表中查找
            do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e;
            } while ((e = e.next) != null);
        }
    } return null;
}
</code></pre>

<p><strong>（3）resize方法</strong></p>

<p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p>

<p>②.每次扩展的时候，都是扩展2倍；</p>

<p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p>

<pre><code class="language-java">final Node[] resize() {
    Node[] oldTab = table;//oldTab指向hash桶数组
    int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) {//如果oldCap不为空的话，就是hash桶数组不为空
        if (oldCap &gt;= MAXIMUM_CAPACITY) {//如果大于最大容量了，就赋值为整数最大的阀值
            threshold = Integer.MAX_VALUE; return oldTab;//返回
        }//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16
        else if ((newCap = oldCap oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr // double threshold 双倍扩容阀值threshold
 } else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr; else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    } if (newThr == 0) { float ft = (float)newCap * loadFactor;
        newThr = (newCap float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node[] newTab = (Node[])new Node[newCap];//新建hash桶数组
    table = newTab;//将新数组的值复制给旧的hash桶数组
    if (oldTab != null) {//进行扩容操作，复制Node对象值到新的hash桶数组
        for (int j = 0; j j) {
            Node e; if ((e = oldTab[j]) != null) {//如果旧的hash桶数组在j结点处不为空，复制给e
                oldTab[j] = null;//将旧的hash桶数组在j结点处设置为空，方便gc
                if (e.next == null)//如果e后面没有Node结点
                    newTab[e.hash &amp; (newCap - 1)] = e;//直接对e的hash值对新的数组长度求模获得存储位置
                else if (e instanceof TreeNode)//如果e是红黑树的类型，那么添加到红黑树中
                    ((TreeNode)e).split(this, newTab, j, oldCap); else { // preserve order
                    Node loHead = null, loTail = null;
                    Node hiHead = null, hiTail = null;
                    Node next; do {
                        next = e.next;//将Node结点的next赋值给next
                        if ((e.hash &amp; oldCap) == 0) {//如果结点e的hash值与原hash桶数组的长度作与运算为0
                            if (loTail == null)//如果loTail为null
                                loHead = e;//将e结点赋值给loHead
                            else loTail.next = e;//否则将e赋值给loTail.next
                            loTail = e;//然后将e复制给loTail
 } else {//如果结点e的hash值与原hash桶数组的长度作与运算不为0
                            if (hiTail == null)//如果hiTail为null
                                hiHead = e;//将e赋值给hiHead
                            else hiTail.next = e;//如果hiTail不为空，将e复制给hiTail.next
                            hiTail = e;//将e复制个hiTail
 }
                    } while ((e = next) != null);//直到e为空
                    if (loTail != null) {//如果loTail不为空
                        loTail.next = null;//将loTail.next设置为空
                        newTab[j] = loHead;//将loHead赋值给新的hash桶数组[j]处
 } if (hiTail != null) {//如果hiTail不为空
                        hiTail.next = null;//将hiTail.next赋值为空
                        newTab[j + oldCap] = hiHead;//将hiHead赋值给新的hash桶数组[j+旧hash桶数组长度]
 }
                }
            }
        }
    } return newTab;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java基础知识整理]]></title>
    <link href="https://books.sangkf.cn/15511460518747.html"/>
    <updated>2019-02-26T09:54:11+08:00</updated>
    <id>https://books.sangkf.cn/15511460518747.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>不积跬步无以至千里，不积小流无以成江海<br/>
千里之行，始于足下</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">数据类型</h2>

<ul>
<li><p><strong>基本类型</strong></p>
<ul>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
<li>boolean/~</li>
</ul>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 并不支持 boolean 数组，而是使用 byte 数组来表示 int 数组来表示。</p></li>
<li><p><strong>包装类型</strong></p>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<pre><code class="language-java">Integer x = 2;     // 装箱
int y = x;         // 拆箱
</code></pre></li>
<li><p><strong>缓存池</strong></p>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<pre><code class="language-java">Integer x = new Integer(123);
Integer y = new Integer(123);<br/>
System.out.println(x == y);    // false<br/>
Integer z = Integer.valueOf(123);<br/>
Integer k = Integer.valueOf(123);<br/>
System.out.println(z == k);   // true
</code></pre>
<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<pre><code class="language-java">public static Integer valueOf(int i) {
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br/>
        return IntegerCache.cache[i + (-IntegerCache.low)];<br/>
    return new Integer(i);<br/>
}
</code></pre>
<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<pre><code class="language-java">static final int low = -128;
static final int high;<br/>
static final Integer cache[];<br/>
static {<br/>
    // high value may be configured by property<br/>
    int h = 127;<br/>
    String integerCacheHighPropValue =<br/>
        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);<br/>
    if (integerCacheHighPropValue != null) {<br/>
        try {<br/>
            int i = parseInt(integerCacheHighPropValue);<br/>
            i = Math.max(i, 127);<br/>
            // Maximum array size is Integer.MAX_VALUE<br/>
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);<br/>
        } catch( NumberFormatException nfe) {<br/>
            // If the property cannot be parsed into an int, ignore it.<br/>
        }<br/>
    }<br/>
    high = h;<br/>
    cache = new Integer[(high - low) + 1];<br/>
    int j = low;<br/>
    for(int k = 0; k &lt; cache.length; k++)<br/>
        cache[k] = new Integer(j++);<br/>
    // range [-128, 127] must be interned (JLS7 5.1.7)<br/>
    assert IntegerCache.high &gt;= 127;<br/>
}
</code></pre>
<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p>
<pre><code class="language-java">Integer m = 123;
Integer n = 123;<br/>
System.out.println(m == n); // true
</code></pre>
<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p></li>
</ul>

<h2 id="toc_1">String</h2>

<ul>
<li><p><strong>概览</strong><br/>
String 被声明为 final，因此它不可被继承。<br/>
在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {<br/>
    /** The value is used for character storage. */<br/>
    private final char value[];<br/>
}
</code></pre>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</p>
<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {<br/>
    /** The value is used for character storage. */<br/>
    private final byte[] value;<br/>
    /** The identifier of the encoding used to encode the bytes in {@code value}. */<br/>
    private final byte coder;<br/>
}
</code></pre>
<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p></li>
<li><p><strong>不可变的好处</strong></p>
<ol>
<li>可以缓存 hash 值<br/>
因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li>String Pool 的需要<br/>
如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。
<img src="media/15511460518747/15511491243385.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></li>
<li>安全性<br/>
String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
<li>线程安全<br/>
String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ol></li>
<li><p><strong>String, StringBuffer and StringBuilder</strong></p>
<ol>
<li>可变性
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul></li>
<li>线程安全
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul></li>
</ol></li>
<li><p><strong>String Pool</strong></p>
<p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<pre><code class="language-java">String s1 = new String(&quot;aaa&quot;);
String s2 = new String(&quot;aaa&quot;);<br/>
System.out.println(s1 == s2);           // false<br/>
String s3 = s1.intern();<br/>
String s4 = s1.intern();<br/>
System.out.println(s3 == s4);           // true
</code></pre>
<p>如果是采用 &quot;bbb&quot; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<pre><code class="language-java">String s5 = &quot;bbb&quot;;
String s6 = &quot;bbb&quot;;<br/>
System.out.println(s5 == s6);  // true
</code></pre>
<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p></li>
<li><p><strong>new String(&quot;abc&quot;)</strong></p>
<p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &quot;abc&quot; 字符串对象）。</p>
<ul>
<li>&quot;abc&quot; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &quot;abc&quot; 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。<br/>
创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</li>
</ul>
<pre><code class="language-java">public class NewStringTest {
    public static void main(String[] args) {<br/>
        String s = new String(&quot;abc&quot;);<br/>
    }<br/>
}
</code></pre>
<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<pre><code class="language-java">// ...
Constant pool:<br/>
// ...<br/>
   #2 = Class              #18            // java/lang/String<br/>
   #3 = String             #19            // abc<br/>
// ...<br/>
  #18 = Utf8               java/lang/String<br/>
  #19 = Utf8               abc<br/>
// ...<br/>
  public static void main(java.lang.String[]);<br/>
    descriptor: ([Ljava/lang/String;)V<br/>
    flags: ACC_PUBLIC, ACC_STATIC<br/>
    Code:<br/>
      stack=3, locals=2, args_size=1<br/>
         0: new           #2                  // class java/lang/String<br/>
         3: dup<br/>
         4: ldc           #3                  // String abc<br/>
         6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V<br/>
         9: astore_1<br/>
// ...
</code></pre>
<p>在 Constant Pool 中，#19 存储这字符串字面量 &quot;abc&quot;，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<pre><code class="language-java">public String(String original) {
    this.value = original.value;<br/>
    this.hash = original.hash;<br/>
}
</code></pre></li>
</ul>

<h2 id="toc_2">运算</h2>

<ul>
<li><strong>参数传递</strong>
Java 的参数是以值传递的形式传入方法中，而不是引用传递。</li>
</ul>

<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p>

<pre><code class="language-java">public class Dog {

    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }

    void setName(String name) {
        this.name = name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
</code></pre>

<pre><code class="language-java">public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog(&quot;B&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
</code></pre>

<p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p>

<pre><code class="language-java">class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName(&quot;B&quot;);
    }
}
</code></pre>

<ul>
<li><strong>float 与 double</strong>
Java 不能隐式执行向下转型，因为这会使得精度降低。<br/>
1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</li>
</ul>

<pre><code class="language-java">// float f = 1.1;
</code></pre>

<p>1.1f 字面量才是 float 类型。</p>

<pre><code class="language-java">float f = 1.1f;
</code></pre>

<ul>
<li><strong>隐式类型转换</strong>
因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</li>
</ul>

<pre><code class="language-java">short s1 = 1;
// s1 = s1 + 1;
</code></pre>

<p>但是使用 += 或者 ++ 运算符可以执行隐式类型转换。</p>

<pre><code class="language-java">s1 += 1;
// s1++;
</code></pre>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>

<pre><code class="language-java">s1 = (short) (s1 + 1);
</code></pre>

<ul>
<li><strong>switch</strong>
从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</li>
</ul>

<pre><code class="language-java">String s = &quot;a&quot;;
switch (s) {
    case &quot;a&quot;:
        System.out.println(&quot;aaa&quot;);
        break;
    case &quot;b&quot;:
        System.out.println(&quot;bbb&quot;);
        break;
}
</code></pre>

<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>

<pre><code class="language-java">// long x = 111;
// switch (x) { // Incompatible types. Found: &#39;long&#39;, required: &#39;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#39;
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }
</code></pre>

<h2 id="toc_3">继承</h2>

<h3 id="toc_4">访问权限</h3>

<p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>

<p>可以对类或类中的成员（字段以及方法）加上访问修饰符。<br/>
    <strong>类可见表示其它类可以用这个类创建实例对象。<br/>
    成员可见表示其它类可以用这个类的实例对象访问到该成员；</strong></p>

<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>

<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>

<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p>

<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>

<pre><code class="language-java">public class AccessExample {
    public String id;
}
</code></pre>

<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>

<pre><code class="language-java">public class AccessExample {

    private int id;

    public String getId() {
        return id + &quot;&quot;;
    }

    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}
</code></pre>

<p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>

<pre><code class="language-java">public class AccessWithInnerClassExample {

    private class InnerClass {
        int x;
    }

    private InnerClass innerClass;

    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }

    public int getValue() {
        return innerClass.x;  // 直接访问
    }
}
</code></pre>

<h3 id="toc_5">抽象类与接口</h3>

<ul>
<li><strong>抽象类</strong></li>
</ul>

<p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p>

<p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p>

<pre><code class="language-java">public abstract class AbstractClassExample {
    
    protected int x;
    private int y;
    
    public abstract void func1();
    
    public void func2() {
        System.out.println(&quot;func2&quot;);
    }
}
</code></pre>

<pre><code class="language-java">public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println(&quot;func1&quot;);
    }
}
</code></pre>

<pre><code class="language-java">// AbstractClassExample ac1 = new AbstractClassExample(); 
// &#39;AbstractClassExample&#39; is abstract; cannot be instantiated
AbstractClassExample ac2 = new AbstractExtendClassExample();
ac2.func1();
</code></pre>

<ul>
<li><strong>接口</strong></li>
</ul>

<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>

<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p>

<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p>

<p>接口的字段默认都是 static 和 final 的。</p>

<pre><code class="language-java">    public interface InterfaceExample {
    
    void func1();
    
    default void func2(){
        System.out.println(&quot;func2&quot;);
    }
    
    int x = 123;
    // int y;               // Variable &#39;y&#39; might not have been initialized
    public int z = 0;       // Modifier &#39;public&#39; is redundant for interface fields
    // private int k = 0;   // Modifier &#39;private&#39; not allowed here
    // protected int l = 0; // Modifier &#39;protected&#39; not allowed here
    // private void fun3(); // Modifier &#39;private&#39; not allowed here
} 
</code></pre>

<pre><code class="language-java">public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println(&quot;func1&quot;);
    }
}
</code></pre>

<pre><code class="language-java"> // InterfaceExample ie1 = new InterfaceExample(); // &#39;InterfaceExample&#39; is abstract; cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
</code></pre>

<ul>
<li><p><strong>比较</strong>   </p>
<ul>
<li>从设计层面来看，抽象类提供了一种IS-A关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种LIKE-A关系，他只是提供一个方法实现契约，并不要求接口和实现的类具有IS—A关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但不能继承多个抽象类。</li>
<li>接口的字段只能是static和final类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是public的，而抽象类的成员可以有多重访问权限。</li>
</ul></li>
<li><p><strong>使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/">深入理解 abstract class 和 interface</a></li>
<li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface">When to Use Abstract Class and Interface</a></li>
</ul></li>
</ul>

<h3 id="toc_6">super</h3>

<ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>

<pre><code class="language-java">public class SuperExample {

    protected int x;
    protected int y;

    public SuperExample(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void func() {
        System.out.println(&quot;SuperExample.func()&quot;);
    }
}
</code></pre>

<pre><code class="language-java">public class SuperExtendExample extends SuperExample {

    private int z;

    public SuperExtendExample(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    public void func() {
        super.func();
        System.out.println(&quot;SuperExtendExample.func()&quot;);
    }
}
</code></pre>

<pre><code class="language-java">SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();
</code></pre>

<pre><code class="language-java">SuperExample.func()
SuperExtendExample.func()
</code></pre>

<h3 id="toc_7">重写与重载</h3>

<h4 id="toc_8">重写</h4>

<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。<br/>
为了满足里式替换原则，重写有有以下两个限制：</p>

<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。<br/>
使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</li>
</ul>

<h4 id="toc_9">重载</h4>

<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>

<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>

<h4 id="toc_10">实例</h4>

<pre><code class="language-java">class A {
    public String show(D obj) {
        return (&quot;A and D&quot;);
    }

    public String show(A obj) {
        return (&quot;A and A&quot;);
    }
}

class B extends A {
    public String show(B obj) {
        return (&quot;B and B&quot;);
    }

    public String show(A obj) {
        return (&quot;B and A&quot;);
    }
}

class C extends B {
}

class D extends B {
}
</code></pre>

<pre><code class="language-java">public class Test {

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new B();
        B b = new B();
        C c = new C();
        D d = new D();
        System.out.println(a1.show(b)); // A and A
        System.out.println(a1.show(c)); // A and A
        System.out.println(a1.show(d)); // A and D
        System.out.println(a2.show(b)); // B and A
        System.out.println(a2.show(c)); // B and A
        System.out.println(a2.show(d)); // A and D
        System.out.println(b.show(b));  // B and B
        System.out.println(b.show(c));  // B and B
        System.out.println(b.show(d));  // A and D
    }
}
</code></pre>

<pre><code class="language-java">public class Test {

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new B();
        B b = new B();
        C c = new C();
        D d = new D();
        System.out.println(a1.show(b)); // A and A
        System.out.println(a1.show(c)); // A and A
        System.out.println(a1.show(d)); // A and D
        System.out.println(a2.show(b)); // B and A
        System.out.println(a2.show(c)); // B and A
        System.out.println(a2.show(d)); // A and D
        System.out.println(b.show(b));  // B and B
        System.out.println(b.show(c));  // B and B
        System.out.println(b.show(d));  // A and D
    }
}
</code></pre>

<p>涉及到重写时，方法调用的优先级为：</p>

<ul>
<li>this.show(O)</li>
<li>super.show(O)</li>
<li>this.show((super)O)</li>
<li>super.show((super)O)</li>
</ul>

<h2 id="toc_11">Object 通用方法</h2>

<h3 id="toc_12">概览</h3>

<pre><code class="language-java">public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class&lt;?&gt; getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
</code></pre>

<h3 id="toc_13">equals()</h3>

<h4 id="toc_14">等价关系</h4>

<ul>
<li><strong>自反性</strong></li>
</ul>

<pre><code class="language-java">x.equals(x); // true
</code></pre>

<ul>
<li><strong>对称性</strong></li>
</ul>

<pre><code class="language-java">x.equals(y) == y.equals(x); // true
</code></pre>

<ul>
<li><strong>传递性</strong></li>
</ul>

<pre><code class="language-java">if (x.equals(y) &amp;&amp; y.equals(z))
    x.equals(z); // true;
</code></pre>

<ul>
<li><strong>一致性</strong></li>
</ul>

<p>多次调用 equals() 方法结果不变</p>

<pre><code class="language-java">x.equals(y) == x.equals(y); // true
</code></pre>

<ul>
<li><strong>与NULL的比较</strong></li>
</ul>

<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>

<pre><code class="language-java">x.equals(null); // false;
</code></pre>

<h4 id="toc_15">等价与相等</h4>

<ul>
<li>对于基本类型，==判断两个值是否相等，基本类型没有equals()方法</li>
<li>对于引用类型，==判断两个变量是否引用同一个对象，而equals()判断引用的对象是否等价</li>
</ul>

<pre><code class="language-java">Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false
</code></pre>

<h4 id="toc_16">实现</h4>

<ul>
<li>检查是否为同一个对象的引用，如果是直接返回true</li>
<li>检查是否为同一类型，如果不是，直接返回false</li>
<li>将Object对象进行转型</li>
<li>判断每个关键域是否相等</li>
</ul>

<pre><code class="language-java">public class EqualExample {

    private int x;
    private int y;
    private int z;

    public EqualExample(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EqualExample that = (EqualExample) o;

        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}
</code></pre>

<h3 id="toc_17">hashCode()</h3>

<p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p>

<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p>

<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p>

<pre><code class="language-java">EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
</code></pre>

<p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p>

<p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>

<pre><code class="language-java">@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
</code></pre>

<h3 id="toc_18">toString()</h3>

<p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>

<pre><code class="language-java">public class ToStringExample {

    private int number;

    public ToStringExample(int number) {
        this.number = number;
    }
}
</code></pre>

<pre><code class="language-java">ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());
</code></pre>

<pre><code class="language-java">ToStringExample@4554617c
</code></pre>

<h3 id="toc_19">clone()</h3>

<h4 id="toc_20">cloneable</h4>

<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>

<pre><code class="language-java">public class CloneExample {
    private int a;
    private int b;
}
</code></pre>

<pre><code class="language-java">CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;
</code></pre>

<p>重写 clone() 得到以下实现：</p>

<pre><code class="language-java">public class CloneExample {
    private int a;
    private int b;

    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
</code></pre>

<pre><code class="language-java">CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
</code></pre>

<pre><code class="language-java">java.lang.CloneNotSupportedException: CloneExample
</code></pre>

<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>

<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>

<pre><code class="language-java">public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>

<h4 id="toc_21">浅拷贝</h4>

<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>

<pre><code class="language-java">public class ShallowCloneExample implements Cloneable {

    private int[] arr;

    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}
</code></pre>

<pre><code class="language-java">ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 222
</code></pre>

<h4 id="toc_22">深拷贝</h4>

<p>拷贝对象和原始对象的引用类型引用不同对象。</p>

<pre><code class="language-java">public class DeepCloneExample implements Cloneable {

    private int[] arr;

    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone();
        result.arr = new int[arr.length];
        for (int i = 0; i &lt; arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;
    }
}
</code></pre>

<pre><code class="language-java">DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
</code></pre>

<h4 id="toc_23">clone的替代方案</h4>

<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>

<pre><code class="language-java">public class CloneConstructorExample {

    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i &lt; original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
</code></pre>

<pre><code class="language-java">CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
</code></pre>

<h2 id="toc_24">关键字</h2>

<h3 id="toc_25">final</h3>

<h4 id="toc_26">数据</h4>

<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>

<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>

<pre><code class="language-java">final int x = 1;
// x = 2;  // cannot assign value to final variable &#39;x&#39;
final A y = new A();
y.a = 1;
</code></pre>

<h4 id="toc_27">方法</h4>

<p>声明方法不能被子类重写。</p>

<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>

<h4 id="toc_28">类</h4>

<p>声明类不允许被继承。</p>

<h3 id="toc_29">static</h3>

<h4 id="toc_30">静态变量</h4>

<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>

<pre><code class="language-java">public class A {

    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field &#39;x&#39; cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
</code></pre>

<h4 id="toc_31">静态方法</h4>

<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>

<pre><code class="language-java">public abstract class A {
    public static void func1(){
    }
    // public abstract static void func2();  // Illegal combination of modifiers: &#39;abstract&#39; and &#39;static&#39;
}
</code></pre>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p>

<pre><code class="language-java">public class A {

    private static int x;
    private int y;

    public static void func1(){
        int a = x;
        // int b = y;  // Non-static field &#39;y&#39; cannot be referenced from a static context
        // int b = this.y;     // &#39;A.this&#39; cannot be referenced from a static context
    }
}
</code></pre>

<h4 id="toc_32">静态语句块</h4>

<p>静态语句块在类初始化时运行一次。</p>

<pre><code class="language-java">public class A {
    static {
        System.out.println(&quot;123&quot;);
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}
</code></pre>

<pre><code class="language-java">123
</code></pre>

<h4 id="toc_33">静态内部类</h4>

<p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p>

<pre><code class="language-java">public class OuterClass {

    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // &#39;OuterClass.this&#39; cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
</code></pre>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>

<h4 id="toc_34">静态导包</h4>

<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>

<pre><code class="language-java">import static com.xxx.ClassName.*
</code></pre>

<h4 id="toc_35">初始化顺序</h4>

<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>

<pre><code class="language-java">public static String staticField = &quot;静态变量&quot;;
</code></pre>

<pre><code class="language-java">static {
    System.out.println(&quot;静态语句块&quot;);
}
</code></pre>

<pre><code class="language-java">public String field = &quot;实例变量&quot;;
</code></pre>

<pre><code class="language-java">{
    System.out.println(&quot;普通语句块&quot;);
}
</code></pre>

<p>最后才是构造函数的初始化。</p>

<pre><code class="language-java">public InitialOrderTest() {
    System.out.println(&quot;构造函数&quot;);
}
</code></pre>

<p>存在继承的情况下，初始化顺序为：</p>

<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>

<h2 id="toc_36">反射</h2>

<p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>

<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>

<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>

<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>

<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 创建新的对象。</li>
</ul>

<p><strong>反射的优点：</strong></p>

<ul>
<li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>

<p><strong>反射的缺点：</strong></p>

<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>

<ul>
<li><p><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p></li>
<li><p><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p></li>
<li><p><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p></li>
<li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Trail: The Reflection API</a></p></li>
<li><p><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1）- 基础</a></p></li>
</ul>

<h2 id="toc_37">异常</h2>

<p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>

<ul>
<li><strong>受检异常</strong> ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>

<p><img src="media/15511460518747/PPjwP.png" alt="" style="width:600px;"/></p>

<ul>
<li><a href="https://www.tianmaying.com/tutorial/Java-Exception">Java 入门之异常处理</a></li>
<li><a href="http://www.importnew.com/7383.html">Java 异常的面试问题及答案 -Part 1</a></li>
</ul>

<h2 id="toc_38">泛型</h2>

<pre><code class="language-java">public class Box&lt;T&gt; {
    // T stands for &quot;Type&quot;
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
</code></pre>

<ul>
<li><a href="http://www.importnew.com/24029.html">Java 泛型详解</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1033693">10 道 Java 泛型面试题</a></li>
</ul>

<h2 id="toc_39">注解</h2>

<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>

<p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解 Annotation 实现原理与自定义注解例子</a></p>

<h2 id="toc_40">特性</h2>

<h3 id="toc_41">Java 各版本的新特性</h3>

<p><strong>New highlights in Java SE 8</strong></p>

<ol>
<li>Lambda Expressions</li>
<li>Pipelines and Streams</li>
<li>Date and Time API</li>
<li>Default Methods</li>
<li>Type Annotations</li>
<li>Nashhorn JavaScript Engine</li>
<li>Concurrent Accumulators</li>
<li>Parallel operations</li>
<li>PermGen Error Removed</li>
</ol>

<p><strong>New highlights in Java SE 7</strong></p>

<ol>
<li>Strings in Switch Statement</li>
<li>Type Inference for Generic Instance Creation</li>
<li>Multiple Exception Handling</li>
<li>Support for Dynamic Languages</li>
<li>Try with Resources</li>
<li>Java nio Package</li>
<li>Binary Literals, Underscore in literals</li>
<li><p>Diamond Syntax</p></li>
</ol>

<ul>
<li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17">Difference between Java 1.8 and Java 1.7?</a></li>
<li><a href="http://www.importnew.com/19345.html">Java 8 特性</a></li>
</ul>

<h2 id="toc_42">Java 与 C++ 的区别</h2>

<ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
<li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li>
</ul>

<h2 id="toc_43">JRE or JDK</h2>

<ul>
<li>JRE is the JVM program, Java application need to run on JRE.</li>
<li>JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler &quot;javac&quot;</li>
</ul>

<h2 id="toc_44">参考资料</h2>

<ul>
<li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li>
<li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li>
</ul>

<h2 id="toc_45">进阶指南</h2>

<p><a href="https://github.com/CyC2018/Backend-Interview-Guide">https://github.com/CyC2018/Backend-Interview-Guide</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务架构下处理分布式事务的典型方案]]></title>
    <link href="https://books.sangkf.cn/15511042581022.html"/>
    <updated>2019-02-25T22:17:38+08:00</updated>
    <id>https://books.sangkf.cn/15511042581022.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>根据微服务架构的鼻祖Martin Fowler的忠告，微服务架构中应当尽量避免分布式事务。然而，在某些领域，分布式事务如同宿命中的对手无法避免。在工程领域，分布式事务的讨论主要聚焦于强一致性和最终一致性的解决方案。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">引述</h2>

<p>根据微服务架构的鼻祖Martin Fowler的忠告，微服务架构中应当尽量避免分布式事务。然而，在某些领域，分布式事务如同宿命中的对手无法避免。在工程领域，分布式事务的讨论主要聚焦于强一致性和最终一致性的解决方案。典型方案包括：</p>

<ul>
<li>两阶段提交（2PC, Two-phase Commit）方案；</li>
<li>eBay 事件队列方案；</li>
<li>TCC 补偿模式；</li>
<li>缓存数据最终一致性。</li>
</ul>

<h2 id="toc_1">一致性理论</h2>

<p>分布式事务的目的是保障分库数据一致性，而跨库事务会遇到各种不可控制的问题，如个别节点永久性宕机，像单机事务一样的ACID是无法奢望的。另外，业界著名的CAP理论也告诉我们，对分布式系统，需要将数据一致性和系统可用性、分区容忍性放在天平上一起考虑。</p>

<p>两阶段提交协议（简称2PC）是实现分布式事务较为经典的方案，但2PC 的可扩展性很差，在分布式架构下应用代价较大，eBay 架构师Dan Pritchett 提出了BASE 理论，用于解决大规模分布式系统下的数据一致性问题。BASE 理论告诉我们：可以通过放弃系统在每个时刻的强一致性来换取系统的可扩展性。</p>

<ul>
<li><p>CAP理论</p>
<ul>
<li><p>在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）3 个要素最多只能同时满足两个，不可兼得。其中，分区容忍性又是不可或缺的。</p>
<ul>
<li>一致性：分布式环境下多个节点的数据是否强一致。</li>
<li>可用性：分布式服务能一直保证可用状态。当用户发出一个请求后，服务能在有限时间内返回结果。</li>
<li>分区容忍性：特指对网络分区的容忍性。</li>
</ul></li>
</ul></li>
</ul>

<p>举例：Cassandra、Dynamo 等，默认优先选择AP，弱化C；HBase、MongoDB 等，默认优先选择CP，弱化A。</p>

<ul>
<li><p>BASE 理论</p>
<ul>
<li><p>核心思想：</p>
<ul>
<li>基本可用（Basically Available）：指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。</li>
<li>软状态（Soft State）：指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。</li>
<li>最终一致性（Eventual Consistency）：指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态。</li>
</ul></li>
<li><p>一致性模型</p>
<ul>
<li><p>数据的一致性模型可以分成以下 3 类：</p>
<ul>
<li>强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。</li>
<li>弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。</li>
<li>最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>分布式系统数据的强一致性、弱一致性和最终一致性可以通过Quorum NRW算法分析。</p>

<h2 id="toc_2">分布式事务解决方案</h2>

<h3 id="toc_3">2PC方案——强一致性</h3>

<p>2PC的核心原理是通过提交分阶段和记日志的方式，记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个状态节点重试，如Coordinator重启后，通过日志可以确定提交处于Prepare还是PrepareAll状态，若是前者，说明有节点可能没有Prepare成功，或所有节点Prepare成功但还没有下发Commit，状态恢复后给所有节点下发RollBack；若是PrepareAll状态，需要给所有节点下发Commit，数据库节点需要保证Commit幂等。</p>

<ul>
<li><p>2PC方案的问题：</p>
<ul>
<li>同步阻塞；</li>
<li>数据不一致；</li>
<li>单点问题。</li>
</ul></li>
<li><p>升级的3PC方案旨在解决这些问题，主要有两个改进：</p>
<ul>
<li>增加超时机制。</li>
<li>两阶段之间插入准备阶段。</li>
</ul></li>
</ul>

<p>但三阶段提交也存在一些缺陷，要彻底从协议层面避免数据不一致，可以采用Paxos或者Raft 算法。</p>

<h3 id="toc_4">eBay 事件队列方案——最终一致性</h3>

<p>eBay 的架构师Dan Pritchett，曾在一篇解释BASE 原理的论文《Base：An Acid Alternative》中提到一个eBay 分布式系统一致性问题的解决方案。它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。</p>

<p>描述的场景为，有用户表user 和交易表transaction，用户表存储用户信息、总销售额和总购买额，交易表存储每一笔交易的流水号、买家信息、卖家信息和交易金额。如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。</p>

<p>论文中提出的解决方法是将更新交易表记录和用户表更新消息放在一个本地事务来完成，为了避免重复消费用户表更新消息带来的问题，增加一个操作记录表updates_applied来记录已经完成的交易相关的信息。</p>

<p>这个方案的核心在于第二阶段的重试和幂等执行。失败后重试，这是一种补偿机制，它是能保证系统最终一致的关键流程。</p>

<h3 id="toc_5">TCC （Try-Confirm-Cancel）补偿模式——最终一致性</h3>

<p>某业务模型如图，由服务 A、服务B、服务C、服务D 共同组成的一个微服务架构系统。服务A 需要依次调用服务B、服务C 和服务D 共同完成一个操作。当服务A 调用服务D 失败时，若要保证整个系统数据的一致性，就要对服务B 和服务C 的invoke 操作进行回滚，执行反向的revert 操作。回滚成功后，整个微服务系统是数据一致的。</p>

<ul>
<li><p>实现关键要素：</p>
<ol>
<li>服务调用链必须被记录下来；</li>
<li>每个服务提供者都需要提供一组业务逻辑相反的操作，互为补偿，同时回滚操作要保证幂等；</li>
<li>必须按失败原因执行不同的回滚策略。</li>
</ol></li>
<li><p>实现难点：</p></li>
</ul>

<p>补偿模式的特点是实现简单，但是想形成一定程度的通用方案比较困难，特别是服务链的记录，因为大部分时候，业务参数或者业务逻辑千差万别。</p>

<p>另外，很多业务特征使得该服务无法提供一个安全的回滚操作。</p>

<h3 id="toc_6">缓存数据最终一致性</h3>

<p>在我们的业务系统中，缓存（Redis 或者Memcached）通常被用在数据库前面，作为数据读取的缓冲，使得I/O 操作不至于直接落在数据库上。以商品详情页为例，假如卖家修改了商品信息，并写回到数据库，但是这时候用户从商品详情页看到的信息还是从缓存中拿到的过时数据，这就出现了缓存系统和数据库系统中的数据不一致的现象。</p>

<ul>
<li>要解决该场景下缓存和数据库数据不一致的问题我们有以下两种解决方案：</li>
</ul>

<p>为缓存数据设置过期时间。当缓存中数据过期后，业务系统会从数据库中获取数据，并将新值放入缓存。这个过期时间就是系统可以达到最终一致的容忍时间。</p>

<p>更新数据库数据后同时清除缓存数据。数据库数据更新后，同步删除缓存中数据，使得下次对商品详情的获取直接从数据库中获取，并同步到缓存。</p>

<blockquote>
<p>选择建议</p>
</blockquote>

<p>在面临数据一致性问题的时候，首先要从业务需求的角度出发，确定我们对于3 种一致性模型的接受程度，再通过具体场景来决定解决方案。</p>

<p>从应用角度看，分布式事务的现实场景常常无法规避，在有能力给出其他解决方案前，2PC也是一个不错的选择。</p>

<p>对购物转账等电商和金融业务，中间件层的2PC最大问题在于业务不可见，一旦出现不可抗力或意想不到的一致性破坏，如数据节点永久性宕机，业务难以根据2PC的日志进行补偿。金融场景下，数据一致性是命根，业务需要对数据有百分之百的掌控力，建议使用TCC这类分布式事务模型，或基于消息队列的柔性事务框架，这两种方案都在业务层实现，业务开发者具有足够掌控力，可以结合SOA框架来架构，包括Dubbo、Spring Cloud等。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式系统常见的事务处理机制]]></title>
    <link href="https://books.sangkf.cn/15511041776834.html"/>
    <updated>2019-02-25T22:16:17+08:00</updated>
    <id>https://books.sangkf.cn/15511041776834.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>为保障系统的可用性、可靠性以及性能，在分布式系统中，往往会设置数据冗余，即对数据进行复制。举例来说，当一个数据库的副本被破环以后，那么系统只需要转换到其他数据副本就能继续运行下去。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">引述</h2>

<p>为保障系统的可用性、可靠性以及性能，在分布式系统中，往往会设置数据冗余，即对数据进行复制。举例来说，当一个数据库的副本被破环以后，那么系统只需要转换到其他数据副本就能继续运行下去。<br/>
另外一个例子，当访问单一服务器管理的数据的进程数不断增加时，系统就需要对服务器的数量进行扩充，此时，对服务器进行复制，随后让它们分担工作负荷，就可以提高性能。但同时，如何保障多个数据节点之间数据的一致以及如何处理分布式事务，将成为为一个复杂的话题。本文将介绍常用的事务处理机制。</p>

<h2 id="toc_1">CAP 定理</h2>

<p>CAP 定理（也称为 Brewer 定理），是由计算机科学家 Eric Brewer 提出的，即在分布式计算机系统不可能同时提供以下全部三个保证：</p>

<ul>
<li><p><strong>一致性</strong>（Consistency）：所有节点同一时间看到是相同的数据；</p></li>
<li><p><strong>可用性</strong>（Availability）：不管是否成功，确保每一个请求都能接收到响应；</p></li>
<li><p><strong>分区容错性</strong>（Partition tolerance）：系统任意分区后，在网络故障时，仍能操作</p></li>
</ul>

<p>显然，为了保障性能和可靠性，我们将数据复制多份，分布到多个节点上，同时也带来了一个难点，那就是如何保持各个副本数据的一致性。换句话说，我们选择了 AP ，则必须要牺牲掉 C 了。</p>

<p>但是，在实际的应用场景中，数据的一致性往往也是需要保证的。那么这是否违背了 CAP 定理呢？</p>

<h2 id="toc_2">一致性模型</h2>

<p>其实，数据的一致性也分几种情况，大致可以分为：</p>

<ul>
<li><p>Weak 弱一致性：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些存储系统，搜索引擎，实时游戏，语音聊天等，这些数据本文对完整性要求不高，数据是否一致关系也不大。</p></li>
<li><p>Eventually 最终一致性：当你写入一个新值后，并不一定能马上读出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件，消息中间件等系统，大部分分布式系统技术都采用这类模式。</p></li>
<li><p>Strong 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS都是强一致性的。</p></li>
</ul>

<p>也就是说，在设计分布式系统时，我们并不一定要求是强一致性的，根据应用场景可以选择弱一致性或者是最终一致性。</p>

<h2 id="toc_3">事务的作用</h2>

<p>事务有如下作用：</p>

<ul>
<li><p>保证执行结果的正确性</p></li>
<li><p>保证数据的一致性</p></li>
<li><p>ACID</p></li>
</ul>

<h2 id="toc_4">常见的事务处理机制</h2>

<h3 id="toc_5">Master-Slave 复制</h3>

<p>Slave 一般是 Master 的备份。在这样的系统中，一般是如下设计的：</p>

<ul>
<li><p>读写请求都由 Master 负责。</p></li>
<li><p>写请求写到 Master 上后，由 Master 同步到 Slave 上。</p></li>
</ul>

<p>这种机制的特点是：</p>

<ul>
<li><p>数据同步通常是异步的</p></li>
<li><p>有良好的吞吐量，低延迟 *　在大多数　RDBMS　中支持，比如　MySQL二进制日志</p></li>
<li><p>弱/最终一致性</p></li>
</ul>

<p>这种机制的缺点是，如果 Master 挂了，Slave 只能提供读服务，而没有写服务。</p>

<h3 id="toc_6">Master-Master 多主复制</h3>

<p>指一个系统存在两个或多个Master，每个Master都提供读写服务。这个机制是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。 Master-Master的好处是，一台Master挂了，别的Master可以正常做读写服务，他和Master-Slave一样，当数据没有被复制到别的Master上时，数据会丢失。很多数据库都支持Master-Master的Replication的机制。</p>

<p>这种机制的特点是：</p>

<ul>
<li><p>异步</p></li>
<li><p>最终的一致性</p></li>
<li><p>多个节点间需要序列化协议</p></li>
</ul>

<h3 id="toc_7">两阶段提交</h3>

<p>两阶段提交协议 （Two-phase commit protocol，2PC）的过程涉及到协调者和参与者。协调者可以看做成事务的发起者，同时也是事务的一个参与者。对于一个分布式事务来说，一个事务是涉及到多个参与者的。具体的两阶段提交的过程如下：</p>

<h4 id="toc_8">第一阶段（准备阶段）</h4>

<ul>
<li><p>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p></li>
<li><p>参与者节点执行询问发起为止的所有事务操作，并将 Undo 信息和 Redo 信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p></li>
<li><p>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个“同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个“中止”消息。</p></li>
</ul>

<h4 id="toc_9">第二阶段（提交阶段）</h4>

<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p>

<ul>
<li><p>当协调者节点从所有参与者节点获得的相应消息都为“同意”时:</p></li>
<li><p>协调者节点向所有参与者节点发出“正式提交(commit)”的请求。</p></li>
<li><p>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</p></li>
<li><p>参与者节点向协调者节点发送“完成”消息。</p></li>
<li><p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p></li>
<li><p>协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</p></li>
<li><p>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p></li>
<li><p>参与者节点向协调者节点发送”回滚完成”消息。</p></li>
<li><p>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p></li>
<li><p>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务</p></li>
</ul>

<p>不管最后结果如何，第二阶段都会结束当前事务。</p>

<p>二段式提交协议的优缺点：</p>

<p>优点：原理简单，实现方便；</p>

<p>缺点：</p>

<ul>
<li><p>同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。</p></li>
<li><p>单点故障。由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。</p></li>
<li><p>数据不一致。在阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到 commit 请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p></li>
<li><p>二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p></li>
</ul>

<p>为了解决两阶段提交协议的种种问题，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p>

<h4 id="toc_10">三阶段提交</h4>

<p>三阶段提交协议（Three-phase commit protocol，3PC），是二阶段提交（2PC）的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点：</p>

<ul>
<li><p>引入超时机制。同时在协调者和参与者中都引入超时机制。</p></li>
<li><p>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</p></li>
</ul>

<p>即 3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。</p>

<h4 id="toc_11">CanCommit 阶段</h4>

<p>CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p>

<ul>
<li><p>事务询问：协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p></li>
<li><p>响应反馈：参与者接到 CanCommit 请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No</p></li>
</ul>

<h4 id="toc_12">PreCommit 阶段</h4>

<p>协调者根据参与者的反应情况来决定是否可以记性事务的 PreCommit 操作。根据响应情况，有以下两种可能。</p>

<ul>
<li><p>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。</p></li>
<li><p>发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入Prepared 阶段。</p></li>
<li><p>事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将undo 和 redo 信息记录到事务日志中。</p></li>
<li><p>响应反馈：如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。</p></li>
<li><p>假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p></li>
<li><p>发送中断请求：协调者向所有参与者发送 abort 请求。</p></li>
<li><p>中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p></li>
</ul>

<h4 id="toc_13">doCommit 阶段</h4>

<p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>

<ul>
<li><p>执行提交</p></li>
<li><p>发送提交请求：协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。</p></li>
<li><p>事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p></li>
<li><p>响应反馈：事务提交完之后，向协调者发送 ACK 响应。</p></li>
<li><p>完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。</p></li>
<li><p>中断事务：协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。</p></li>
<li><p>发送中断请求：协调者向所有参与者发送 abort 请求</p></li>
<li><p>事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p></li>
<li><p>反馈结果：参与者完成事务回滚之后，向协调者发送 ACK 消息</p></li>
<li><p>中断事务：协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。</p></li>
</ul>

<p>在 doCommit 阶段，如果参与者无法及时接收到来自协调者的 doCommit 或者 rebort 请求时，会在等待超时之后，会继续进行事务的提交。即当进入第三阶段时，由于网络超时等原因，虽然参与者没有收 到 commit 或者 abort 响应，事务仍然会提交。</p>

<p>三阶段提交不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作，这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。</p>

<h3 id="toc_14">Paxos 算法</h3>

<p>Paxos 算法是 Leslie Lamport 于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法。Paxos 算法目前在 Google 的 Chubby、MegaStore、Spanner 等系统中得到了应用，Hadoop 中的 ZooKeeper 也使用了 Paxos 算法。</p>

<p>在 Paxos 算法中，分为4种角色：</p>

<ul>
<li><p>Proposer ：提议者</p></li>
<li><p>Acceptor：决策者</p></li>
<li><p>Client：产生议题者</p></li>
<li><p>Learner：最终决策学习者</p></li>
</ul>

<p>算法可以分为两个阶段来执行：</p>

<h4 id="toc_15">阶段1</h4>

<ul>
<li><p>Proposer 选择一个议案编号 n，向 acceptor 的多数派发送编号也为 n 的 prepare 请求。</p></li>
<li><p>Acceptor：如果接收到的 prepare 请求的编号 n 大于它已经回应的任何prepare 请求，它就回应已经批准的编号最高的议案（如果有的话），并承诺不再回应任何编号小于 n 的议案；</p></li>
</ul>

<h4 id="toc_16">阶段2</h4>

<ul>
<li><p>Proposer：如果收到了多数 acceptor 对 prepare 请求（编号为 n）的回应，它就向这些 acceptor 发送议案{n, v}的 accept 请求，其中 v 是所有回应中编号最高的议案的决议，或者是 proposer 选择的值，如果回应说还没有议案。</p></li>
<li><p>Acceptor：如果收到了议案{n, v}的 accept 请求，它就批准该议案，除非它已经回应了一个编号大于 n 的议案。</p></li>
<li><p>Proposer 可以提出多个议案，只要它遵循上面的算法。它可以在任何时刻放弃一个议案。（这不会破坏正确性，即使在议案被放弃后，议案的请求或者回应消息才到达目标）如果其它的 proposer 已经开始提出更高编号的议案，那么最好能放弃当前的议案。因此，如果 acceptor 忽略一个 prepare 或者 accept 请求（因为已经收到了更高编号的 prepare 请求），它应该告知 proposer 放弃议案。这是一个性能优化，而不影响正确性。</p></li>
</ul>

<h2 id="toc_17">参考文献</h2>

<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf">http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf</a></li>
<li><a href="https://www.oschina.net/question/2720166_2235329">https://www.oschina.net/question/2720166_2235329</a></li>
<li><a href="https://github.com/waylau/distributed-systems-technologies-and-cases-analysis">《分布式系统常用技术及案例分析》</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[😋 技术必备基础知识]]></title>
    <link href="https://books.sangkf.cn/15511034481464.html"/>
    <updated>2019-02-25T22:04:08+08:00</updated>
    <id>https://books.sangkf.cn/15511034481464.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本项目包含了技术面试必备的基础知识，浅显易懂，你不需要花很长的时间去阅读和理解成堆的技术书籍就可以快速掌握这些知识，从而节省宝贵的面试复习时间。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>本项目包含了技术面试必备的基础知识，浅显易懂，你不需要花很长的时间去阅读和理解成堆的技术书籍就可以快速掌握这些知识，从而节省宝贵的面试复习时间。你也可以阅读 <a href="https://github.com/CyC2018/Backend-Interview-Guide">面试进阶指南</a>，包含了学习指导和面试技巧，让你更轻松拿到满意的 Offer。</p>

<h2 id="toc_0">✏️ 算法</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md">剑指 Offer 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode%20%E9%A2%98%E8%A7%A3.md">Leetcode 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%AE%97%E6%B3%95.md">算法</a></li>
</ul>

<h2 id="toc_1">💻 操作系统</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md">计算机操作系统</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Linux.md">Linux</a></li>
</ul>

<h2 id="toc_2">☁️ 网络</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md">计算机网络</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md">HTTP</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Socket.md">Socket</a></li>
</ul>

<h2 id="toc_3">🎨 面向对象</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md">设计模式</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md">面向对象思想</a></li>
</ul>

<h2 id="toc_4">💾 数据库</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">数据库系统原理</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md">SQL</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md">Leetcode-Database 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md">MySQL</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md">Redis</a></li>
</ul>

<h2 id="toc_5">☕️ Java</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md">Java 基础</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md">Java 容器</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md">Java 并发</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md">Java 虚拟机</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md">Java I/O</a></li>
</ul>

<h2 id="toc_6">💡 系统设计</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md">系统设计基础</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md">分布式</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9B%86%E7%BE%A4.md">集群</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md">攻击技术</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md">缓存</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md">消息队列</a></li>
</ul>

<h2 id="toc_7">🔧 工具</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Git.md">Git</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Docker.md">Docker</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md">构建工具</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md">正则表达式</a></li>
</ul>

<h2 id="toc_8">🍉 编码实践</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.md">代码可读性</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.md">代码风格规范</a></li>
</ul>

<blockquote>
<p>原文地址 <a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式事务]]></title>
    <link href="https://books.sangkf.cn/15510945917129.html"/>
    <updated>2019-02-25T19:36:31+08:00</updated>
    <id>https://books.sangkf.cn/15510945917129.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>解决分布式事务的最好办法其实就是不考虑分布式事务，将一个大的业务进行拆分，整个大的业务流程，转化成若干个小的业务流程，然后通过设计补偿流程从而考虑最终一致性。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">概述</h2>

<p>分布式事务场景如何设计系统架构及解决数据一致性问题，个人理解最终方案把握以下原则就可以了，那就是：大事务=小事务（原子事务）+异步（消息通知），<br/>
<strong>解决分布式事务的最好办法其实就是不考虑分布式事务，将一个大的业务进行拆分，整个大的业务流程，转化成若干个小的业务流程，然后通过设计补偿流程从而考虑最终一致性。</strong></p>

<h4 id="toc_1">What’s 事务</h4>

<p>事务（Transaction）及其ACID属性</p>

<p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性：</p>

<ul>
<li>原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li>隔离性（Isoation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li>持久性（Durabe）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>

<h4 id="toc_2">典型场景：银行转账业务</h4>

<p>例如：李雷账户中有500块钱，韩梅梅账户有200块钱，李雷要从自己的账户中转100块钱给韩梅梅，转账（事务）成功执行完成后应该是李雷账户减100变为400，韩梅梅账户加100变为300，不能出现其他情况，即在事务开始和结束时数据都必须保持一致状态（一致性），事务结束时所有的数据及结构都必须是正确的。并且同样的转账操作（同一流水，即一次转账操作）无论执行多少次结果都相同（幂等性）。</p>

<h4 id="toc_3">电商场景：流量充值业务</h4>

<p>再说我们做的一个项目：中国移动-流量充值能力中心，核心业务流程为：</p>

<pre><code class="language-text">  1. 用户进入流量充值商品购买页面，选择流量商品；
  2. 购买流量充值商品，有库存限制则判断库存，生成流量购买订单；
  3. 选择对应的支付方式（和包、银联、支付宝、微信）进行支付操作；
  4. 支付成功后，近实时流量到账即可使用流量商品；

</code></pre>

<p>此业务流程看似不是很复杂对吧，不涉及到类似电商业务的实物购买，但是我认为其中的区别并不是很大，只是缺少电商中的物流发货流程，其他流程几乎是一样的，也有库存以及优惠折扣等业务存在。</p>

<p>整个系统交互如下图：</p>

<p><img src="media/15510945917129/15510949905392.png" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<h4 id="toc_4">分布式事务</h4>

<p>上述两个场景的业务需求已经说完了，接着谈谈分布式事务，要说分布式事务那就先聊聊本地事务与分布式事务：</p>

<p>Ps：相同点：首先都是要保证数据正确（即ACID），本地事务与分布式事务还可以对应为：刚性事务与柔性事务，在我个人理解刚性事务与柔性事务的最大区别就是：一个完整的事务操作是否可以在同一物理介质（例如：内存）上同时完成；柔性事务就是一个完整事务需要跨物理介质或跨物理节点（网络通讯），那么排它锁、共享锁等等就没有用武之地了（这里并不是指大事务拆小事务【本地事务】后），无法保证原子性（Atomicity）完成事务。个人理解分布式（柔性）事务本质意义上就是-伪事务，柔性事务其实就是根据不同的业务场景使用不同的方法实现最终一致性，因为可以根据业务的特性做部分取舍，在业务过程中可以容忍一定时间内的数据不一致。</p>

<p>在知乎上面看过一篇文章，支付宝的柔性事务实现方式有四种分别针对不同的业务场景，如下图：</p>

<p><img src="media/15510945917129/2.png" alt="image" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<ol>
<li>两阶段型</li>
<li>补偿型</li>
<li>异步确保型</li>
<li>最大努力通知型</li>
</ol>

<p>回到我们流量交易中心的业务场景：</p>

<p>通过Dubbo实现了微服务化，大致拆分如下：</p>

<ol>
<li>商品服务</li>
<li>订单服务</li>
<li>库存服务</li>
<li>支付服务</li>
<li>直充服务</li>
<li>消息服务</li>
<li>等其他服务</li>
</ol>

<h4 id="toc_5">场景一：</h4>

<p>库存数量与订单数量一致性，采用补偿型+最大努力通知型，采用原因为不涉及跨机房和长事务（正常情况下库存与订单服务处理很快）：</p>

<ol>
<li>用户下单先减库存，库存减成功后；</li>
<li>调用下单服务：</li>
<li>2-1. 下单成功，两事务均提交完成；</li>
<li>2-2. 下单失败，库存回滚，两事务均失败，此处还有一个保障机制（最大努力通知型），就是如果调用库存服务异常，确定库存回滚失败了，则放入消息服务（延时消息队列）分阶段定时重试，努力重试保证库存服务正常后成功回滚。</li>
</ol>

<h4 id="toc_6">场景二：</h4>

<p>订单信息、支付信息、充值信息三者之间的一致性，采用异步确保型的原因是，整个业务链路太长且跨不同的机房系统，网络延迟较高，业务方面恰好不需要非常高的实时性，所以采用小事务+异步通知，目前正常情况下用户从下单到完成支付到流量到账平均为1-5分钟左右：</p>

<ol>
<li>下单成功即订单服务创建订单成功并发送支付请求到支付网关系统（订单状态-待支付，超过1小时未支付则流转为超时未付撤销，此处用到了RocketMQ的延时消费恰好实现定时器业务场景）。</li>
<li>返回支付页面，用户在支付交易系统完成支付业务流程，支付网关异步通知流量中心，流量中心接收到支付成功状态后修改订单状态-支付成功，并给支付网关返回成功结果（此处并发压力目前不大，暂时没有再进行异步解耦）。</li>
<li>流量中心修改完订单状态后，调用消息服务将直充业务放入消息队列，对直充业务进行解耦（原因是直充需要调用31省移动CRM系统，此链路过长，且部分省CRM系统耗时非常大，每个省的处理能力不同，经常出现20秒以上的超时，因此要考虑部分超时较高的省份拖垮系统，进行业务的削峰填谷）；</li>
<li>3-1. 当直充成功时，修改订单状态-已完成；</li>
<li>3-2. 当直充失败时（移动特性，例如：直充时正好用户销户或者停机了），修改订单状态为待退款，并调用支付网关系统的退款接口，退款成功后支付网关异步通知流量中心，流量中心修改订单状态为-退款成功；</li>
<li>3-3. 当直充超时时，调用定时任务服务进行超时重试机制（第一次重试在10分钟后执行、第二次在30分钟后、第三次…..），直到最大超时重试次数后还得不到直充结果，订单状态会卡在支付成功状态，依赖T+1对账稽核流程保证最终一致性，订单状态根据对账结果流转为：已完成或待退款–&gt;退款成功。</li>
</ol>

<h4 id="toc_7">场景三：</h4>

<p>直充到账后的消息通知（APP消息推送或短信通知），采用最大努力通知型，这个业务场景比较简单，在直充成功后，订单状态流转为已完成，此时通过消息服务进行到账通知业务的解耦，调用消息服务失败的情况下，使用定时任务努力通知。</p>

<h4 id="toc_8">场景四：</h4>

<p><strong>对账稽核：</strong></p>

<p>按照支付账期每日进行T+1对账，对账原则：以支付交易记录为准，对流量中心订单记录+支付网关交易记录+省CRM充值记录三方比对，将某些中间状态的订单（例如：支付成功、待退款）核对后将订单状态流转完结（已完成、退款成功）。</p>

<p><strong>结算稽核：</strong></p>

<p>对账成功后的数据定期进入结算流程，对支付网关周期内的支付金额与结算数据的金额进行核对，稽核成功后进行财务结算流程，将钱结算给省公司，并提供结算明细给省公司，供省公司与直充成本记录进行复核。 Ps：以下是流量中心的部分架构设计，总体原则方向：微服务化</p>

<p><strong>流量中心-架构设计</strong></p>

<p><img src="media/15510945917129/3.png" alt="image" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>架构设计思想：在系统初期设计时以及部分硬性环境约束下，我们根据业务拆分为多个子系统（微服务）：商品服务、订单服务、库存服务、支付网关、统一接口平台、对账服务、结算服务、网关对接服务等，后续还会增加：账户服务、虚拟货币服务、卡券服务等等…。按照微服务的核心设计思想，所有服务完全独立、隔离，因此所有服务从上至下：请求接入（连接管理）、请求处理（计算服务）、数据存储（存储服务）进行拆分，接入与计算尽最大可能实现无状态，数据存储进行垂直+水平拆分，垂直拆分：商品库-mysql（读多写少，主从架构+读写分离）+redis（读多写少，集群方式）、订单库-mysql（读写均衡，多主多从+水平拆分）、库存专用库-redis（分布式+主备容灾）、外部交易系统-支付网关、外部办理系统-统一接口平台。</p>

<p>Ps：此架构目前已支撑总交易额3.6亿，总订单4680万，日均交易额500万，日订单量50万，后续业务量持续增加的情况下按照微服务思想继续拆分，例如将订单服务再拆分为：下单服务、查单服务，直到根据业务需求与系统关系耦合性拆分到最细粒度为止。</p>

<ol>
<li>性能扩展：应用层计算服务（无状态应用）通过增加服务节点同比提升运算性能，配套质量（性能）监控服务dubbo monitor及整合Netflix的Hystrix熔断器对业务质量进行管理实现应用层的动态扩缩容。</li>
<li>容量扩展：数据层存储服务（有状态应用）通过对数据水平拆分实现容量的无限扩容，Nosql类方案：Codis中间件；关系型数据库：Mycat数据库分库分表中间件。目前项目中采用twitter的snowflake唯一ID生成器（根据业务场景优化后）自己实现数据的水平拆分和路由规则。</li>
<li>存储性能：Nosql：针对读多写少场景-使用淘宝的Tedis（多写随机读的特性提高性能），读写均衡使用-Codis；Mysql：读多写少场景使用一主多从架构（例如商品信息），读写均衡场景使用多主多从架构（例如订单信息）。</li>
</ol>

<p><strong>整体拆分原则如下图：</strong></p>

<p><img src="media/15510945917129/4.png" alt="image" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事务]]></title>
    <link href="https://books.sangkf.cn/15510944838066.html"/>
    <updated>2019-02-25T19:34:43+08:00</updated>
    <id>https://books.sangkf.cn/15510944838066.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>原子性、一致性、隔离性、持久性是事务的四个基本特性。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">事务特性</h2>

<p>原子性、一致性、隔离性、持久性，这四个属性通常称为ACID特性。</p>

<ul>
<li>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
<li>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
<li>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ul>

<h2 id="toc_1">分布式事务</h2>

<ul>
<li><a href="15510945917129.html">分布式事务</a></li>
<li><a href="15511041776834.html">分布式系统常见的事务处理机制</a></li>
<li><a href="15511042581022.html">微服务架构下处理分布式事务的典型方案</a></li>
<li>解决分布式系统事务一致性的几种方案对比</li>
<li>多库多事务降低数据不一致概率</li>
<li>蚂蚁技术专家：一篇文章带你学习分布式事务</li>
</ul>

<h2 id="toc_2">开源框架</h2>

<ul>
<li>tcc-transaction是TCC型事务java实现</li>
<li>TCC分布式事务的实现原理</li>
<li>分布式事务 TCC-Transaction 源码分析 —— Dubbo 支持</li>
<li>分布式事务 TCC-Transaction 源码分析 —— 项目实战</li>
<li>GTS来了！阿里微服务架构下的分布式事务解决方案</li>
<li>Atomikos</li>
<li>微服务架构下分布式事务解决方案 —— 阿里GTS</li>
<li>ByteJTA是一个兼容JTA规范的基于XA/2PC的分布式事务管理器</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 生态圈知识汇总]]></title>
    <link href="https://books.sangkf.cn/15510844326202.html"/>
    <updated>2019-02-25T16:47:12+08:00</updated>
    <id>https://books.sangkf.cn/15510844326202.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>多读书、多看报，多研究常用开源框架的源码，比如：github.com，这里汇集了全球工程师的智慧！</p>
</blockquote>

<span id="more"></span><!-- more -->

<h3 id="toc_0">前言</h3>

<p>有人认为编程是一门技术活，要有一定的天赋，非天资聪慧者不能及也。其实不然，笔者虽是计算机专业出身，但工作年限并不长，对于技术这碗饭有一些心得体会，大多数人成为某领域顶级专家可能会有些难度，但应对日常工作，成长为资深研发工程师、技术专家、甚至成为小团队的Team Leader，其实并不难。</p>

<p><strong>多读书、多看报，多研究常用开源框架的源码，比如：github.com，这里汇集了全球工程师的智慧！</strong></p>

<p>言归正传，下文会列举工作中常用的一些技术，以及如何锻炼提升自己的架构能力。</p>

<p>由于每块技术市场上基本都有对应的网络资料或书籍，所以本文只是少篇幅列举工作中用到的核心知识点，抛砖引玉，属于进阶型，不适用初学者。</p>

<h3 id="toc_1"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"></a>基础知识</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fjava.md">java</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspring.md">spring</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspringboot.md">spring boot</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspringcloud.md">spring cloud</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fibatis.md">ibatis</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2F%25E5%25B8%25B8%25E7%2594%25A8%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F.md">设计模式</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2FLog4j.md">Log日志</a></li>
</ul>

<h3 id="toc_2"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E6%95%B0%E6%8D%AE%E5%BA%93"></a>数据库</h3>

<p>目前使用最多还是mysql，虽然单机性能比不上oracle，但免费开源，单机成本低且借助于分布式集群，可以有强大的输出能力。</p>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fdatabase-connection-pool.md">连接池</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Ftransaction.md">事务</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2F%25E5%2588%2586%25E5%25BA%2593%25E5%2588%2586%25E8%25A1%25A8.md">分库分表</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fid-generate.md">id生成器</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F6909240">读写分离</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fsql-optimize.md">SQL调优</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fother.md">其它</a></li>
</ul>

<h3 id="toc_3"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#web%E5%AE%B9%E5%99%A8%E5%8D%8F%E8%AE%AE%E7%BD%91%E7%BB%9C"></a>web容器/协议/网络</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fload-balance.md">负载均衡</a></li>
<li>服务器
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2FNginx.md">Nginx</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Ftomcat.md">Tomcat</a></li>
</ul></li>
<li>协议
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fhttp%25E5%258D%258F%25E8%25AE%25AE.md">HTTP 协议</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Ftcp.md">TCP 协议</a></li>
</ul></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2FCDN.md">CDN</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fother.md">其它</a></li>
</ul>

<h3 id="toc_4"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E5%8C%85"></a>常用三方工具包</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FGoole-Guava.md">Google Guava</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FfastJson.md">fastJson</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F17913607">log4J</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-codec.md">commons-codec</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-lang3.md">commons-lang3</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-io.md">commons-io</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FQuartz.md">Quartz</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FHttpClient.md">HttpClient</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F7671294">Javassist</a></li>
</ul>

<h3 id="toc_5"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E4%B8%AD%E9%97%B4%E4%BB%B6"></a>中间件</h3>

<ul>
<li><p>RPC框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fdubbo.md">dubbo</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fdubbox">dubbox</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fweibocom%2Fmotan">motan</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fapache%2Fthrift">Thrift</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Frpc-compare.md">RPC框架性能比较</a></li>
</ul></li>
<li><p>MQ消息</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fapache%2Factivemq">ActiveMQ</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FRabbitMQ.md">RabbitMQ</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fkafka.md">Kafka</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FRocketMQ.md">RocketMQ</a></li>
</ul></li>
<li><p>分布式缓存</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fredis.md">redis</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster">codis</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F8035197">memcache</a></li>
</ul></li>
<li><p>本地缓存</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fguava.md">Guava</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fehcache.md">ehcache</a></li>
</ul></li>
<li><p>搜索</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Felasticsearch.md">Elasticsearch</a></li>
</ul></li>
<li><p>分布式数据框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fcobar.md">cobar</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fmycat.md">Mycat</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Ftsharding.md">tsharding</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Ftb_tddl">tddl</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fsharding-jdbc.md">sharding-jdbc</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgitee.com%2Frobertleepeak%2Fdbsplit">dbsplit</a></li>
</ul></li>
<li><p>分布式协调服务</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fzookeeper.md">zookeeper</a></li>
</ul></li>
<li><p>配置管理</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fsuper-diamond%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590.md">super-diamond</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fdisconf">disconf</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fapollo.md">apollo</a></li>
</ul></li>
<li><p>分布式文件系统</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FFastDFS.md">FastDFS</a></li>
</ul></li>
<li><p>分布式任务调度框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Felasticjob%2Felastic-job">Elastic-Job</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Fdangdang-distributed-work-framework-elastic-job">详解当当网的分布式作业框架elastic-job</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Ftaosir_zhang%2Farticle%2Fdetails%2F50728362">TBSchedule</a></li>
</ul></li>
<li><p>大数据</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHbase.md">Hbase</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FSpark.md">Spark</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHadoop.md">Hadoop</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHive.md">Hive</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fbig-data.md">other框架</a></li>
</ul></li>
<li><p>其它</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fcanal">数据库binlog的增量订阅&amp;消费组件</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fotter">数据库同步系统</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FTCC-Transaction.md">TCC-Transaction</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FNetty.md">Netty</a></li>
</ul></li>
</ul>

<h3 id="toc_6"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"></a>系统架构</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Farchitecture-experience.md">架构经验</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Farchitecture-good-case.md">经典案例</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Ftechnology-selection.md">通用技术方案选型</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2F%25E7%25BC%2596%25E7%25A0%2581%25E5%2589%258D3000%25E9%2597%25AE.md">编码前3000问</a></li>
</ul>

<h3 id="toc_7"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"></a>项目管理</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2F%25E8%25AE%25BA%25E9%259C%2580%25E6%25B1%2582%25E8%25B0%2583%25E7%25A0%2594%25E7%259A%2584%25E9%2587%258D%25E8%25A6%2581%25E6%2580%25A7.md">论需求调研的重要性</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Fproject-management.md">项目管理</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Fcode.md">代码管理</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Ftest.md">测试相关</a></li>
</ul>

<h3 id="toc_8"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E8%BF%90%E7%BB%B4"></a>运维</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Fonline-question.md">快速排查线上问题</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Flinux-commands.md">linux常用命令</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2F%25E6%259C%25AC%25E5%259C%25B0%25E4%25BB%25A3%25E7%25A0%2581%25E8%25B0%2583%25E8%25AF%2595.md">本地代码调试</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Fdocker.md">Docker</a></li>
</ul>

<h3 id="toc_9"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF"></a>个人成长</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fstudy.md">学习网站</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fbook.md">Tom哥的读书单</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fperson.md">个人成长与职业规划</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fprogramer.md">程序员素养</a></li>
</ul>

<h3 id="toc_10"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%85%B6%E5%AE%83"></a>其它</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Ftool.md">常用软件工具</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2F%25E4%25B8%2580%25E8%2587%25B4%25E6%2580%25A7hash.md">一致性hash算法</a></li>
<li>面试
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fjava-interview.md">java面试题</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fbigdata-interview.md">大数据面试题</a></li>
</ul></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2F%25E5%259B%259E%25E8%25BD%25A6%25E4%25B8%258E%25E6%258D%25A2%25E8%25A1%258C%25E7%259A%2584%25E5%258C%25BA%25E5%2588%25AB.md">回车与换行的区别</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fqq1332479771%2Farticle%2Fdetails%2F56087333">github上fork项目后，如何同步更新后面提交</a></li>
</ul>

<p>[<strong>原文地址</strong>]：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk">github.com/aalansehaiy…</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[限流设计]]></title>
    <link href="https://books.sangkf.cn/15510821177382.html"/>
    <updated>2019-02-25T16:08:37+08:00</updated>
    <id>https://books.sangkf.cn/15510821177382.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>限流，书面意思和作用一致，就是为了限制，通过对并发访问或者请求进行限速或者一个时间窗口内的请求进行限速来保护系统。一旦达到了限制的临界点，可以用拒绝服务、排队、或者等待的方式来保护现有系统，不至于发生雪崩现象。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>限流就像做帝都的地铁一般，如果你住在西二旗或者天通苑也许会体会的更深刻一些。我更习惯在技术角度用消费者的角度来阐述，需要限流的一般原因是消费者能力有限，目的为了避免超过消费者能力而出现系统故障。当然也有其他类似的情况也可以用限流来解决。</p>

<p>限流的表现形式上大部分可以分为两大类：</p>

<ul>
<li>限制消费者数量。也可以说消费的最大能力值。比如：数据库的连接池是侧重的是总的连接数，本质上也是限制了消费者的最大消费能力。</li>
<li>可以被消费的请求数量。这里的数量可以是瞬时并发数，也可以是一段时间内的总并发数。</li>
</ul>

<p>除此之外，限流还有别的表现形式，例如按照网络流量来限流，按照cpu使用率来限流等。按照限流的范围又可以分为分布式限流，应用限流，接口限流等。无论怎么变化，限流都可以用以下图来表示：</p>

<p><img src="media/15510821177382/15510824198802.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_0">常用技术实现</h2>

<ul>
<li>令牌桶算法<br/>
令牌桶是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌，填满了就丢弃令牌，请求是否被处理要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求。令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌。令牌桶中装的是令牌。
<img src="media/15510821177382/15510825111049.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></li>
<li><p>漏桶算法<br/>
漏桶一个固定容量的漏桶，按照固定常量速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝。漏桶可以看做是一个具有固定容量、固定流出速率的队列，漏桶限制的是请求的流出速率。漏桶中装的是请求。</p></li>
<li><p>计数器<br/>
 有时我们还会使用计数器来进行限流，主要用来限制一定时间内的总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流，是一种简单粗暴的总数量限流，而不是平均速率限流。</p></li>
</ul>

<h2 id="toc_1">不用算法的解决方案</h2>

<p>我们可以用一个按照时间段限制请求总数的方式来限流。 总体思路是这样：</p>

<ul>
<li>用一个环形来代表通过的请求容器。</li>
<li>用一个指针指向当前请求所到的位置索引，来判断当前请求时间和当前位置上次请求的时间差，依此来判断是否被限制。</li>
<li>如果请求通过，则当前指针向前移动一个位置，不通过则不移动位置</li>
<li>重复以上步骤 直到永远.......</li>
</ul>

<p><img src="media/15510821177382/15510827864849.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_2">核心代码</h2>

<blockquote>
<p>以下代码的核心思路是这样的：指针当前位置的时间元素和当前时间的差来决定是否允许此次请求，这样通过的请求在时间上表现的比较平滑。</p>
</blockquote>

<pre><code class="language-java">//限流组件,采用数组做为一个环
    class LimitService
    {
        //当前指针的位置
        int currentIndex = 0;
        //限制的时间的秒数，即：x秒允许多少请求
        int limitTimeSencond = 1;
        //请求环的容器数组
        DateTime?[] requestRing = null;
        //容器改变或者移动指针时候的锁
        object objLock = new object();

        public LimitService(int countPerSecond,int  _limitTimeSencond)
        {
            requestRing = new DateTime?[countPerSecond];
            limitTimeSencond= _limitTimeSencond;
        }

        //程序是否可以继续
        public bool IsContinue()
        {
            lock (objLock)
            {
                var currentNode = requestRing[currentIndex];
                //如果当前节点的值加上设置的秒 超过当前时间，说明超过限制
                if (currentNode != null&amp;&amp; currentNode.Value.AddSeconds(limitTimeSencond) &gt;DateTime.Now)
                {
                    return false;
                }
                //当前节点设置为当前时间
                requestRing[currentIndex] = DateTime.Now;
                //指针移动一个位置
                MoveNextIndex(ref currentIndex);
            }            
            return true;
        }
        //改变每秒可以通过的请求数
        public bool ChangeCountPerSecond(int countPerSecond)
        {
            lock (objLock)
            {
                requestRing = new DateTime?[countPerSecond];
                currentIndex = 0;
            }
            return true;
        }

        //指针往前移动一个位置
        private void MoveNextIndex(ref int currentIndex)
        {
            if (currentIndex != requestRing.Length - 1)
            {
                currentIndex = currentIndex + 1;
            }
            else
            {
                currentIndex = 0;
            }
        }
    }
</code></pre>

<p>测试程序如下：</p>

<pre><code class="language-java">static  LimitService l = new LimitService(1000, 1);
        static void Main(string[] args)
        {
            int threadCount = 50;
            while (threadCount &gt;= 0)
            {
                Thread t = new Thread(s =&gt;
                {
                    Limit();
                });
                t.Start();
                threadCount--;
            }           

            Console.Read();
        }

        static void Limit()
        {
            int i = 0;
            int okCount = 0;
            int noCount = 0;
            Stopwatch w = new Stopwatch();
            w.Start();
            while (i &lt; 1000000)
            {
                var ret = l.IsContinue();
                if (ret)
                {
                    okCount++;
                }
                else
                {
                    noCount++;
                }
                i++;
            }
            w.Stop();
            Console.WriteLine($&quot;共用{w.ElapsedMilliseconds},允许：{okCount},  拦截：{noCount}&quot;);
        }
</code></pre>

<p>测试结果如下：</p>

<p><img src="media/15510821177382/15510829240788.jpg" alt=""/><br/>
<img src="media/15510821177382/15510829535558.jpg" alt=""/><br/>
最大用时15秒,共处理请求1000000*50=50000000 次</p>

<p>并未发生GC操作，内存使用率非常低，每秒处理 300万次+请求 。以上程序修改为10个线程，大约用时4秒之内<br/>
<img src="media/15510821177382/15510829711440.jpg" alt=""/></p>

<p>如果是强劲的服务器或者线程数较少情况下处理速度将会更快</p>

<p>[<strong>转载</strong>]<a href="https://www.cnblogs.com/zhanlang/p/10424757.html">https://www.cnblogs.com/zhanlang/p/10424757.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JDK动态代理]]></title>
    <link href="https://books.sangkf.cn/15510682951931.html"/>
    <updated>2019-02-25T12:18:15+08:00</updated>
    <id>https://books.sangkf.cn/15510682951931.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>代理类的目的是为其他对象提供一个代理以控制对某个对象的访问。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">代理的含义</h2>

<ul>
<li>代理类的目的是为其他对象提供一个代理以控制对某个对象的访问。</li>
<li>代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</li>
<li>为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。</li>
<li>通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好的隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</li>
</ul>

<h2 id="toc_1">动态代理相关类介绍</h2>

<ol>
<li><p>InvocationHandler</p>
<pre><code class="language-text">每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联了一个Handler,当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的Invoke方法来进行调用。
</code></pre>
<p>InvocationHandler这个接口的唯一一个方法invoke方法:</p>
<pre><code class="language-java">Object invoke(Object proxy, Method method, Object[] args) throws Throwable
</code></pre>
<p>三个参数:</p>
<ul>
<li>proxy： 指代JDK动态生成的最终代理对象</li>
<li>method：指代的是我们所要调用真是对象的某个方法的Method对象</li>
<li>args: 指代的是调用真是对象的某个方法时接收的参数</li>
</ul></li>
<li><p>Proxy</p>
<p>​    Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法</p>
<pre><code class="language-java">public static Object newProxyInstance(ClassLoader loader,
                                         Class&lt;?&gt;[] interfaces,<br/>
                                         InvocationHandler h)<br/>
       throws IllegalArgumentException
</code></pre>
<p>这个方法的作用就是得到一个动态的代理对象，其接收三个参数，我们来看看这三个参数所代表的含义：</p>
<ul>
<li>loader:　一个ClassLoader对象，定义了由哪个ClassLoader来对生成的代理对象进行加载</li>
<li>interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</li>
<li>一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</li>
</ul>
<p>其实我们所说的DynamicProxy（动态代理类）是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些 interface。如此一来，我们可以把该class的实例当作这些interface中的任何一个来用（可以强转为相应的接口类型）。当然，这个DynamicProxy其实就是一个Proxy，它不会做实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</p></li>
</ol>

<p>[<strong>转载</strong>]<a href="https://blog.csdn.net/xiaokang123456kao/article/details/77679848">https://blog.csdn.net/xiaokang123456kao/article/details/77679848</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql大表优化方案]]></title>
    <link href="https://books.sangkf.cn/15510645880732.html"/>
    <updated>2019-02-25T11:16:28+08:00</updated>
    <id>https://books.sangkf.cn/15510645880732.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">单表优化方案</h2>

<p>除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量。</p>

<ol>
<li><p><strong>字段优化总结</strong></p>
<ul>
<li>尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED</li>
<li>VARCHAR的长度只分配真正需要的空间</li>
<li>使用枚举或整数代替字符串类型</li>
<li>尽量使用TIMESTAMP而非DATETIME</li>
<li>单表不要有太多字段，建议在20以内</li>
<li>避免使用NULL字段，很难查询优化且占用额外索引空间</li>
<li>用整型来存IP</li>
</ul></li>
<li><p><strong>索引优化总结</strong></p>
<ul>
<li>索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描</li>
<li>应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>值分布很稀少的字段不适合建索引，例如&quot;性别&quot;这种只有两三个值的字段</li>
<li>字符字段只建前缀索引</li>
<li>字符字段最好不要做主键</li>
<li>不用外键，由程序保证约束</li>
<li>尽量不用UNIQUE，由程序保证约束</li>
<li>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引</li>
</ul></li>
<li><p><strong>查询SQL优化总结</strong></p>
<ul>
<li>可通过开启慢查询日志来找出较慢的SQL</li>
<li>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</li>
<li>sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库</li>
<li>不用SELECT *</li>
<li>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内</li>
<li>不用函数和触发器，在应用程序实现</li>
<li>避免%xxx式查询</li>
<li>少用JOIN</li>
<li>使用同类型进行比较，比如用&#39;123&#39;和&#39;123&#39;比，123和123比</li>
<li>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描</li>
<li>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5</li>
<li>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</li>
</ul></li>
<li><p><strong>引擎的选择</strong></p>
<p>目前广泛使用的是MyISAM和InnoDB两种引擎。</p>
<ul>
<li><p><strong>MyISAM</strong></p>
<p><strong>MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：</strong></p>
<ul>
<li>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</li>
<li>不支持事务</li>
<li>不支持外键</li>
<li>不支持崩溃后的安全恢复</li>
<li>在表有读取查询的同时，支持往表中插入新纪录</li>
<li>支持BLOB和TEXT的前500个字符索引，支持全文索引</li>
<li>支持延迟更新索引，极大提升写入性能</li>
<li>对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用</li>
</ul></li>
<li><p><strong>InnoDB</strong></p>
<p><strong>InnoDB在MySQL 5.5后成为默认索引，它的特点是：</strong></p>
<ul>
<li>支持行锁，采用MVCC来支持高并发</li>
<li>支持事务</li>
<li>支持外键</li>
<li>支持崩溃后的安全恢复</li>
<li>不支持全文索引</li>
</ul></li>
</ul>
<p>总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表</p></li>
<li><p><strong>系统调优参数</strong></p>
<p>1）back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500；</p>
<p>2）wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时；</p>
<p>3）max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限；</p>
<p>4）thread_concurrency：并发线程数，设为CPU核数的两倍；</p>
<p>5）skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问；</p>
<p>6）key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询show status like &#39;key_read%&#39;，保证key_reads / key_read_requests在0.1%以下最好；</p>
<p>7）innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询show status like &#39;Innodb_buffer_pool_read%&#39;，保证 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests越高越好；</p>
<p>8）innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小；</p>
<p>9）innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB；</p>
<p>10）query_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大；</p>
<p>11）可以通过命令show status like &#39;Qcache_%&#39;查看目前系统Query catch使用大小；</p>
<p>12）read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能；</p>
<p>13）sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小；</p>
<p>14）read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大；</p>
<p>15）record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值；</p>
<p>16）thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的；</p>
<p>17）table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM。</p></li>
<li><p><strong>升级硬件</strong></p>
<p>Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能。</p></li>
</ol>

<h2 id="toc_1">读写分离</h2>

<p>也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离</p>

<h2 id="toc_2">缓存</h2>

<p><strong>缓存可以发生在这些层次：</strong></p>

<p>1）MySQL内部：在系统调优参数介绍了相关设置；</p>

<p>2）数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象Persistence Object；</p>

<p>3）应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象Data Transfer Object；</p>

<p>4）Web层：针对web页面做缓存；</p>

<p>5）浏览器客户端：用户端的缓存。</p>

<p>可以根据实际情况在一个层次或多个层次结合加入缓存。</p>

<p><strong>这里重点介绍下服务层的缓存实现，目前主要有两种方式：</strong></p>

<p><strong>1）直写式（Write Through）：</strong>在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般；</p>

<p><strong>2）回写式（Write Back）：</strong>当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。</p>

<h2 id="toc_3">表分区</h2>

<p>MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码。</p>

<p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218160702113.png" alt="image-20190218160702113"/></p>

<p>用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上：</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218160739457.png" alt="image-20190218160739457"/></p>

<p><strong>分区的好处是：</strong></p>

<p>1）可以让单表存储更多的数据；</p>

<p>2）分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作；</p>

<p>3）部分查询能够从查询条件确定只落在少数分区上，速度会很快；</p>

<p>4）分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备；</p>

<p>5）可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争；</p>

<p>6）可以备份和恢复单个分区。</p>

<p><strong>分区的限制和缺点：</strong></p>

<p>1）一个表最多只能有1024个分区；</p>

<p>2）如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来；</p>

<p>3）分区表无法使用外键约束；</p>

<p>4）NULL值会使分区过滤无效；</p>

<p>5）所有分区必须使用相同的存储引擎。</p>

<p><strong>分区的类型：</strong></p>

<p>1）RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区；</p>

<p>2）LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择；</p>

<p>3）HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式；</p>

<p>4）KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</p>

<p><strong>分区最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218160812843.png" alt="image-20190218160812843"/></p>

<p>查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。</p>

<p>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存。</p>

<p>另外MySQL有一种早期的简单的分区实现 - 合并表（merge table），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代。</p>

<h2 id="toc_4">垂直拆分</h2>

<p>垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。</p>

<p><strong>比如原始的用户表是：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218162154213.png" alt="image-20190218162154213"/></p>

<p><strong>垂直拆分后是：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218162129833.png" alt="image-20190218162129833"/></p>

<p><strong>垂直拆分的优点是：</strong></p>

<p>1）可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)；</p>

<p>2）可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起；</p>

<p>3）数据维护简单。</p>

<p><strong>缺点是：</strong></p>

<p>1）主键出现冗余，需要管理冗余列；</p>

<p>2）会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力；</p>

<p>3）依然存在单表数据量过大的问题（需要水平拆分）；</p>

<p>4）事务处理复杂。</p>

<h2 id="toc_5">水平拆分</h2>

<h4 id="toc_6">概述</h4>

<p>水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表。</p>

<p>库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决。</p>

<p><strong>前面垂直拆分的用户表如果进行水平拆分，结果是：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218162027582.png" alt="image-20190218162027582"/></p>

<p>实际情况中往往会是垂直拆分和水平拆分的结合，即将Users_A_M和Users_N_Z再拆成Users和UserExtras，这样一共四张表。</p>

<p><strong>水平拆分的优点是:</strong></p>

<p>1）不存在单库大数据和高并发的性能瓶颈；</p>

<p>2）应用端改造较少；</p>

<p>3）提高了系统的稳定性和负载能力。</p>

<p><strong>缺点是：</strong></p>

<p>1）分片事务一致性难以解决；</p>

<p>2）跨节点Join性能差，逻辑复杂；</p>

<p>3）数据多次扩展难度跟维护量极大。</p>

<h4 id="toc_7">分片原则</h4>

<p>1）能不分就不分，参考“单表优化”；</p>

<p>2）分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量；</p>

<p>3）分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容；</p>

<p>4）尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题；</p>

<p>5）查询条件尽量优化，尽量避免Select * 的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引；</p>

<p>6）通过数据冗余和表分区赖降低跨库Join的可能。</p>

<p>这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p>

<p>总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。</p>

<h4 id="toc_8">解决方案</h4>

<p>由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。</p>

<p>*<strong>【客户端架构】：*</strong></p>

<p>通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现。</p>

<p>这是一个客户端架构的例子：</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218161958669.png" alt="image-20190218161958669"/></p>

<p>可以看到分片的实现是和应用服务器在一起的，通过修改Spring JDBC层来实现</p>

<p>客户端架构的优点是：</p>

<p>1）应用直连数据库，降低外围系统依赖所带来的宕机风险；</p>

<p>2）集成成本低，无需额外运维的组件。</p>

<p>缺点是：</p>

<p>1）限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心；</p>

<p>2）将分片逻辑的压力放在应用服务器上，造成额外风险。</p>

<p>*<strong>【代理架构】：*</strong></p>

<p>通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件。</p>

<p>这是一个代理架构的例子：</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218161928361.png" alt="image-20190218161928361"/></p>

<p>代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理。</p>

<p>代理架构的优点是：</p>

<p>能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强；</p>

<p>对于应用服务器透明且没有增加任何额外负载。</p>

<p>缺点是：</p>

<p>需部署和运维独立的代理中间件，成本高；<br/>
应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险。</p>

<h4 id="toc_9">各方案比较</h4>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218161825489.png" alt="image-20190218161825489"/></p>

<p><strong>如此多的方案，如何进行选择？可以按以下思路来考虑：</strong></p>

<p>1）确定是使用代理架构还是客户端架构。中小型规模或是比较简单的场景倾向于选择客户端架构，复杂场景或大规模系统倾向选择代理架构；<br/>
2）具体功能是否满足，比如需要跨节点ORDER BY，那么支持该功能的优先考虑；<br/>
3）不考虑一年内没有更新的产品，说明开发停滞，甚至无人维护和技术支持；<br/>
4）最好按大公司-&gt;社区-&gt;小公司-&gt;个人这样的出品方顺序来选择；<br/>
5）选择口碑较好的，比如github星数、使用者数量质量和使用者反馈；<br/>
6）开源的优先，往往项目有特殊需求可能需要改动源代码。</p>

<p><strong>按照上述思路，推荐以下选择：</strong></p>

<p>1）客户端架构：ShardingJDBC；<br/>
2）代理架构：MyCat或者Atlas。</p>

<h2 id="toc_10">兼容MySQL且可水平扩展的数据库</h2>

<p><strong>目前也有一些开源数据库兼容MySQL协议，如：</strong></p>

<p>1）<a href="https://github.com/pingcap/tidb">TiDB</a>；<br/>
2）<a href="http://www.cubrid.org/">Cubrid</a>。<br/>
但其工业品质和MySQL尚有差距，且需要较大的运维投入。</p>

<p><strong>如果想将原始的MySQL迁移到可水平扩展的新数据库中，可以考虑一些云数据库：</strong></p>

<p>1）阿里云<a href="https://cn.aliyun.com/product/petadata/?spm=5176.7960203.237031.38.cAzx5r">PetaData</a>；<br/>
2）阿里云<a href="https://cn.aliyun.com/product/oceanbase?spm=5176.7960203.237031.40.cAzx5r">OceanBase</a>；<br/>
3）腾讯云<a href="https://cloud.tencent.com/product/dcdb_for_tdsql">DCDB</a>。</p>

<p>10、NoSQL<br/>
在MySQL上做Sharding是一种戴着镣铐的跳舞，事实上很多大表本身对MySQL这种RDBMS的需求并不大，并不要求ACID，可以考虑将这些表迁移到NoSQL，彻底解决水平扩展问题。</p>

<p><strong>例如：</strong></p>

<p>1）日志类、监控类、统计类数据；<br/>
2）非结构化或弱结构化数据；<br/>
3）对事务要求不强，且无太多关联操作的数据。</p>

<p><a href="https://yq.aliyun.com/articles/679881?spm=a2c4e.11155472.0.0.ae1e42459WcIqo">原文地址</a><br/>
<a href="https://yq.aliyun.com/articles/679881?spm=a2c4e.11155472.0.0.ae1e42459WcIqo">https://yq.aliyun.com/articles/679881?spm=a2c4e.11155472.0.0.ae1e42459WcIqo</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java知识点]]></title>
    <link href="https://books.sangkf.cn/15510645390936.html"/>
    <updated>2019-02-25T11:15:39+08:00</updated>
    <id>https://books.sangkf.cn/15510645390936.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>列举一些Java相关的知识点<br/>
<span id="more"></span><!-- more --></p>
</blockquote>

<p><strong>基础篇</strong><br/>
<strong>01面向对象</strong><br/>
<strong>→ 什么是面向对象</strong><br/>
面向对象、面向过程</p>

<p>面向对象的三大基本特征和五大基本原则<br/>
<strong>→ 平台无关性</strong><br/>
Java 如何实现的平台无关</p>

<p>JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）</p>

<p><strong>→ 值传递</strong><br/>
值传递、引用传递</p>

<p>为什么说 Java 中只有值传递</p>

<p><strong>→ 封装、继承、多态</strong><br/>
什么是多态、方法重写与重载</p>

<p>Java 的继承与实现</p>

<p>构造函数与默认构造函数</p>

<p>类变量、成员变量和局部变量</p>

<p>成员变量和方法作用域</p>

<p><strong>02 Java 基础知识</strong></p>

<p><strong>→ 基本数据类型</strong><br/>
7 种基本数据类型：整型、浮点型、布尔型、字符型</p>

<p>整型中 byte、short、int、long 的取值范围</p>

<p>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？</p>

<p><strong>→ 自动拆装箱</strong><br/>
什么是包装类型、什么是基本类型、什么是自动拆装箱</p>

<p>Integer 的缓存机制</p>

<p><strong>→ String</strong><br/>
字符串的不可变性</p>

<p>JDK 6 和 JDK 7 中 substring 的原理及区别、</p>

<p>replaceFirst、replaceAll、replace 区别、</p>

<p>String 对“+”的重载、字符串拼接的几种方式和区别</p>

<p>String.valueOf 和 Integer.toString 的区别、</p>

<p>switch 对 String 的支持</p>

<p>字符串池、常量池（运行时常量池、Class 常量池）、intern</p>

<p><strong>→ 熟悉 Java 中各种关键字</strong><br/>
transient、instanceof、final、static、volatile、synchronized、const 原理及用法</p>

<p><strong>→ 集合类</strong><br/>
常用集合类的使用、ArrayList 和 LinkedList 和 Vector 的区别 、SynchronizedList 和 Vector 的区别、HashMap、HashTable、ConcurrentHashMap 区别、</p>

<p>Set 和 List 区别？Set 如何保证元素不重复？</p>

<p>Java 8 中 stream 相关用法、apache 集合处理工具类的使用、不同版本的 JDK 中 HashMap 的实现的区别以及原因</p>

<p>Collection 和 Collections 区别</p>

<p>Arrays.asList 获得的 List 使用时需要注意什么</p>

<p>Enumeration 和 Iterator 区别</p>

<p>fail-fast 和 fail-safe</p>

<p>CopyOnWriteArrayList、ConcurrentSkipListMap</p>

<p><strong>→ 枚举</strong><br/>
枚举的用法、枚举的实现、枚举与单例、Enum 类</p>

<p>Java 枚举如何比较</p>

<p>switch 对枚举的支持</p>

<p>枚举的序列化如何实现</p>

<p>枚举的线程安全性问题</p>

<p><strong>→ IO</strong><br/>
字符流、字节流、输入流、输出流、</p>

<p>同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型</p>

<p>BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty</p>

<p><strong>→ 反射</strong><br/>
反射与工厂模式、反射有什么用</p>

<p>Class 类、java.lang.reflect.*</p>

<p><strong>→ 动态代理</strong><br/>
静态代理、动态代理</p>

<p>动态代理和反射的关系</p>

<p>动态代理的几种实现方式</p>

<p>AOP</p>

<p><strong>→ 序列化</strong><br/>
什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全</p>

<p><strong>→ 注解</strong><br/>
元注解、自定义注解、Java 中常用注解使用、注解与反射的结合</p>

<p>Spring 常用注解</p>

<p><strong>→ JMS</strong><br/>
什么是 Java 消息服务、JMS 消息传送模型</p>

<p><strong>→ JMX</strong><br/>
java.lang.management.<em>、 javax.management.</em></p>

<p><strong>→ 泛型</strong><br/>
泛型与继承、类型擦除、泛型中 KTVE? object 等的含义、泛型各种用法</p>

<p>限定通配符和非限定通配符、上下界限定符 extends 和 super</p>

<p>List</p>

<p>List&lt;?&gt; 和 List</p>

<p><strong>→ 单元测试</strong><br/>
junit、mock、mockito、内存数据库（h2）</p>

<p><strong>→ 正则表达式</strong><br/>
java.lang.util.regex.*</p>

<p><strong>→ 常用的 Java 工具库</strong><br/>
commons.lang、commons.*...、 guava-libraries、 netty</p>

<p><strong>→ API &amp; SPI</strong><br/>
API、API 和 SPI 的关系和区别</p>

<p>如何定义 SPI、SPI 的实现原理</p>

<p><strong>→ 异常</strong><br/>
异常类型、正确处理异常、自定义异常</p>

<p>Error 和 Exception</p>

<p>异常链、try-with-resources</p>

<p>finally 和 return 的执行顺序</p>

<p><strong>→ 时间处理</strong><br/>
时区、冬令时和夏令时、时间戳、Java 中时间 API</p>

<p>格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系</p>

<p>SimpleDateFormat 的线程安全性问题</p>

<p>Java 8 中的时间处理</p>

<p>如何在东八区的计算机上获取美国时间</p>

<p><strong>→ 编码方式</strong><br/>
Unicode、有了 Unicode 为啥还需要 UTF-8</p>

<p>GBK、GB2312、GB18030 之间的区别</p>

<p>UTF8、UTF16、UTF32 区别</p>

<p>URL 编解码、Big Endian 和 Little Endian</p>

<p>如何解决乱码问题</p>

<p><strong>→ 语法糖</strong><br/>
Java 中语法糖原理、解语法糖</p>

<p>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式</p>

<p><strong>03阅读源代码</strong></p>

<p>String、Integer、Long、Enum、</p>

<p>BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、</p>

<p>ArrayList &amp; LinkedList、</p>

<p>HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet</p>

<p><strong>04 Java 并发编程</strong></p>

<p><strong>→ 并发与并行</strong><br/>
什么是并发、什么是并行</p>

<p>并发与并行的区别</p>

<p><strong>→ 什么是线程，与进程的区别</strong><br/>
线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程</p>

<p>线程与进程的区别</p>

<p><strong>→ 线程池</strong><br/>
自己设计线程池、submit() 和 execute()、线程池原理</p>

<p>为什么不允许使用 Executors 创建线程池</p>

<p><strong>→ 线程安全</strong><br/>
死锁、死锁如何排查、线程安全和内存模型的关系</p>

<p><strong>→ 锁</strong><br/>
CAS、乐观锁与****悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、</p>

<p>锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁</p>

<p><strong>→ 死锁</strong><br/>
什么是死锁</p>

<p>死锁如何解决</p>

<p><strong>→ synchronized</strong><br/>
synchronized 是如何实现的？</p>

<p>synchronized 和 lock 之间关系、不使用 synchronized 如何实现一个线程安全的单例</p>

<p>synchronized 和原子性、可见性和有序性之间的关系</p>

<p><strong>→ volatile</strong><br/>
happens-before、内存屏障、编译器指令重排和 CPU 指令重</p>

<p>volatile 的实现原理</p>

<p>volatile 和原子性、可见性和有序性之间的关系</p>

<p>有了 symchronized 为什么还需要 volatile</p>

<p><strong>→ sleep 和 wait</strong><br/>
<strong>→ wait 和 notify</strong><br/>
<strong>→ notify 和 notifyAll</strong><br/>
<strong>→ ThreadLocal</strong><br/>
<strong>→ 写一个死锁的程序</strong><br/>
<strong>→ 写代码来解决生产者消费者问题</strong><br/>
<strong>→ 并方包</strong><br/>
Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、ConcurrentHashMap、Executors</p>

<p><strong>2底层篇</strong></p>

<p><strong>01JVM</strong></p>

<p><strong>→ JVM 内存结构</strong></p>

<p>class 文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、</p>

<p>堆和栈区别</p>

<p>Java 中的对象一定在堆上分配吗？</p>

<p><strong>→ Java 内存模型</strong><br/>
计算机内存模型、缓存一致性、MESI 协议</p>

<p>可见性、原子性、顺序性、happens-before、</p>

<p>内存屏障、synchronized、volatile、final、锁</p>

<p><strong>→ 垃圾回收</strong><br/>
GC 算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收</p>

<p>GC 参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon）</p>

<p><strong>→ JVM 参数及调优</strong><br/>
-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、</p>

<p>-XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold</p>

<p><strong>→ Java 对象模型</strong><br/>
oop-klass、对象头</p>

<p><strong>→ HotSpot</strong><br/>
即时编译器、编译优化</p>

<p><strong>→ 虚拟机性能监控与故障处理工具</strong><br/>
jps, jstack, jmap, jstat, jconsole, jinfo, jhat, javap, btrace, TProfiler</p>

<p>Arthas</p>

<p><strong>02 类加载机制</strong></p>

<p>classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）</p>

<p><strong>03 编译与反编译</strong></p>

<p>什么是编译（前端编译、后端编译）、什么是反编译</p>

<p>JIT、JIT 优化（逃逸分析、栈上分配、标量替换、锁优化）</p>

<p>编译工具：javac</p>

<p>反编译工具：javap 、jad 、CRF</p>

<p><strong>3进阶篇</strong></p>

<p><strong>01 Java 底层知识</strong></p>

<p><strong>→ 字节码、class 文件格式</strong><br/>
<strong>→ CPU 缓存，L1，L2，L3 和伪共享</strong><br/>
<strong>→ 尾递归</strong><br/>
<strong>→ 位运算</strong><br/>
用位运算实现加、减、乘、除、取余</p>

<p><strong>02 设计模式</strong><br/>
设计模式的六大原则：</p>

<p>开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle）</p>

<p>接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle）</p>

<p><strong>→ 了解 23 种设计模式</strong></p>

<p>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</p>

<p>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p>

<p>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</p>

<p><strong>→ 会使用常用设计模式</strong><br/>
单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁</p>

<p>工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会</p>

<p><strong>→ 不用 synchronized 和 lock，实现线程安全的单例模式</strong><br/>
<strong>→ 实现 AOP</strong><br/>
<strong>→ 实现 IOC</strong><br/>
<strong>→ nio 和 reactor 设计模式</strong></p>

<p><strong>03 网络编程知识</strong></p>

<p><strong>→ tcp、udp、http、https 等常用协议</strong></p>

<p>三次握手与四次关闭、流量控制和拥塞控制、OSI 七层模型、tcp 粘包与拆包</p>

<p><strong>→ http/1.0 http/1.1 http/2 之前的区别</strong><br/>
http 中 get 和 post 区别</p>

<p>常见的 web 请求返回的状态码</p>

<p>404、302、301、500分别代表什么</p>

<p><strong>→ http/3</strong><br/>
<strong>→ Java RMI，Socket，HttpClient</strong><br/>
<strong>→ cookie 与 session</strong><br/>
cookie 被禁用，如何实现 session</p>

<p><strong>→ 用 Java 写一个简单的静态文件的 HTTP 服务器</strong><br/>
<strong>→ 了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器</strong><br/>
<strong>→ 用 Java 实现 FTP、SMTP 协议</strong><br/>
<strong>→ 进程间通讯的方式</strong><br/>
<strong>→ 什么是 CDN？如果实现？</strong><br/>
<strong>→ DNS</strong><br/>
什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等<br/>
域名解析、根域名服务器</p>

<p>DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS</p>

<p><strong>→ 反向代理</strong><br/>
正向代理、反向代理</p>

<p>反向代理服务器</p>

<p><strong>04 框架知识</strong></p>

<p><strong>→ Servlet</strong></p>

<p>生命周期</p>

<p>线程安全问题</p>

<p>filter 和 listener</p>

<p>web.xml 中常用配置及作用</p>

<p><strong>→ Hibernate</strong><br/>
什么是 OR Mapping</p>

<p>Hibernate 的懒加载<br/>
Hibernate 的缓存机制</p>

<p>Hibernate / Ibatis / MyBatis 之间的区别</p>

<p><strong>→ Spring</strong> <br/>
Bean 的初始化<br/>
AOP 原理<br/>
实现 Spring 的IOC<br/>
Spring 四种依赖注入方式<br/>
<strong>→ Spring MVC</strong><br/>
什么是 MVC</p>

<p>Spring mvc 与 Struts mvc 的区别</p>

<p><strong>→ Spring Boot</strong><br/>
Spring Boot 2.0、起步依赖、自动配置、</p>

<p>Spring Boot 的 starter 原理，自己实现一个 starter</p>

<p><strong>→ Spring Security</strong><br/>
<strong>→ Spring Cloud</strong><br/>
服务发现与注册：Eureka、Zookeeper、Consul</p>

<p>负载均衡：Feign、Spring Cloud Loadbalance</p>

<p>服务配置：Spring Cloud Config</p>

<p>服务限流与熔断：Hystrix</p>

<p>服务链路追踪：Dapper</p>

<p>服务网关、安全、消息</p>

<p><strong>05 应用服务器知识</strong></p>

<p><strong>→ JBoss</strong><br/>
<strong>→ tomcat</strong><br/>
<strong>→ jetty</strong><br/>
<strong>→ Weblogic</strong></p>

<p><strong>06 工具</strong></p>

<p><strong>→ git &amp; svn</strong><br/>
<strong>→ maven &amp; gradle</strong><br/>
<strong>→ Intellij IDEA</strong><br/>
常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat</p>

<p>Lombok plugin、.ignore、Mybatis plugin</p>

<p><strong>4高级篇</strong></p>

<p><strong>01 新技术</strong></p>

<p><strong>→ Java 8</strong></p>

<p>lambda 表达式、Stream API、时间 API</p>

<p><strong>→ Java 9</strong><br/>
Jigsaw、Jshell、Reactive Streams</p>

<p><strong>→ Java 10</strong><br/>
局部变量类型推断、G1 的并行 Full GC、ThreadLocal 握手机制</p>

<p><strong>→ Java 11</strong><br/>
ZGC、Epsilon、增强 var</p>

<p><strong>→ Spring 5</strong><br/>
响应式编程</p>

<p><strong>→ Spring Boot 2.0</strong><br/>
<strong>→ HTTP/2</strong><br/>
<strong>→ HTTP/3</strong></p>

<p><strong>02 性能优化</strong></p>

<p>使用单例、使用 Future 模式、使用线程池</p>

<p>选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存</p>

<p><strong>03 线上问题分析</strong></p>

<p><strong>→ dump 获取</strong></p>

<p>线程 Dump、内存 Dump、gc 情况</p>

<p><strong>→ dump 分析</strong><br/>
分析死锁、分析内存泄露</p>

<p><strong>→ dump 分析及获取工具</strong><br/>
jstack、jstat、jmap、jhat、Arthas</p>

<p><strong>→ 自己编写各种 outofmemory，stackoverflow 程序</strong><br/>
HeapOutOfMemory、 Young OutOfMemory、</p>

<p>MethodArea OutOfMemory、ConstantPool OutOfMemory、</p>

<p>DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow</p>

<p><strong>→ Arthas</strong><br/>
jvm 相关、class/classloader 相关、monitor/watch/trace 相关、</p>

<p>options、管道、后台异步任务</p>

<p>文档：<a href="https://alibaba.github.io/arthas/advanced-use.html">https://alibaba.github.io/arthas/advanced-use.html</a></p>

<p><strong>→ 常见问题解决思路</strong><br/>
内存溢出、线程死锁、类加载冲突</p>

<p><strong>→ 使用工具尝试解决以下问题，并写下总结</strong><br/>
当一个 Java 程序响应很慢时如何查找问题</p>

<p>当一个 Java 程序频繁 FullGC 时如何解决问题</p>

<p>如何查看垃圾回收日志</p>

<p>当一个 Java 应用发生 OutOfMemory 时该如何解决</p>

<p>如何判断是否出现死锁</p>

<p>如何判断是否存在内存泄露</p>

<p>使用 Arthas 快速排查 Spring Boot 应用404/401问题</p>

<p>使用 Arthas 排查线上应用日志打满问题</p>

<p>利用 Arthas 排查 Spring Boot 应用 NoSuchMethodError</p>

<p><strong>04编译原理知识</strong></p>

<p><strong>→ 编译与反编译</strong><br/>
<strong>→ Java 代码的编译与反编译</strong><br/>
<strong>→ Java 的反编译工具</strong><br/>
javap 、jad 、CRF</p>

<p><strong>→ 即时编译器</strong><br/>
<strong>→ 编译过程</strong><br/>
词法分析，语法分析（LL 算法，递归下降算法，LR 算法）<br/>
语义分析，运行时环境，中间代码，代码生成，代码优化</p>

<p><strong>05 操作系统知识</strong></p>

<p><strong>→ Linux 的常用命令</strong><br/>
<strong>→ 进程间通信</strong><br/>
<strong>→ 进程同步</strong><br/>
生产者消费者问题、哲学家就餐问题、读者写者问题</p>

<p><strong>→ 缓冲区溢出</strong><br/>
<strong>→ 分段和分页</strong><br/>
<strong>→ 虚拟内存与主存</strong><br/>
<strong>→ 虚拟内存管理</strong><br/>
<strong>→ 换页算法</strong></p>

<p><strong>06 数据库知识</strong></p>

<p><strong>→ MySQL 执行引擎</strong><br/>
<strong>→ MySQL 执行计划</strong><br/>
如何查看执行计划，如何根据执行计划进行 SQL 优化</p>

<p><strong>→ 索引</strong><br/>
Hash 索引、B 树索引（B+树、和B树、R树）</p>

<p>普通索引、唯一索引</p>

<p>覆盖索引、最左前缀原则、索引下推</p>

<p><strong>→ SQL 优化</strong><br/>
<strong>→ 数据库事务和隔离级别</strong><br/>
事务的隔离级别、事务能不能实现锁的功能</p>

<p><strong>→ 数据库锁</strong><br/>
行锁、表锁、使用数据库锁实现乐观锁、</p>

<p><strong>→ 连接</strong><br/>
内连接，左连接，右连接</p>

<p><strong>→ 数据库主备搭建</strong><br/>
<strong>→ binlog</strong><br/>
<strong>→ redolog</strong><br/>
<strong>→ 内存数据库</strong><br/>
h2</p>

<p><strong>→ 分库分表</strong><br/>
<strong>→ 读写分离</strong><br/>
<strong>→ 常用的 NoSql 数据库</strong><br/>
redis、memcached</p>

<p><strong>→ 分别使用数据库锁、NoSql 实现分布式锁</strong><br/>
<strong>→ 性能调优</strong><br/>
<strong>→ 数据库连接池</strong></p>

<p><strong>07 数据结构与算法知识</strong></p>

<p><strong>→ 简单的数据结构</strong></p>

<p>栈、队列、链表、数组、哈希表、</p>

<p>栈和队列的相同和不同之处</p>

<p>栈通常采用的两种存储结构</p>

<p><strong>→ 树</strong><br/>
二叉树、字典树、平衡树、排序树、</p>

<p>B 树、B+ 树、R 树、多路树、红黑树</p>

<p><strong>→ 堆</strong><br/>
大根堆、小根堆</p>

<p><strong>→ 图</strong><br/>
有向图、无向图、拓扑</p>

<p><strong>→ 排序算法</strong><br/>
稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序</p>

<p>不稳定的排序：选择排序、希尔排序、Clover 排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序</p>

<p>各种排序算法和时间复杂度</p>

<p><strong>→ 两个栈实现队列，和两个队列实现栈</strong><br/>
<strong>→ 深度优先和广度优先搜索</strong><br/>
<strong>→ 全排列、贪心算法、KMP 算法、hash 算法</strong><br/>
<strong>→ 海量数据处理</strong><br/>
分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce 等。</p>

<p><strong>08大数据知识</strong></p>

<p><strong>→ Zookeeper</strong></p>

<p>基本概念、常见用法</p>

<p><strong>→ Solr，Lucene，ElasticSearch</strong><br/>
在 linux 上部署 solr，solrcloud，新增、删除、查询索引</p>

<p><strong>→ Storm，流式计算，了解 Spark，S4</strong><br/>
在 linux 上部署 storm，用 zookeeper 做协调，运行 storm hello world，local 和 remote 模式运行调试 storm topology。</p>

<p><strong>→ Hadoop，离线计算</strong><br/>
HDFS、MapReduce</p>

<p><strong>→ 分布式日志收集 flume，kafka，logstash</strong><br/>
<strong>→ 数据挖掘，mahout</strong></p>

<p><strong>09 网络安全知识</strong></p>

<p><strong>→ XSS</strong></p>

<p>XSS 的防御</p>

<p><strong>→ CSRF</strong><br/>
<strong>→ 注入攻击</strong><br/>
SQL 注入、XML 注入、CRLF 注入</p>

<p><strong>→ 文件上传漏洞</strong><br/>
<strong>→ 加密与解密</strong><br/>
对称加密、非对称加密、哈希算法、加盐哈希算法</p>

<p>MD5，SHA1、DES、AES、RSA、DSA</p>

<p>彩虹表</p>

<p><strong>→ DDOS攻击</strong><br/>
DOS 攻击、DDOS 攻击</p>

<p>memcached 为什么可以导致 DDos 攻击、什么是反射型 DDoS</p>

<p>如何通过 Hash 碰撞进行 DOS 攻击</p>

<p><strong>→ SSL、TLS，HTTPS</strong><br/>
<strong>→ 用 openssl 签一个证书部署到 apache 或 nginx</strong></p>

<p><strong>5架构篇</strong></p>

<p><strong>01分布式</strong></p>

<p>数据一致性、服务治理、服务降级</p>

<p><strong>→ 分布式事务</strong></p>

<p>2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC</p>

<p><strong>→ Dubbo</strong><br/>
服务注册、服务发现，服务治理</p>
<http://dubbo.apache.org/zh-cn/>
<p><strong>→ 分布式数据库</strong><br/>
怎样打造一个分布式数据库、什么时候需要分布式数据库、</p>

<p>mycat、otter、HBase</p>

<p><strong>→ 分布式文件系统</strong><br/>
mfs、fastdfs</p>

<p><strong>→ 分布式缓存</strong><br/>
缓存一致性、缓存命中率、缓存冗余</p>

<p><strong>→ 限流降级</strong><br/>
Hystrix、Sentinal</p>

<p><strong>→ 算法</strong><br/>
共识算法、Raft 协议、Paxos 算法与 Raft 算法、</p>

<p>拜占庭问题与算法、2PC、3PC</p>

<p><strong>02 微服务</strong></p>

<p>SOA、康威定律</p>

<p><strong>→ ServiceMesh</strong><br/>
sidecar</p>

<p><strong>→ Docker &amp; Kubernets</strong><br/>
<strong>→ Spring Boot</strong><br/>
<strong>→ Spring Cloud</strong></p>

<p><strong>03 高并发</strong></p>

<p><strong>→ 分库分表</strong><br/>
<strong>→ CDN 技术</strong><br/>
<strong>→ 消息队列</strong><br/>
ActiveMQ</p>

<p><strong>04 监控</strong></p>

<p><strong>→ 监控什么</strong></p>

<p>CPU、内存、磁盘 I/O、网络 I/O 等</p>

<p><strong>→ 监控手段</strong><br/>
进程监控、语义监控、机器资源监控、数据波动</p>

<p><strong>→ 监控数据采集</strong><br/>
日志、埋点</p>

<p><strong>→ Dapper</strong></p>

<p><strong>05 负载均衡</strong></p>

<p>tomcat 负载均衡、Nginx 负载均衡</p>

<p>四层负载均衡、七层负载均衡</p>

<p><strong>06 DNS</strong></p>

<p>DNS 原理、DNS 的设计</p>

<p><strong>07 CDN</strong></p>

<p>数据一致性</p>

<p><strong>6扩展篇</strong></p>

<p><strong>01 云计算</strong></p>

<p>IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess</p>

<p><strong>02 搜索引擎</strong></p>

<p>Solr、Lucene、Nutch、Elasticsearch</p>

<p><strong>03权限管理</strong></p>

<p>Shiro</p>

<p><strong>04 区块链</strong></p>

<p>哈希算法、Merkle 树、公钥密码算法、共识算法、</p>

<p>Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名</p>

<p><strong>→ 比特币</strong><br/>
挖矿、共识机制、闪电网络、侧链、热点问题、分叉</p>

<p><strong>→ 以太坊</strong><br/>
<strong>→ 超级账本</strong></p>

<p><strong>05人工智能</strong></p>

<p>数学基础、机器学习、人工神经网络、深度学习、应用场景。</p>

<p><strong>→ 常用框架</strong><br/>
TensorFlow、DeepLearning4J</p>

<p><strong>06 loT</strong></p>

<p><strong>07 量子计算</strong></p>

<p><strong>08 AR &amp; VR</strong></p>

<p><strong>09其他语言</strong></p>

<p>Groovy、Python、Go、NodeJs、Swift、Rust</p>

<p><strong>7推荐书籍</strong></p>

<p>《深入理解 Java 虚拟机》 <br/>
《Effective Java》 <br/>
《深入分析 Java Web 技术内幕》 <br/>
《大型网站技术架构》 <br/>
《代码整洁之道》 <br/>
《架构整洁之道》 <br/>
《Head First 设计模式》 <br/>
《maven 实战》 <br/>
《区块链原理、设计与应用》 <br/>
《Java 并发编程实战》 <br/>
《鸟哥的 Linux 私房菜》 <br/>
《从Paxos 到 Zookeeper》 <br/>
《架构即未来》</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAVA8新特性]]></title>
    <link href="https://books.sangkf.cn/15510645099182.html"/>
    <updated>2019-02-25T11:15:09+08:00</updated>
    <id>https://books.sangkf.cn/15510645099182.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>[<strong>原文地址</strong>] <a href="https://www.cnblogs.com/huyunfan/p/7456535.html">https://www.cnblogs.com/huyunfan/p/7456535.html</a></p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">default拓展方法</h2>

<p>default关键字为接口声明添加非抽象方法的实现,也称为拓展方法</p>

<pre><code class="language-java">  public interface Formula {
      void doSomething();
  
      default void before() {
          System.out.println(&quot;我是拓展方法&quot;);
      }
  }
  
  public class FormulaService implements Formula {
  
      @Override
      public void doSomething() {
          before();
          System.out.println(&quot;我是override方法&quot;);
      }
  }
</code></pre>

<h2 id="toc_1">Lambda表达式</h2>

<p>java8引入函数式编程，Lambda则是函数式编程的基础。</p>

<pre><code class="language-java">  List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
  
  // java8之前
  Collections.sort(list, new Comparator&lt;String&gt;(){
      @Override
      public int compare(String o1, String o2) {
          return o1.compareTo(o2);
      }
  });
  
  // lambda
  Collections.sort(list, (String o1, String o2) -&gt; {
              return o2.compareTo(o1);
  });
  
  // 简洁lambda
  Collections.sort(list, (String o1, String o2) -&gt;  o2.compareTo(o1));
  
  // 更简洁lambda
  Collections.sort(list, (o1, o2) -&gt;  o2.compareTo(o1));
  
  // 也可以这样写
  Collections.sort(list, Comparator.comparing(String::toString));
</code></pre>

<h2 id="toc_2">函数式接口</h2>

<p>一个函数式接口有且只能有一个抽象方法申明，其中该注意的是 @FunctionalInterface 注解，此时如果在接口中定义了第二个抽象方法，编译器将会抛出异常。当然如果不加该注解也不是不行，如果接口中有多个抽象方法，而你又使用了lambda表达式，则在调用处会抛出异常。</p>

<pre><code class="language-java">  @FunctionalInterface
  public interface Formula&lt;F,T&gt;{
      T convert(F var1);
  }
  
  Formula&lt;String,Integer&gt; function = (var1 -&gt; Integer.valueOf(var1));
  Integer var2 = function.convert(&quot;1000&quot;); 
</code></pre>

<h2 id="toc_3">方法和构造函数引用</h2>

<p>方法引用的标准语法是 <code>类名:方法名</code></p>

<p>| 类型                             | 示例                              |<br/>
  | -------------------------------- | --------------------------------- |<br/>
  | 引用静态方法                     | targetClass :: staticMethodName   |<br/>
  | 引用某个对象的实例方法           | targetClass :: instanceMethodName |<br/>
  | 引用某个类型的任意对象的实例方法 | targetType :: methodName          |<br/>
  | 引用构造方法                     | className :: new                  |</p>

<h3 id="toc_4">引用静态方法</h3>

<pre><code class="language-java">   Formula&lt;String,Integer&gt; function = (Integer::valueOf);
   Integer var2 = function.convert(&quot;1000&quot;);
</code></pre>

<h3 id="toc_5">引用某个类型的任意对象的实例方法</h3>

<pre><code class="language-java">   public static void main(String[] args) {
      String[] array = {&quot;贱明&quot;, &quot;学友&quot;};
      Arrays.sort(array, String::compareTo);
   }
</code></pre>

<h3 id="toc_6">引用构造方法</h3>

<pre><code class="language-java">   // 定义工厂
   interface PersonFactory&lt;P extends Person&gt;{
       P create(String name);
   }
   // Person类的构造方法
   public Person(String name) {
       this.name = name;
   }
   // 创建
   PersonFactory&lt;Person&gt; factory = Person::new;
   factory.create(&quot;贱明&quot;);
</code></pre>

<h2 id="toc_7">Lambda的范围</h2>

<p>lambda可以访问局部对应的外部区域的局部final变量，以及成员变量和静态变量。</p>

<h3 id="toc_8">访问成员变量</h3>

<pre><code class="language-text"> ```java
 public void doSomething(){
     final String p1 = &quot;贱明&quot;;
     final String p2 = &quot;学友&quot;;
     Formula function = (person1, person2) -&gt; p1.compareTo(p2);
 }
 ```

 与java8以下版本不同的是，p1 p2你可以不修饰成final 也不会报错，但是如果你想修改他们，编译器则会告诉你这是不被允许的。
</code></pre>

<h3 id="toc_9">访问成员变量和静态变量</h3>

<pre><code class="language-text"> ```java
 public void doSomething(){;
    Formula function = (person1, person2) -&gt;{
        dehua = &quot;贱明&quot;;
        xueyou=&quot;学友&quot;;
        return dehua.compareTo(xueyou);
    };
 }
 ```
</code></pre>

<h2 id="toc_10">内置函数式接口</h2>

<p>​     java8 api中提供了很多内置函数式接口，而且有些接口其实在Google Guava中已经实现了，很大程  度的降低了程序员的工作负担。</p>

<h3 id="toc_11">Predicates</h3>

<pre><code class="language-text"> Predicate是一个布尔类型的函数，该函数只有一个输入参数，他包含了多种默认实现。

 ```java
 public static void main(String[] args) {
    Predicate&lt;String&gt; predicate = (s) -&gt; s.contains(&quot;贱明&quot;);
    String var1 = &quot;牛贱明&quot;;

    predicate.test(var1);              // true
    predicate.negate().test(var1);     // false

    Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;
    Predicate&lt;Boolean&gt; isNull = Objects::isNull;

    Predicate&lt;String&gt; isEmpty = String::isEmpty;
    Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();

    isNotEmpty.and(isEmpty).test(var1);
 }
 ```
</code></pre>

<h3 id="toc_12">Functions</h3>

<pre><code class="language-text"> Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起

 ```java
 public static void main(String[] args) {
    Function&lt;String, Integer&gt; toInteger = Integer::valueOf;
    Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);

    System.out.println(toInteger.apply(&quot;123&quot;));
    System.out.println(backToString.apply(&quot;123&quot;));
 }

 ```
</code></pre>

<h3 id="toc_13">Suppliers</h3>

<pre><code class="language-text"> Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。

 ```java
 Supplier&lt;Person&gt; personSupplier = Person::new;
 Person p = personSupplier.get();   // new Person

 ```
</code></pre>

<h3 id="toc_14">Consumers</h3>

<pre><code class="language-text"> Consumer代表了在一个输入参数上需要进行的操作。

 ```java
 Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.getName());
 greeter.accept(new Person(&quot;贱明&quot;));

 ```
</code></pre>

<h3 id="toc_15">Comparators</h3>

<pre><code class="language-text"> Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。

 ```java
 Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.getName().compareTo(p2.getName());

 Person p1 = new Person(&quot;贱明&quot;);
 Person p2 = new Person(&quot;学友&quot;);

 System.out.println(comparator.compare(p1, p2));             // &gt; 1105
 System.out.println(comparator.reversed().compare(p1, p2));  // &lt; -1105

 ```
</code></pre>

<h3 id="toc_16">Optional</h3>

<pre><code class="language-text"> Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerException产生。
 Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional。

 ```java
 Optional&lt;String&gt; optional = Optional.of(&quot;贱明&quot;);

 System.out.println(optional.isPresent()); // true      
 System.out.println(optional.get()); // 贱明   
 System.out.println(optional.orElse(&quot;学友&quot;)); // 贱明    

 optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));    
 ```
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringCloud服务治理，服务注册，服务发现]]></title>
    <link href="https://books.sangkf.cn/15510642705827.html"/>
    <updated>2019-02-25T11:11:10+08:00</updated>
    <id>https://books.sangkf.cn/15510642705827.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>服务治理是微服务架构中最为核心和基础的模块，他主要用来实现各个微服务市里的自动化注册和发现。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">服务治理</h2>

<p>服务治理是微服务架构中最为核心和基础的模块，他主要用来实现各个微服务市里的自动化注册和发现。<br/>
<!-- more --></p>

<ul>
<li><p>为什么需要服务治理？微服务没有他会怎样？</p>
<p>​ 在最开始构建微服务系统的时候可能服务并不多，我们可以通过一些静态配置来完成服务的调用。比如，有两个服务A和服务B，其中服务A需要调用服务B来完成一个业务的操作时，为了实现服务B的高可用，不论采用服务端负载均衡还是客户端负载均衡，都需要手工维护服务B的具体实例清单。但是随着业务的发展，系统的功能越来越复杂，相应的微服务应用也不断增加，我们的静态配置会变得越来越难以维护。并且面对不断发展的业务，我们的集群规模，服务的位置，服务的命名等都可能发生变化，如果还是通过手工维护的方式，那么极易发生错误或者命名冲突等问题。同时，对于这类静态内容的维护也必将消耗大量的人力。</p>
<p><u><strong>服务治理框架的实现都是围绕着服务注册与服务发现机制来完成微服务应用实例的自动化管理</strong></u></p></li>
</ul>

<h2 id="toc_1">服务注册</h2>

<p>​   在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，将主机与端口号，版本号，通信协议等一些附加信息告知注册中心，注册中心按照服务名分类组织服务清单。</p>

<p>当这些进程启动，并向注册中心注册自己的服务后，注册中心就会维护类似下面的一个服务清单。另外，服务注册中心还需要以心跳的方式去监测清单中的服务是否可用，如果不可用则需要从服务清单中提出，达到排除故障服务的效果。</p>

<table>
<thead>
<tr>
<th>服务名</th>
<th>位置</th>
</tr>
</thead>

<tbody>
<tr>
<td>服务A</td>
<td>192.168.0.100:8000，192.168.0.101:8000</td>
</tr>
<tr>
<td>服务B</td>
<td>192.168.0.100:9000，192.168.0.101:9000，192.168.0.102:9000</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">服务发现</h2>

<p>​   由于在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务名发起请求调用实现。所以，服务调用方在调用服务提供方接口的时候，并不知道具体的服务实例位置。因此，调用方需要向服务注册中心咨询服务，并获取所有的服务的实例清单，以实现对具体服务实例的访问。</p>

<p>比如，现有服务C希望调用服务A，服务C就向注册中心发起咨询服务的请求，服务注册中心就会将服务A的位置清单返回给服务C。如按上例服务A的的情况，C便获得了服务A的两个可用位置192.168.0.100:8000和192.168.0.101:8000。当服务C要发起调用的时候，便从该清单中以某种轮询策略取出一个位置来进行服务调用，这就是后续我们将会介绍的客户端负载均衡。</p>

]]></content>
  </entry>
  
</feed>
