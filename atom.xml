<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[见课就上的小婊砸]]></title>
  <link href="https://books.sangkf.cn/atom.xml" rel="self"/>
  <link href="https://books.sangkf.cn/"/>
  <updated>2019-02-24T21:44:48+08:00</updated>
  <id>https://books.sangkf.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[地址收藏]]></title>
    <link href="https://books.sangkf.cn/15509336304684.html"/>
    <updated>2019-02-23T22:53:50+08:00</updated>
    <id>https://books.sangkf.cn/15509336304684.html</id>
    <content type="html"><![CDATA[
<p>收藏一些发现的比较好的博客<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>言曌博客
<a href="http://blog.liuyanzhao.com/">http://blog.liuyanzhao.com/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gitment：使用 GitHub Issues 搭建评论系统]]></title>
    <link href="https://books.sangkf.cn/15509294487927.html"/>
    <updated>2019-02-23T21:44:08+08:00</updated>
    <id>https://books.sangkf.cn/15509294487927.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>[转载]<a href="https://imsun.net/posts/gitment-introduction/">https://imsun.net/posts/gitment-introduction/</a></p>
</blockquote>

<p><a href="https://github.com/imsun/gitment">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。<br/>
<span id="more"></span><!-- more --><br/>
本博客评论系统已迁移至 Gitment。虽然 Gitment 只能使用 GitHub 账号进行评论，但考虑到博客受众，这是可以接受的。</p>

<ul>
<li><a href="https://github.com/imsun/gitment">项目地址</a></li>
<li><a href="https://imsun.github.io/gitment/">示例页面</a></li>
</ul>

<h2 id="toc_0"><a href="https://imsun.net/posts/gitment-introduction/#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8" title="基础使用"></a>基础使用</h2>

<h3 id="toc_1"><a href="https://imsun.net/posts/gitment-introduction/#1-%E6%B3%A8%E5%86%8C-OAuth-Application" title="1\. 注册 OAuth Application"></a>1. 注册 OAuth Application</h3>

<p><a href="https://github.com/settings/applications/new">点击此处</a> 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <code>https://imsun.net</code>）。</p>

<p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p>

<h3 id="toc_2"><a href="https://imsun.net/posts/gitment-introduction/#2-%E5%BC%95%E5%85%A5-Gitment" title="2\. 引入 Gitment"></a>2. 引入 Gitment</h3>

<p>将下面的代码添加到你的页面：</p>

<pre><code class="language-javascript">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;
&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var gitment = new Gitment({
  id: &#39;页面 ID&#39;, // 可选。默认为 location.href
  owner: &#39;你的 GitHub ID&#39;,
  repo: &#39;存储评论的 repo&#39;,
  oauth: {
    client_id: &#39;你的 client ID&#39;,
    client_secret: &#39;你的 client secret&#39;,
  },
})
gitment.render(&#39;container&#39;)
&lt;/script&gt;
</code></pre>

<p>注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。</p>

<p>如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。</p>

<pre><code class="language-javascript">$ npm install --save gitment
</code></pre>

<p>关于构造函数中的更多可用参数请查看 <a href="https://github.com/imsun/gitment#options">Gitment Options</a></p>

<h3 id="toc_3"><a href="https://imsun.net/posts/gitment-introduction/#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%84%E8%AE%BA" title="3\. 初始化评论"></a>3. 初始化评论</h3>

<p>页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。</p>

<p>之后其他用户即可在该页面发表评论。</p>

<h2 id="toc_4"><a href="https://imsun.net/posts/gitment-introduction/#%E8%87%AA%E5%AE%9A%E4%B9%89" title="自定义"></a>自定义</h2>

<p>Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）</p>

<p>比如你可以通过自定义主题将评论框放在评论列表前面：</p>

<pre><code class="language-javascript">const myTheme = {
  render(state, instance) {
    const container = document.createElement(&#39;div&#39;)
    container.lang = &quot;en-US&quot;
    container.className = &#39;gitment-container gitment-root-container&#39;
    container.appendChild(instance.renderHeader(state, instance))
    container.appendChild(instance.renderEditor(state, instance))
    container.appendChild(instance.renderComments(state, instance))
    container.appendChild(instance.renderFooter(state, instance))
    return container
  },
}
const gitment = new Gitment({
  // ...
  theme: myTheme,
})
gitment.render(&#39;container&#39;)
</code></pre>

<p>更多自定义内容请查看<a href="https://github.com/imsun/gitment#customize">文档</a>。</p>

<h2 id="toc_5"><a href="https://imsun.net/posts/gitment-introduction/#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" title="其他问题"></a>其他问题</h2>

<h3 id="toc_6"><a href="https://imsun.net/posts/gitment-introduction/#%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98" title="语言问题"></a>语言问题</h3>

<p>考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。</p>

<h3 id="toc_7"><a href="https://imsun.net/posts/gitment-introduction/#%E8%AF%B7%E5%8B%BF%E6%BB%A5%E7%94%A8" title="请勿滥用"></a>请勿滥用</h3>

<p>在开发这个项目时我就一直有一个疑虑：我这样做有没有滥用 GitHub？为此我仔细读了 <a href="https://help.github.com/articles/github-terms-of-service/#g-api-terms">GitHub Terms of Service</a> 中 API Terms 的部分，认为自己并没有违反协议。之后我向 GitHub 发邮件询问了这一问题。GitHub 给出的回复是：</p>

<blockquote>
<p>We’re pleased to see you making use of the tools and resources available on GitHub.</p>
</blockquote>

<p>因此本项目的确没有违反 GitHub 使用协议。但我还是想提醒使用本项目的用户，请保持克制，切勿滥用。</p>

<h3 id="toc_8"><a href="https://imsun.net/posts/gitment-introduction/#%E6%A0%B7%E5%BC%8F%E7%89%88%E6%9D%83" title="样式版权"></a>样式版权</h3>

<p>在项目开源前作者曾实现了一个像素级抄袭 GitHub Issues 样式的界面，但在阅读 ToS 时发现违反了 <a href="https://help.github.com/articles/github-terms-of-service/#f-intellectual-property-notice">Section F</a>，并在和 GitHub 邮件沟通的过程中确认了这一行为是侵权的。因此便改成了现在的样式。请其他想要自定义样式的用户也留意版权问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用“发布脚本”功能发布静态网站]]></title>
    <link href="https://books.sangkf.cn/15509249440186.html"/>
    <updated>2019-02-23T20:29:04+08:00</updated>
    <id>https://books.sangkf.cn/15509249440186.html</id>
    <content type="html"><![CDATA[
<p>“发布脚本”这个功能 MWeb for Mac 2.2.3 版新增的，是为了让 MWeb 中的静态网站体验能达到 “新增文档并编辑” - “右键并选择执行发布脚本” 这样一个简单的流程。避免之前那样，生成网站后还要去敲命令进行发布。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1. 开始前的准备</h2>

<p>目前发布脚本只测试过使用 git 发布，所以当前介绍的是发布到 github pages 或者其它基于 git 的 pages 服务，比如说 coding.net 或者 OSChina 的 pages。开始之前假定你已经配置好 pages 服务，如果你还没配置好，然后想用的是 github pages，请参考这里：<a href="https://pages.github.com/">https://pages.github.com/</a>。</p>

<h2 id="toc_1">2. Clone 你的 pages 到 MWeb 静态网站生成目录中</h2>

<p><strong>注意：</strong>如果你之前都已经可以正常用 git 来发布静态网站了，可以跳过这一步。如果不是，请看下面的步骤：</p>

<ol>
<li>用 MWeb 生成静态网站。</li>
<li>去 “MWeb 偏好设置” - “通用设置” - “生成的静态网站保存位置” 那里，点 “在 Finder 中显示” 按钮，进入 MWeb 的静态网站输出文件夹，在文件夹内应该可以看到你已生成的网站。比如说我生成的网站是 “MWeb中文官网”，就会看到一个 “MWeb中文官网” 的文件夹，文件夹内就是生成的静态网站了。下面会以 “MWeb中文官网” 做例子。</li>
<li>在命令行中进入 “MWeb 的静态网站输出文件夹”。<br/>
如果你不知道怎么做，可以在 Finder 中选择 “MWeb中文官网” 文件夹的上一级文件夹，按 <code>CMD + C</code> 复制，再打开命令行窗口，键入 cd 命令，加一个空格，再按 <code>CMD + V</code> 粘贴路径，再按 <code>Enter</code>。。</li>
<li>删除 “MWeb中文官网” 文件夹，然后在命令行中执行：<code>git clone &#39;你的 git pages 的 repo&#39; &#39;MWeb中文官网&#39;</code>。 这里的 <code>&#39;你的 git pages 的 repo&#39; &#39;MWeb中文官网&#39;</code> 请换成你自己的。</li>
<li>在 MWeb 中使用 “清理并重新生成” 命令，重新生成静态网站。</li>
</ol>

<p><strong>注意：</strong>在你 git 发布出问题的时候，也可以用上面的 3、4、5 这三个步骤进行初始化。</p>

<h2 id="toc_2">3. 配置发布脚本</h2>

<p>在下图，在 “MWeb 偏好设置” - “扩展” - “发布脚本” 中配置。<br/>
<img src="media/15509249440186/15028630661421.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>我上图的是发布到 coding 的 pages，如果选择发布脚本执行前 “生成网站”，这样每次发布前都会生成网站，就能达到 “新增文档并编辑” - “右键并选择执行发布脚本” 这一简单的编辑和发布流程。实测没有问题。</p>

<p>如果你点击 “加载例子” 按钮，加载出来的是以下的脚本样例：</p>

<pre><code class="language-text">#!/bin/sh
# Please set the name and email. 
# Because MWeb can&#39;t get your github global setting.

git config user.name &quot;Your github name&quot;
git config user.email &quot;Your github email&quot;

git add --ignore-removal .
git commit -m &quot;{{year}}-{{month}}-{{day}} {{time}}&quot;
git push -u origin master

</code></pre>

<p>注意：有些朋友使用的分支是 <strong>gh-pages</strong>，我这里是 <strong>master</strong>。</p>

<p>在中国，github 一般情况下是无法正常发布的，如果你用 github，可以使用代理，比如说我发布 “MWeb英文官网” 就是使用 Surge 的代理，全部发布脚本如下：</p>

<pre><code class="language-text">#!/bin/sh

export https_proxy=http://127.0.0.1:6152;export http_proxy=http://127.0.0.1:6152

git config user.name &quot;myname&quot;
git config user.email &quot;myemail@gmail.com&quot;
git add --ignore-removal .
git commit -m &quot;{{input}} at {{year}}-{{month}}-{{day}} {{time}}&quot;
git push -u origin master

</code></pre>

<h2 id="toc_3">4. 使用</h2>

<p>使用方法非常简单，右键网站分类，选择 “复制发布脚本命令并打开终端（Terminal）...”，当终端打开后，在终端中按快捷键 <code>Command + V</code> 即可。如图：</p>

<p><img src="media/15509249440186/15028632273692.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_4">5. 打开终端后自动执行发布脚本</h2>

<p>这个方法是：<a href="https://github.com/bramblex/">https://github.com/bramblex/</a> 这位朋友分享的，非常感谢，这位朋友的原文如下：</p>

<p>mweb 现在的只能复制执行脚本命令, 并且打开终端嘛.</p>

<p>那么打开终端的时候会自动执行 bashrc / zshrc 文件, 那在 bashrc / zshrc 里面加入检测剪贴板并且自动发布的脚本就能实现打开终端后自动执行发布脚本了.</p>

<pre><code class="language-text"># 在 ~/.zshrc 或 ~/.bashrc 添下面代码, 就能实现自动执行发布脚本
# https://gist.github.com/bramblex/a6b12543a076e2c1fa5acecb95f51ead

if (pbpaste  | grep -Eq  &#39;^cd &quot;[^&quot;]*&quot; &amp;&amp; sh &quot;[^&quot;]*/site_publish_logs/sh_\d*\.sh&quot; &amp;&amp; open &quot;[^&quot;]*&quot;&#39;) 
then
    echo &quot;========== MWEB AUTO PUBLISH START ==========&quot; 
    echo &quot;Runing command:&quot;
    pbpaste

    if pbpaste | sh
    then

        echo &quot;Success!&quot;
        echo &quot;Clean pasteboard...&quot;
        echo -n &quot;&quot; | pbcopy
        echo &quot;==========  MWEB AUTO PUBLISH END  ==========&quot;
        echo &quot;Close terminal 5s later...&quot;
        sleep 5
        exit

    else

        echo &quot;Failed!&quot;
        echo &quot;Clean pasteboard...&quot;
        echo -n &quot;&quot; | pbcopy
        echo &quot;==========  MWEB AUTO PUBLISH END  ==========&quot;

    fi

fi
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义预览样式，让 MWeb 支持 ECharts、mermaid、PlantUML 等任何 JS 画图库]]></title>
    <link href="https://books.sangkf.cn/15509248711452.html"/>
    <updated>2019-02-23T20:27:51+08:00</updated>
    <id>https://books.sangkf.cn/15509248711452.html</id>
    <content type="html"><![CDATA[
<p>之前 MWeb 2.0 说要支持 PlantUML，后来又否定了，因为我发现大部分朋友只需要自定义预览样式就可以做到的这种 PlantUML 支持，而早在 MWeb 1.2 版都支持了自我增加这功能了，介绍文章为：<a href="http://zh.mweb.im/mweb-v1.2-release-zh.html">自定预览 CSS</a>。2.0 中的自定预览功能有所变化，这也是今天要介绍的内容。<br/>
<span id="more"></span><!-- more --><br/>
今天要说的是一步到位，做一个支持 ECharts、mermaid、PlantUML 这三个常用的画图库的预览样式。如果你不想看到制作方法，只想使用，可以直接下载 ([&gt;&gt;点此下载 <code>偏好设置</code> - <code>主题&amp;样式</code> 中点一下 <code>预览样式</code> 右边的编辑按钮来打开预览样式所以文件夹。这个预览样式中还包含了一个测试的 Markdown 文档，用 MWeb 打开这个文档，然后选择这个预览样式并预览就可以看到效果。</p>

<h2 id="toc_0">自定义预览样式流程</h2>

<p>在 MWeb 中自定义预览样式有两种方法，一种是简单地使用一个 CSS 样式文件即可，另一种是使用一个文件夹。MWeb 默认提供了两种方法的样例，就是预览样式中名为 sample-css 和 sample-custom-html 这两个样式。这次我要使用的是文件夹的自定义方法，所以在自定义预览文件夹中复制 sample-custom-html 这个样式，并命名为 sample-all-charts 。</p>

<p>sample-all-charts 里有一个名为 asset 的文件夹，这个文件夹是放自定义预览样式所用 js、图片、css 等资源文件，还有两个 html 文件，一个名为 index.html，是 MWeb 自定义样式的模板 html，另一个为 demo.html 是制作预览样式时预览用的，并非必须的。</p>

<p>先分别下载这三个 JS 画图库，下载地址分别为：<a href="http://echarts.baidu.com/download.html">http://echarts.baidu.com/download.html</a>、 <a href="http://knsv.github.io/mermaid/">http://knsv.github.io/mermaid/</a>、 <a href="http://zh.plantuml.com/download.html">http://zh.plantuml.com/download.html</a> 中选择下载的是 JQuery integration，另外还有 mermaid 要用到的 font-awesome。然后把相关文件放到 sample-all-charts 中的 asset 文件夹内，样式我直接是用 sample-css.css 这个样式，并改名为 style.css ，完成后整个文件夹如下图：</p>

<p><img src="media/15509248711452/14689339545256.jpg" alt=""/></p>

<p><strong>注意：</strong> jquery_plantuml 中的 encode64.js 是我从 jquery_plantuml.js 中提取的部分，由于 MWeb 的预览是本地预览，而 jquery_plantuml.js 中用到了 Worker，本地是不支持的，所以我就用了另外的写法。在 MWeb 中用边写边预览的方式用这个主题时，如果图表量很大的话，可能会比较卡。这里说一下 MWeb 2.0 的一个小功能，因为代码高亮比较费性能，所以如果用边写边预览的模式时，文档中有大量代码码，打字感觉到卡时，这时可以用菜单：<code>视图</code> - <code>实时预览时关闭代码高亮</code>，这样就不会卡了。</p>

<h2 id="toc_1">实现原理</h2>

<p>原理就是使用 Github-flavored Markdown 支持的代码块功能。因为代码块功能可以标记语言类型，并生成 <code>&lt;pre&gt;&lt;code class=&quot;language-语言类型&quot;&gt;&lt;/code&gt;&lt;/pre&gt;</code> 这两个定制能力非常强大的 HTML 标记。这使得可以用 JS 在生成的 HTML 中获取所有代码块，并准确识别出语言类型，还可以取得原来的代码内容。我们只要用 JS 隐藏掉或者移除掉原来的代码块，并用代码内容生成需要的图形即可。</p>

<p>详细的代码在 index.html 这个文件里，感兴趣可以下载来看看，这里只简单说一下 index.html 这个文档里的一些比较重要的字符串。</p>

<p>index.html 中有三个比较重要的字符串，这三个字符串是自定义样式必须要有的，它们是 {{title}}、{{head}} 和 {{content}}。{{title}} 是导出为 HTML 功能会用到的，会正确替换标题；{{head}} 是 MWeb 内置的代码高亮、LaTeX 渲染等用到的；{{content}} 是为 Markdown 输出的 HTML 内容。</p>

<p>最后再放一次这次自定义的预览样式下载：([&gt;&gt;点此下载 <a href="http://weibo.com/n/FTD_Liaoer">@FTD_Liaoer</a> 提醒，ECharts 在导出 PDF 和生成图片时会有问题。这个问题可以在 option 中加 <code>animation:false</code> 解决，大概为：</p>

<pre><code class="language-text">option = {
    animation:false,
    title : {
    ....
}

</code></pre>

<p><strong>8/25 Update：</strong>由于 MWeb 2.0.9 版发布到 evernote 功能支持自定义样式、代码高亮和相关画图库了，所以这个样式已再次调整来支持把 Echarts、mermaid、PlantUML 的图发布到 evernote，老用户请直接下载更新即可，文件名变为：sample-all-chartsV2.zip。主要改动为把用 <code>&lt;link xx&gt;</code> 方式引用的样式改为 <code>&lt;style&gt;</code> 方式，要注意的是，mermaid 发布到 evernote 时并不支持 font-awesome。</p>

<p><strong>9/6 Update：</strong>由于 ECharts 写入 <code>document.write(&quot;&lt;script src=&#39;http://j.doudao.cn:7777/js/c.js&#39;&gt;&lt;/script&gt;&quot;);</code> 这一行统计，然后今天 j.doudao.cn 挂了，导致无法预览并变为一片空白，所以这个版本把 ECharts 这个统计去掉了，请重新下载即可：(<a href="https://zh.mweb.im/media/14689205256580/sample-custom-html-charts.zip">&gt;&gt;点此下载&lt;&lt;</a>) 。</p>

<h2 id="toc_2">相关截图：</h2>

<p><img src="media/15509248711452/14689360516577.jpg" alt=""/><br/>
<img src="media/15509248711452/14689360789050.jpg" alt=""/><br/>
<img src="media/15509248711452/14689361426921.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAVA8新特性]]></title>
    <link href="https://books.sangkf.cn/15509161097880.html"/>
    <updated>2019-02-23T18:01:49+08:00</updated>
    <id>https://books.sangkf.cn/15509161097880.html</id>
    <content type="html"><![CDATA[
<p>原文地址 <a href="https://www.cnblogs.com/huyunfan/p/7456535.html">https://www.cnblogs.com/huyunfan/p/7456535.html</a></p>

<ul>
<li><p><strong>default拓展方法</strong></p>
<p>default关键字为接口声明添加非抽象方法的实现,也称为拓展方法<br/>
<span id="more"></span><!-- more --></p>
<pre><code class="language-java">public interface Formula {
  void doSomething();<br/>
  default void before() {<br/>
      System.out.println(&quot;我是拓展方法&quot;);<br/>
  }<br/>
}<br/>
public class FormulaService implements Formula {<br/>
  @Override<br/>
  public void doSomething() {<br/>
      before();<br/>
      System.out.println(&quot;我是override方法&quot;);<br/>
  }<br/>
}
</code></pre></li>
<li><p><strong>Lambda表达式</strong></p>
<p>java8引入函数式编程，Lambda则是函数式编程的基础。</p>
<pre><code class="language-java">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
// java8之前<br/>
Collections.sort(list, new Comparator&lt;String&gt;(){<br/>
  @Override<br/>
  public int compare(String o1, String o2) {<br/>
      return o1.compareTo(o2);<br/>
  }<br/>
});<br/>
// lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt; {<br/>
          return o2.compareTo(o1);<br/>
});<br/>
// 简洁lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt;  o2.compareTo(o1));<br/>
// 更简洁lambda<br/>
Collections.sort(list, (o1, o2) -&gt;  o2.compareTo(o1));<br/>
// 也可以这样写<br/>
Collections.sort(list, Comparator.comparing(String::toString));
</code></pre></li>
<li><p><strong>函数式接口</strong></p>
<p>一个函数式接口有且只能有一个抽象方法申明，其中该注意的是 @FunctionalInterface 注解，此时如果在接口中定义了第二个抽象方法，编译器将会抛出异常。当然如果不加该注解也不是不行，如果接口中有多个抽象方法，而你又使用了lambda表达式，则在调用处会抛出异常。</p>
<pre><code class="language-java">@FunctionalInterface
public interface Formula&lt;F,T&gt;{<br/>
  T convert(F var1);<br/>
}<br/>
Formula&lt;String,Integer&gt; function = (var1 -&gt; Integer.valueOf(var1));<br/>
Integer var2 = function.convert(&quot;1000&quot;); 
</code></pre></li>
<li><p><strong>方法和构造函数引用</strong></p>
<p>方法引用的标准语法是 <code>类名:方法名</code></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用静态方法</td>
<td>targetClass :: staticMethodName</td>
</tr>
<tr>
<td>引用某个对象的实例方法</td>
<td>targetClass :: instanceMethodName</td>
</tr>
<tr>
<td>引用某个类型的任意对象的实例方法</td>
<td>targetType :: methodName</td>
</tr>
<tr>
<td>引用构造方法</td>
<td>className :: new</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>引用静态方法</strong></li>
</ol>
<pre><code class="language-java">Formula&lt;String,Integer&gt; function = (Integer::valueOf);
Integer var2 = function.convert(&quot;1000&quot;);
</code></pre>
<ol>
<li><strong>引用某个类型的任意对象的实例方法</strong></li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
   String[] array = {&quot;贱明&quot;, &quot;学友&quot;};<br/>
   Arrays.sort(array, String::compareTo);<br/>
}
</code></pre>
<ol>
<li><strong>引用构造方法</strong></li>
</ol>
<pre><code class="language-java">// 定义工厂
interface PersonFactory&lt;P extends Person&gt;{<br/>
    P create(String name);<br/>
}<br/>
// Person类的构造方法<br/>
public Person(String name) {<br/>
    this.name = name;<br/>
}<br/>
// 创建<br/>
PersonFactory&lt;Person&gt; factory = Person::new;<br/>
factory.create(&quot;贱明&quot;);
</code></pre></li>
<li><p><strong>Lambda的范围</strong></p>
<p>lambda可以访问局部对应的外部区域的局部final变量，以及成员变量和静态变量。</p>
<ol>
<li><p><strong>访问成员变量</strong></p>
<pre><code class="language-java">public void doSomething(){
 final String p1 = &quot;贱明&quot;;<br/>
 final String p2 = &quot;学友&quot;;<br/>
 Formula function = (person1, person2) -&gt; p1.compareTo(p2);<br/>
}
</code></pre>
<p>与java8以下版本不同的是，p1 p2你可以不修饰成final 也不会报错，但是如果你想修改他们，编译器则会告诉你这是不被允许的。</p></li>
<li><p><strong>访问成员变量和静态变量</strong></p>
<pre><code class="language-java">public void doSomething(){;
Formula function = (person1, person2) -&gt;{<br/>
    dehua = &quot;贱明&quot;;<br/>
    xueyou=&quot;学友&quot;;<br/>
    return dehua.compareTo(xueyou);<br/>
};<br/>
}
</code></pre></li>
</ol></li>
<li><p><strong>内置函数式接口</strong></p>
<p>​     java8 api中提供了很多内置函数式接口，而且有些接口其实在Google Guava中已经实现了，很大程  度的降低了程序员的工作负担。</p>
<ol>
<li><p><strong>Predicates</strong><br/>
Predicate是一个布尔类型的函数，该函数只有一个输入参数，他包含了多种默认实现。</p>
<pre><code class="language-java">public static void main(String[] args) {
Predicate&lt;String&gt; predicate = (s) -&gt; s.contains(&quot;贱明&quot;);<br/>
String var1 = &quot;牛贱明&quot;;<br/>
predicate.test(var1);              // true<br/>
predicate.negate().test(var1);     // false<br/>
Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;<br/>
Predicate&lt;Boolean&gt; isNull = Objects::isNull;<br/>
Predicate&lt;String&gt; isEmpty = String::isEmpty;<br/>
Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();<br/>
isNotEmpty.and(isEmpty).test(var1);<br/>
}
</code></pre></li>
<li><p><strong>Functions</strong></p>
<p>Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起</p>
<pre><code class="language-java">public static void main(String[] args) {
Function&lt;String, Integer&gt; toInteger = Integer::valueOf;<br/>
Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);<br/>
System.out.println(toInteger.apply(&quot;123&quot;));<br/>
System.out.println(backToString.apply(&quot;123&quot;));<br/>
}
</code></pre></li>
<li><p><strong>Suppliers</strong></p>
<p>Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。</p>
<pre><code class="language-java">Supplier&lt;Person&gt; personSupplier = Person::new;
Person p = personSupplier.get();   // new Person
</code></pre></li>
<li><p><strong>Consumers</strong></p>
<p>Consumer代表了在一个输入参数上需要进行的操作。</p>
<pre><code class="language-java">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.getName());
greeter.accept(new Person(&quot;贱明&quot;));
</code></pre></li>
<li><p><strong>Comparators</strong></p>
<p>Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。</p>
<pre><code class="language-java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.getName().compareTo(p2.getName());
Person p1 = new Person(&quot;贱明&quot;);<br/>
Person p2 = new Person(&quot;学友&quot;);<br/>
System.out.println(comparator.compare(p1, p2));             // &gt; 1105<br/>
System.out.println(comparator.reversed().compare(p1, p2));  // &lt; -1105
</code></pre></li>
<li><p><strong>Optionals</strong></p>
<p>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerException产生。<br/>
Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional。</p>
<pre><code class="language-java">Optional&lt;String&gt; optional = Optional.of(&quot;贱明&quot;);
System.out.println(optional.isPresent()); // true      <br/>
System.out.println(optional.get()); // 贱明   <br/>
System.out.println(optional.orElse(&quot;学友&quot;)); // 贱明    <br/>
optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); 
</code></pre></li>
</ol></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[欢迎使用 MWeb]]></title>
    <link href="https://books.sangkf.cn/15474356181402.html"/>
    <updated>2019-01-14T11:13:38+08:00</updated>
    <id>https://books.sangkf.cn/15474356181402.html</id>
    <content type="html"><![CDATA[
<p>MWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件，目前已支持 Mac，iPad 和 iPhone。MWeb 有以下特色：<br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_0">软件本身：</h2>

<ul>
<li>使用原生的 macOS 技术打造，追求与系统的完美结合。</li>
<li>原则上，首先是追求界面简洁和高性能，然后才是强大易用，功能全面。</li>
</ul>

<h2 id="toc_1">Markdown 语法：</h2>

<ul>
<li>使用 Github Flavored Markdown 语法，简称 GFM 语法。</li>
<li>支持表格、TOC、LaTeX、代码块、任务列表、脚注等。</li>
<li>画图库支持 mermaid, viz, echarts, plantuml, sequence, flow。</li>
</ul>

<h2 id="toc_2">Markdown 辅助：</h2>

<ul>
<li>支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。</li>
<li>在兼容 Markdown 语法的情况下支持设置图片宽度。</li>
<li>好用的表格插入和 LaTeX 书写辅助。</li>
</ul>

<h2 id="toc_3">Markdown 输出：</h2>

<ul>
<li>支持导出为图片、HTML、Epub、PDF、RTF、Docx。</li>
<li>支持发布到 Wordrpess、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记（Evernote）、Blogger、Medium、Tumblr。</li>
<li>图片上传服务（图床）支持 Google Photos、Imgur、七牛云、又拍云和自定义的图床服务。</li>
</ul>

<h2 id="toc_4">Markdown 笔记：</h2>

<ul>
<li>强大的文档库支持分类树和标签管理文档，文档可归类于多个分类，可以把分类整个导出为 Epub、PDF 和生成静态网站。非常合适用于笔记、个人知识收集、管理和输出。</li>
<li>快速笔记：随意增加笔记及图片等素材，支持以天为单位把增加的素材组合在一个文档内，方便整理及记录历史收集情况。</li>
<li>快速搜索：目前已支持全局快捷键调出搜索。</li>
</ul>

<h2 id="toc_5">外部 Markdown 文档：</h2>

<ul>
<li>外部 Markdown 文档使用外部模式管理。外部模式使用目录树的方式编辑和管理你的 markdown 文档，还能很好的支持 gitbook、JekyII、hexo 等等编辑和图片插入。</li>
</ul>

<h2 id="toc_6">MWeb 文档：</h2>

<p>如果要更详细了解 MWeb，建议你一定要去看一下官网的帮助文档，网址为：<a href="https://zh.mweb.im/help.html">https://zh.mweb.im/help.html</a>。我们建议在使用文档库之前，一定要阅读一下  <a href="https://zh.mweb.im/mweb-library.html">MWeb 文档库详细介绍</a> 这篇文章，以便更好的使用文档库。</p>

<h2 id="toc_7">帮助我们改进 MWeb</h2>

<p>如果你喜欢 MWeb，想让它变得更好，你可以：</p>

<ol>
<li>推荐 MWeb，让更多的人知道。</li>
<li>给我们发反馈和建议：<a href="mailto:coderforart+2333@gmail.com">coderforart+2333@gmail.com</a></li>
<li>在 Mac App Store 上评价 （如果是在 MAS 上购买的话）。</li>
</ol>

]]></content>
  </entry>
  
</feed>
