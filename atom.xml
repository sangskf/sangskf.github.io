<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[见课就上的小婊砸]]></title>
  <link href="https://books.sangkf.cn/atom.xml" rel="self"/>
  <link href="https://books.sangkf.cn/"/>
  <updated>2019-05-30T14:21:44+08:00</updated>
  <id>https://books.sangkf.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[java同步系列之JMM（Java Memory Model）]]></title>
    <link href="https://books.sangkf.cn/15582712510625.html"/>
    <updated>2019-05-19T21:07:31+08:00</updated>
    <id>https://books.sangkf.cn/15582712510625.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Java内存模型是在硬件内存模型上的更高层的抽象，它屏蔽了各种硬件和操作系统访问的差异性，保证了Java程序在各种平台下对内存的访问都能达到一致的效果。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">简介</h2>

<p>Java内存模型是在硬件内存模型上的更高层的抽象，它屏蔽了各种硬件和操作系统访问的差异性，保证了Java程序在各种平台下对内存的访问都能达到一致的效果。</p>

<h2 id="toc_1">硬件内存模型</h2>

<p>在正式讲解Java的内存模型之前，我们有必要先了解一下硬件层面的一些东西。</p>

<p>在现代计算机的硬件体系中，CPU的运算速度是非常快的，远远高于它从存储介质读取数据的速度，这里的存储介质有很多，比如磁盘、光盘、网卡、内存等，这些存储介质有一个很明显的特点——距离CPU越近的存储介质往往越小越贵越快，距离CPU越远的存储介质往往越大越便宜越慢。</p>

<p>所以，在程序运行的过程中，CPU大部分时间都浪费在了磁盘IO、网络通讯、数据库访问上，如果不想让CPU在那里白白等待，我们就必须想办法去把CPU的运算能力压榨出来，否则就会造成很大的浪费，而让CPU同时去处理多项任务则是最容易想到的，也是被证明非常有效的压榨手段，这也就是我们常说的“并发执行”。</p>

<p>但是，让CPU并发地执行多项任务并不是那么容易实现的事，因为所有的运算都不可能只依靠CPU的计算就能完成，往往还需要跟内存进行交互，如读取运算数据、存储运算结果等。</p>

<p>前面我们也说过了，CPU与内存的交互往往是很慢的，所以这就要求我们要想办法在CPU和内存之间建立一种连接，使它们达到一种平衡，让运算能快速地进行，而这种连接就是我们常说的“高速缓存”。</p>

<p>高速缓存的速度是非常接近CPU的，但是它的引入又带来了新的问题，现代的CPU往往是有多个核心的，每个核心都有自己的缓存，而多个核心之间是不存在时间片的竞争的，它们可以并行地执行，那么，怎么保证这些缓存与主内存中的数据的一致性就成为了一个难题。</p>

<p>为了解决缓存一致性的问题，多个核心在访问缓存时要遵循一些协议，在读写操作时根据协议来操作，这些协议有MSI、MESI、MOSI等，它们定义了何时应该访问缓存中的数据、何时应该让缓存失效、何时应该访问主内存中的数据等基本原则。</p>

<p><img src="media/15582712510625/JMM1.png" alt="JMM"/></p>

<p>而随着CPU能力的不断提升，一层缓存就无法满足要求了，就逐渐衍生出了多级缓存。</p>

<p>按照数据读取顺序和CPU的紧密程度，CPU的缓存可以分为一级缓存（L1）、二级缓存（L2）、三级缓存（L3），每一级缓存存储的数据都是下一级的一部分。</p>

<p>这三种缓存的技术难度和制作成本是相对递减的，容量也是相对递增的。</p>

<p>所以，在有了多级缓存后，程序的运行就变成了：</p>

<p>当CPU要读取一个数据的时候，先从一级缓存中查找，如果没找到再从二级缓存中查找，如果没找到再从三级缓存中查找，如果没找到再从主内存中查找，然后再把找到的数据依次加载到多级缓存中，下次再使用相关的数据直接从缓存中查找即可。</p>

<p>而加载到缓存中的数据也不是说用到哪个就加载哪个，而是加载内存中连续的数据，一般来说是加载连续的64个字节，因此，如果访问一个 long 类型的数组时，当数组中的一个值被加载到缓存中时，另外 7 个元素也会被加载到缓存中，这就是“缓存行”的概念。</p>

<p><img src="media/15582712510625/JMM2.png" alt="JMM"/></p>

<p>缓存行虽然能极大地提高程序运行的效率，但是在多线程对共享变量的访问过程中又带来了新的问题，也就是非常著名的“伪共享”。</p>

<p>关于伪共享的问题，我们这里就不展开讲了，有兴趣的可以看彤哥之前发布的【<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Frd13SOSxhLA6TT13N9ni8Q">杂谈 什么是伪共享（false sharing）？</a>】章节的相关内容。</p>

<p>除此之外，为了使CPU中的运算单元能够充分地被利用，CPU可能会对输入的代码进行乱序执行优化，然后在计算之后再将乱序执行的结果进行重组，保证该结果与顺序执行的结果一致，但并不保证程序中各个语句计算的先后顺序与代码的输入顺序一致，因此，如果一个计算任务依赖于另一个计算任务的结果，那么其顺序性并不能靠代码的先后顺序来保证。</p>

<p>与CPU的乱序执行优化类似，java虚拟机的即时编译器也有类似的指令重排序优化。</p>

<p>为了解决上面提到的多个缓存读写一致性以及乱序排序优化的问题，这就有了内存模型，它定义了共享内存系统中多线程读写操作行为的规范。</p>

<h2 id="toc_2">Java内存模型</h2>

<p>Java内存模型（Java Memory Model，JMM）是在硬件内存模型基础上更高层的抽象，它屏蔽了各种硬件和操作系统对内存访问的差异性，从而实现让Java程序在各种平台下都能达到一致的并发效果。</p>

<p>Java内存模型定义了程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。这里所说的变量包括实例字段、静态字段，但不包括局部变量和方法参数，因为它们是线程私有的，它们不会被共享，自然不存在竞争问题。</p>

<p>为了获得更好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码的执行顺序等这类权利。</p>

<p>Java内存模型规定了所有的变量都存储在主内存中，这里的主内存跟介绍硬件时所用的名字一样，两者可以类比，但此处仅指虚拟机中内存的一部分。</p>

<p>除了主内存，每条线程还有自己的工作内存，此处可与CPU的高速缓存进行类比。工作内存中保存着该线程使用到的变量的主内存副本的拷贝，线程对变量的操作都必须在工作内存中进行，包括读取和赋值等，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递必须通过主内存来完成。</p>

<p>线程、工作内存、主内存三者的关系如下图所示：</p>

<p><img src="media/15582712510625/JMM3.png" alt="JMM"/></p>

<p>注意，这里所说的主内存、工作内存跟Java虚拟机内存区域划分中的堆、栈是不同层次的内存划分，如果两者一定要勉强对应起来，主内存主要对应于堆中对象的实例部分，而工作内存主要对应与虚拟机栈中的部分区域。</p>

<p>从更低层次来说，主内存主要对应于硬件内存部分，工作内存主要对应于CPU的高速缓存和寄存器部分，但也不是绝对的，主内存也可能存在于高速缓存和寄存器中，工作内存也可能存在于硬件内存中。</p>

<p><img src="media/15582712510625/JMM4.png" alt="JMM"/></p>

<h2 id="toc_3">内存间的交互操作</h2>

<p>关于主内存与工作内存之间具体的交互协议，Java内存模型定义了以下8种具体的操作来完成：</p>

<p>（1）lock，锁定，作用于主内存的变量，它把主内存中的变量标识为一条线程独占状态；</p>

<p>（2）unlock，解锁，作用于主内存的变量，它把锁定的变量释放出来，释放出来的变量才可以被其它线程锁定；</p>

<p>（3）read，读取，作用于主内存的变量，它把一个变量从主内存传输到工作内存中，以便后续的load操作使用；</p>

<p>（4）load，载入，作用于工作内存的变量，它把read操作从主内存得到的变量放入工作内存的变量副本中；</p>

<p>（5）use，使用，作用于工作内存的变量，它把工作内存中的一个变量传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；</p>

<p>（6）assign，赋值，作用于工作内存的变量，它把一个从执行引擎接收到的变量赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时使用这个操作；</p>

<p>（7）store，存储，作用于工作内存的变量，它把工作内存中一个变量的值传递到主内存中，以便后续的write操作使用；</p>

<p>（8）write，写入，作用于主内存的变量，它把store操作从工作内存得到的变量的值放入到主内存的变量中；</p>

<p>如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，同样地，如果要把一个变量从工作内存同步回主内存，就要按顺序地执行store和write操作。注意，这里只说明了要按顺序，并没有说一定要连续，也就是说可以在read与load之间、store与write之间插入其它操作。比如，对主内存中的变量a和b的访问，可以按照以下顺序执行：</p>

<p>read a -&gt; read b -&gt; load b -&gt; load a。</p>

<p>另外，Java内存模型还定义了执行上述8种操作的基本规则：</p>

<p>（1）不允许read和load、store和write操作之一单独出现，即不允许出现从主内存读取了而工作内存不接受，或者从工作内存回写了但主内存不接受的情况出现；</p>

<p>（2）不允许一个线程丢弃它最近的assign操作，即变量在工作内存变化了必须把该变化同步回主内存；</p>

<p>（3）不允许一个线程无原因地（即未发生过assign操作）把一个变量从工作内存同步回主内存；</p>

<p>（4）一个新的变量必须在主内存中诞生，不允许工作内存中直接使用一个未被初始化（load或assign）过的变量，换句话说就是对一个变量的use和store操作之前必须执行过load和assign操作；</p>

<p>（5）一个变量同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才能被解锁。</p>

<p>（6）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值；</p>

<p>（7）如果一个变量没有被lock操作锁定，则不允许对其执行unlock操作，也不允许unlock一个其它线程锁定的变量；</p>

<p>（8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作；</p>

<p>注意，这里的lock和unlock是实现synchronized的基础，Java并没有把lock和unlock操作直接开放给用户使用，但是却提供了两个更高层次的指令来隐式地使用这两个操作，即moniterenter和moniterexit。</p>

<h2 id="toc_4">原子性、可见性、有序性</h2>

<p>Java内存模型就是为了解决多线程环境下共享变量的一致性问题，那么一致性包含哪些内容呢？</p>

<p>一致性主要包含三大特性：原子性、可见性、有序性，下面我们就来看看Java内存模型是怎么实现这三大特性的。</p>

<p>（1）原子性</p>

<p>原子性是指一段操作一旦开始就会一直运行到底，中间不会被其它线程打断，这段操作可以是一个操作，也可以是多个操作。</p>

<p>由Java内存模型来直接保证的原子性操作包括read、load、user、assign、store、write这两个操作，我们可以大致认为基本类型变量的读写是具备原子性的。</p>

<p>如果应用需要一个更大范围的原子性，Java内存模型还提供了lock和unlock这两个操作来满足这种需求，尽管不能直接使用这两个操作，但我们可以使用它们更具体的实现synchronized来实现。</p>

<p>因此，synchronized块之间的操作也是原子性的。</p>

<p>（2）可见性</p>

<p>可见性是指当一个线程修改了共享变量的值，其它线程能立即感知到这种变化。</p>

<p>Java内存模型是通过在变更修改后同步回主内存，在变量读取前从主内存刷新变量值来实现的，它是依赖主内存的，无论是普通变量还是volatile变量都是如此。</p>

<p>普通变量与volatile变量的主要区别是是否会在修改之后立即同步回主内存，以及是否在每次读取前立即从主内存刷新。因此我们可以说volatile变量保证了多线程环境下变量的可见性，但普通变量不能保证这一点。</p>

<p>除了volatile之外，还有两个关键字也可以保证可见性，它们是synchronized和final。</p>

<p>synchronized的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作”这条规则获取的。</p>

<p>final的可见性是指被final修饰的字段在构造器中一旦被初始化完成，那么其它线程中就能看见这个final字段了。</p>

<p>（3）有序性</p>

<p>Java程序中天然的有序性可以总结为一句话：如果在本线程中观察，所有的操作都是有序的；如果在另一个线程中观察，所有的操作都是无序的。</p>

<p>前半句是指线程内表现为串行的语义，后半句是指“指令重排序”现象和“工作内存和主内存同步延迟”现象。</p>

<p>Java中提供了volatile和synchronized两个关键字来保证有序性。</p>

<p>volatile天然就具有有序性，因为其禁止重排序。</p>

<p>synchronized的有序性是由“一个变量同一时刻只允许一条线程对其进行lock操作”这条规则获取的。</p>

<h2 id="toc_5">先行发生原则（Happens-Before）</h2>

<p>如果Java内存模型的有序性都只依靠volatile和synchronized来完成，那么有一些操作就会变得很啰嗦，但是我们在编写Java并发代码时并没有感受到，这是因为Java语言天然定义了一个“先行发生”原则，这个原则非常重要，依靠这个原则我们可以很容易地判断在并发环境下两个操作是否可能存在竞争冲突问题。</p>

<p>先行发生，是指操作A先行发生于操作B，那么操作A产生的影响能够被操作B感知到，这种影响包括修改了共享内存中变量的值、发送了消息、调用了方法等。</p>

<p>下面我们看看Java内存模型定义的先行发生原则有哪些：</p>

<p>（1）程序次序原则</p>

<p>在一个线程内，按照程序书写的顺序执行，书写在前面的操作先行发生于书写在后面的操作，准确地讲是控制流顺序而不是代码顺序，因为要考虑分支、循环等情况。</p>

<p>（2）监视器锁定原则</p>

<p>一个unlock操作先行发生于后面对同一个锁的lock操作。</p>

<p>（3）volatile原则</p>

<p>对一个volatile变量的写操作先行发生于后面对该变量的读操作。</p>

<p>（4）线程启动原则</p>

<p>对线程的start()操作先行发生于线程内的任何操作。</p>

<p>（5）线程终止原则</p>

<p>线程中的所有操作先行发生于检测到线程终止，可以通过Thread.join()、Thread.isAlive()的返回值检测线程是否已经终止。</p>

<p>（6）线程中断原则</p>

<p>对线程的interrupt()的调用先行发生于线程的代码中检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否发生中断。</p>

<p>（7）对象终结原则</p>

<p>一个对象的初始化完成（构造方法执行结束）先行发生于它的finalize()方法的开始。</p>

<p>（8）传递性原则</p>

<p>如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。</p>

<p>这里说的“先行发生”与“时间上的先发生”没有必然的关系。</p>

<p>比如，下面的代码：</p>

<pre><code class="language-text">int a = 0;

// 操作A：线程1对进行赋值操作
a = 1;

// 操作B：线程2获取a的值

int b = a;
复制代码
</code></pre>

<p>如果线程1在时间顺序上先对a进行赋值，然后线程2再获取a的值，这能说明操作A先行发生于操作B吗？</p>

<p>显然不能，因为线程2可能读取的还是其工作内存中的值，或者说线程1并没有把a的值刷新回主内存呢，这时候线程2读取到的值可能还是0。</p>

<p>所以，“时间上的先发生”不一定“先行发生”。</p>

<p>再看一个例子：</p>

<pre><code class="language-text">// 同一个线程中
int i = 1;

int j = 2;
复制代码
</code></pre>

<p>根据第一条程序次序原则，<code>int i = 1;</code>先行发生于<code>int j = 2;</code>，但是由于处理器优化，可能导致<code>int j = 2;</code>先执行，但是这并不影响先行发生原则的正确性，因为我们在这个线程中并不会感知到这点。</p>

<p>所以，“先行发生”不一定“时间上先发生”。</p>

<h2 id="toc_6">总结</h2>

<p>（1）硬件内存架构使得我们必须建立内存模型来保证多线程环境下对共享内存访问的正确性；</p>

<p>（2）Java内存模型定义了保证多线程环境下共享变量一致性的规则；</p>

<p>（3）Java内存模型提供了工作内存与主内存交互的8大操作：lock、unlock、read、load、use、assign、store、write；</p>

<p>（4）Java内存模型对原子性、可见性、有序性提供了一些实现；</p>

<p>（5）先行发生的8大原则：程序次序原则、监视器锁定原则、volatile原则、线程启动原则、线程终止原则、线程中断原则、对象终结原则、传递性原则；</p>

<p>（6）先行发生不等于时间上的先发生；</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java基础]]></title>
    <link href="https://books.sangkf.cn/15572119419279.html"/>
    <updated>2019-05-07T14:52:21+08:00</updated>
    <id>https://books.sangkf.cn/15572119419279.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">String不可变的好处</h2>

<ul>
<li>可以缓存hash值</li>
<li>String Pool的需要</li>
<li>线程安全</li>
<li>安全性(网络传输安全性)</li>
</ul>

<h3 id="toc_1">String字符串用 <code>+</code> 拼接和用 <code>StringBuilder</code> 拼接的差别</h3>

<h3 id="toc_2">JDK6 和 JDK7 中String调用intern()方法的差别</h3>

<p><a href="">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p>

<h2 id="toc_3">抽象类和接口的区别</h2>

<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>

<h2 id="toc_4">Exception 和 Error</h2>

<p>Throwable<br/>
Exception Error </p>

<h2 id="toc_5">运行时数据区</h2>

<p><img src="media/15572119419279/15574558914736.jpg" alt=""/></p>

<h3 id="toc_6">堆</h3>

<p>所有对象都在这里分配内存，是垃圾收集的主要区域（&quot;GC 堆&quot;）。</p>

<h3 id="toc_7">方法区(包含运行时常量池)</h3>

<p>用于存储已被加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。<br/>
对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。<br/>
JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收。但是从 JDK 1.7 开始，已经把原本放在永久代的字符串常量池移到 Native Method 中。</p>

<h3 id="toc_8">程序计数器</h3>

<p>记录正在执行的虚拟机字节码指令的地址（如果执行的是本地方法则为空）</p>

<h3 id="toc_9">虚拟机栈</h3>

<p>每个Java方法在执行的同时会创建一个栈桢用于存储局部变量表，操作数栈，常量池引用信息，从调用直至执行完成的过程，就对应着一个栈桢在Java虚拟机栈中入栈和出栈的过程。<br/>
<img src="media/15572119419279/15573949164151.jpg" alt="" style="width:490px;"/></p>

<h3 id="toc_10">本地方法栈</h3>

<h2 id="toc_11">垃圾收集算法</h2>

<p>如何判断一个对象是否可以被回收</p>

<h3 id="toc_12">引用计数法</h3>

<p>给对象添加一个引用计数器，当对象增加一个引用，计数器加1，引用失效时计数器减1，引用计数为0时，该对象可回收。</p>

<p>两个对象出现循环引用的情况下，此时对象的计数器永不为0,导致无法对他们进行回收</p>

<h3 id="toc_13">可达性分析算法</h3>

<p>通过GC Roots作为起始点进行搜索，能够到达的对象都是存活的，不可达的对象被回收。</p>

<p>GC Roots包括如下4种:</p>

<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>

<h2 id="toc_14">方法区的回收</h2>

<p>主要是对常量池的回收和对类的卸载。</p>

<h2 id="toc_15">引用类型</h2>

<p>判断对象是否可被回收与引用有关。</p>

<ul>
<li>被强引用关联的对象不会被回收 (new 建立的强引用)</li>
<li>被软引用关联的对象只有在内存不够的情况下才会被回收 (使用 SoftReference类来创建软引用)</li>
<li>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前 (WeakReference)</li>
<li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象 (PhantomReference,为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知)</li>
</ul>

<h2 id="toc_16">垃圾回收算法</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式]]></title>
    <link href="https://books.sangkf.cn/15571066386287.html"/>
    <updated>2019-05-06T09:37:18+08:00</updated>
    <id>https://books.sangkf.cn/15571066386287.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>[转载] <a href="https://www.cnblogs.com/dolphin0520/p/3919839.html">https://www.cnblogs.com/dolphin0520/p/3919839.html</a></p>

<p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p>
</blockquote>

<p>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">六大原则</h2>

<h3 id="toc_1">单一职责原则</h3>

<blockquote>
<p>一个类只负责一个功能领域中的相应职责,或者可以定义为: 就一个类而言，应该只有一个引起它变化的原因.</p>
</blockquote>

<p>单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p>

<p><strong>单一职责原则是实现高内聚，低耦合的指导方针</strong></p>

<h3 id="toc_2">开闭原则</h3>

<blockquote>
<p>一个软件实体应当对扩展开放，对修改关闭. 即软件实体应尽量在不修改原有代码的情况下进行扩展.</p>
</blockquote>

<p>在开闭原则的定义中，<strong>软件实体可以指一个软件模块，一个由多个类组成的局部结构或者一个独立的类</strong></p>

<p>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p>

<p>为了满足开闭原则，需要对系统进行抽象化设计，<strong>抽象化是开闭原则的关键</strong>.在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p>

<h3 id="toc_3">里氏代换原则</h3>

<blockquote>
<p>所有引用基类(父类)的地方必须能够透明地使用其子类的对象.</p>
</blockquote>

<p>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么他一定能够使用基类对象。</p>

<p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</strong></p>

<p>在使用里氏代换原则时需要注意如下几个问题：</p>

<p>(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</p>

<p>(2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</p>

<p>(3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</p>

<h3 id="toc_4">依赖倒转原则</h3>

<blockquote>
<p>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程</p>
</blockquote>

<p><strong>依赖倒转原则要求我们在程序中传递参数或在关联关系中, 尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明, 参数类型声明，方法返回类型声明，以及数据类型转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用在子类中增加的新方法。</strong></p>

<p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p>

<p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过<strong>依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</strong></p>

<h3 id="toc_5">接口隔离原则</h3>

<blockquote>
<p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口</p>
</blockquote>

<p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。<strong>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</strong>这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p>

<p>(1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。</p>

<p>(2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指<strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口</strong>。</p>

<p><strong>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</strong></p>

<h3 id="toc_6">迪米特法则</h3>

<blockquote>
<p>一个软件实体应当尽可能少地与其他实体发生相互作用。</p>
</blockquote>

<p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p>

<p>在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p>

<p>最后绘图记录下</p>

<p><img src="media/15571066386287/15571352889083.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 常用命令]]></title>
    <link href="https://books.sangkf.cn/15570460893713.html"/>
    <updated>2019-05-05T16:48:09+08:00</updated>
    <id>https://books.sangkf.cn/15570460893713.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>[来源] <a href="https://gitee.com/all-about-git">https://gitee.com/all-about-git</a><br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_0">仓库</h2>
</blockquote>

<pre><code class="language-shell"># 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
</code></pre>

<h2 id="toc_1">配置</h2>

<pre><code class="language-shell"># 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
</code></pre>

<h2 id="toc_2">增加/删除文件</h2>

<pre><code class="language-shell"># 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
</code></pre>

<h2 id="toc_3">代码提交</h2>

<pre><code class="language-shell"># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre>

<h2 id="toc_4">分支</h2>

<pre><code class="language-shell"># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre>

<h2 id="toc_5">标签</h2>

<pre><code class="language-shell"># 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
</code></pre>

<h2 id="toc_6">查看信息</h2>

<pre><code class="language-shell"># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre>

<h2 id="toc_7">远程同步</h2>

<pre><code class="language-shell"># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre>

<h2 id="toc_8">撤销</h2>

<pre><code class="language-shell"># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre>

<h2 id="toc_9">其他</h2>

<pre><code class="language-shell"># 生成一个可供发布的压缩包
$ git archive
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis为什么是单线程?为什么有如此高的性能?]]></title>
    <link href="https://books.sangkf.cn/15570185321113.html"/>
    <updated>2019-05-05T09:08:52+08:00</updated>
    <id>https://books.sangkf.cn/15570185321113.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><strong>转载</strong> <a href="https://blog.csdn.net/u013328047/article/details/82229710">https://blog.csdn.net/u013328047/article/details/82229710</a></p>
</blockquote>

<span id="more"></span><!-- more --> 

<h2 id="toc_0">Redis为什么是单线程</h2>

<p>注意: redis单线程指的是网络请求模块使用了一个线程,即一个线程处理所有的网络请求，其他模块仍用了多个线程。</p>

<p>因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽，既然单线程容易实现，而且CPU不会成为瓶颈，那么顺理成章地采用单线程的方案了。 </p>

<h2 id="toc_1">Redis为什么这么快</h2>

<p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>

<p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>

<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>

<p>4、使用多路I/O复用模型，非阻塞IO；</p>

<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>

<h2 id="toc_2">多路I/O复用模型，非阻塞IO</h2>

<p>下面举一个例子，模拟一个tcp服务器处理30个客户socket。<br/>
假设你是一个监考老师，让30个学生解答一道竞赛考题，然后负责验收学生答卷，你有下面几个选择：</p>

<ol>
<li>第一种选择：按顺序逐个验收，先验收A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。<br/>
这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</li>
<li>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</li>
<li>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。<br/>
这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。<br/>
这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。</li>
</ol>

<p><strong>针对上面的举例在Redis中表现为</strong></p>

<p>有30个redis客户端（考生）与redis服务器的网络连接模块（监考老师）保持TCP连接，客户端会不定时的发送请求给服务器，当有一个redis客户端发起请求，会触发unix系统像epoll这样的系统调用，Redis的I/O 多路复用模块封装了底层的epoll这样的 I/O 多路复用函数，然后转发到相应的事件处理器。</p>

<p>最后多路I/O复用模型图</p>

<p>redis-reactor-pattern</p>

<p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD（文件描述符），当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p>

<p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。</p>

<h2 id="toc_3">参考文章：</h2>

<p>1、<a href="https://blog.csdn.net/xlgen157387/article/details/79470556">https://blog.csdn.net/xlgen157387/article/details/79470556</a><br/>
2、<a href="https://draveness.me/redis-io-multiplexing">https://draveness.me/redis-io-multiplexing</a><br/>
3、<a href="https://www.zhihu.com/question/28594409">https://www.zhihu.com/question/28594409</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java资源大全中文版]]></title>
    <link href="https://books.sangkf.cn/15569696449715.html"/>
    <updated>2019-05-04T19:34:04+08:00</updated>
    <id>https://books.sangkf.cn/15569696449715.html</id>
    <content type="html"><![CDATA[
<p>我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。<a href="https://github.com/akullpp/awesome-java">awesome-java</a> 就是 akullpp 发起维护的 Java 资源列表，内容包括：构建工具、数据库、框架、模板、安全、代码分析、日志、第三方库、书籍、Java 站点等等。伯乐在线已经把 awesome-java 资源列表翻成中文后发布于 <a href="http://www.importnew.com/14429.html">ImportNew</a>。<br/>
<span id="more"></span><!-- more --><br/>
Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p>

<hr/>

<h3 id="toc_0">我们要做什么？</h3>

<ul>
<li>基于 awesome-java 资源列表，我们将对各个资源项进行编译整理。</li>
<li><p>整理后的内容，将收录在<a href="http://hao.jobbole.com/">伯乐在线资源频道</a>。可参考已整理的内容：</p>
<ul>
<li>《<a href="http://hao.jobbole.com/owner/">OWNER：Java配置文件解决方案</a>》</li>
<li>《<a href="http://hao.jobbole.com/spring-boot/">Spring Boot：简化Spring应用初始搭建以及开发过程</a>》</li>
<li>《<a href="http://hao.jobbole.com/sonarqube/">SonarQube：开源的代码质量管理工具</a>》</li>
</ul></li>
<li><ul>
<li>*</li>
</ul></li>
</ul>

<h3 id="toc_1">如何参与本项目？</h3>

<p>从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。</p>

<p>不过加入前，有几个小要求：</p>

<ul>
<li>英文还不错，能读懂英文并用自己的话复述；</li>
<li>在用 Java；</li>
</ul>

<p>如有兴趣，请加 QQ：50872495。加 Q 时请注明「Java大全」</p>

<hr/>

<h3 id="toc_2">如何为列表贡献新资源？</h3>

<p>欢迎大家为列表贡献高质量的新资源，提交PR时请参照以下要求：</p>

<ul>
<li>请确保推荐的资源自己使用过</li>
<li>提交PR时请注明推荐理由</li>
</ul>

<p>资源列表管理收到PR请求后，会定期（每周）在微博转发本周提交的PR列表，并在微博上面听取使用过这些资源的意见。确认通过后，会加入资源大全。</p>

<p>感谢您的贡献！</p>

<hr/>

<h3 id="toc_3">本项目的参与者</h3>

<ul>
<li><p>维护者：<a href="https://github.com/tangyouhua">tangyouhua</a></p></li>
<li><p>贡献者：<a href="https://github.com/tangyouhua">tangyouhua</a>、<a href="https://github.com/kingzone">kingzone</a>、<a href="https://github.com/llhua2329">llhua2329</a>、<a href="https://github.com/BadCoderChou">BadCoderChou</a>、<a href="http://www.jobbole.com/members/anankun/">anankun</a>、<a href="http://www.jobbole.com/members/jianghehe/">贺贺</a>、<a href="http://www.jobbole.com/members/petra/">大彭</a>、<a href="https://github.com/wing00yf/">superXiaoFan</a>、<a href="http://www.jobbole.com/members/3951356/">javayrf</a>、<a href="http://www.jobbole.com/members/John%20Smith/">John Smith</a>、<a href="http://www.jobbole.com/members/jaler/">Jaler</a>、<a href="http://www.jobbole.com/members/fdconan/">JM</a>、<a href="http://www.jobbole.com/members/zy124348985/">dreamkidd</a>、<a href="http://www.jobbole.com/members/cheenlie">cheenlie</a>、<a href="http://www.jobbole.com/members/zhangQian1991">zhangQian1991</a>、<a href="http://www.jobbole.com/members/wt726553124/">王涛</a>、<a href="http://www.jobbole.com/members/xun_cui">马</a>、<a href="http://www.jobbole.com/members/xuhf_1988/">vvkee</a>、<a href="http://www.jobbole.com/members/yangxy81118">凝枫</a>、<a href="https://github.com/luhaixun">haixunlu</a>、<a href="http://www.jobbole.com/members/milly/">milly</a>、<a href="http://www.jobbole.com/members/xuhf_1988/">Hodur</a>、<a href="http://www.jobbole.com/members/FakeHank">FakeHank</a>、<a href="http://www.jobbole.com/members/%E8%BF%9E%E4%B9%90/">连乐</a>、<a href="http://www.jobbole.com/members/UncleTim/">UncleTim</a>、<a href="http://www.jobbole.com/members/sunbiaobiao">sunbiaobiao</a>、<a href="http://www.jobbole.com/members/wx2702327993/">zhiguo</a>、<a href="http://www.jobbole.com/members/zhongjianno1/">光光头去打酱油</a>、<a href="http://www.jobbole.com/members/TonyAaron/">云中游</a>、<a href="http://www.jobbole.com/members/zemo/">Zemo</a>、<a href="https://github.com/sdcuike">sdcuike</a>、<a href="https://github.com/danielwii">danielwii</a>、<a href="http://www.jobbole.com/members/q1118024125/">oneDay</a>、<a href="https://github.com/dfghj44444">邢敏</a>、<a href="https://github.com/heikehuan">heikehuan</a>、<a href="https://github.com/fgcui1204">fgcui1204</a>、<a href="https://github.com/wenxueliu">wenxueliu</a>、<a href="https://github.com/node">Gentle Yang</a>、<a href="http://hao.jobbole.com/author/huangxiaofei/">黄小非</a>、<a href="http://www.jobbole.com/members/wtgn1m1/">wangtg</a>、<a href="http://www.jobbole.com/members/2937134480/">百焱</a>、<a href="http://www.jobbole.com/members/2480130384/">胡不GUI</a>、<a href="http://www.jobbole.com/members/mtHzm/">Another_mt</a>、<a href="http://www.jobbole.com/members/adonis/">Rainbow</a>、<a href="http://www.jobbole.com/members/menghuanqiqi">super<sup>糖</sup></a>、<a href="http://www.jobbole.com/members/huangyuliang/">黄余粮</a>、<a href="http://www.jobbole.com/members/sunbojian100/">Sun</a>、You</p></li>
</ul>

<p>注：名单不分排名，不定期补充更新</p>

<hr/>

<h3 id="toc_4">奖励计划</h3>

<p>虽然奖励可能并不是你加入的主要原因，但还是有必要提一下：</p>

<ul>
<li>整理超过 20 个资源后，可在伯乐在线上开通打赏；</li>
<li>每整理 20 个资源，有机会获得技术书籍或各种有意思的创意、极客产品；</li>
<li><a href="http://hao.jobbole.com/rewards/">奖励详情</a></li>
</ul>

<h3 id="toc_5">目录</h3>

<ul>
<li><a href="#awesome-java-cn">Java资源大全中文版</a>
<ul>
<li><a href="#ancients">古董级工具</a></li>
<li><a href="#build">构建工具</a></li>
<li><a href="#bytecode-manipulation">字节码操作</a></li>
<li><a href="#cluster-management">集群管理</a></li>
<li><a href="#code-analysis">代码分析</a></li>
<li><a href="#compiler-compiler">编译器生成工具</a></li>
<li><a href="#configuration">外部配置工具</a></li>
<li><a href="#constraint-satisfaction-problem-solver">约束满足问题求解程序</a></li>
<li><a href="#continuous-integration">持续集成</a></li>
<li><a href="#csv">CSV解析</a></li>
<li><a href="#data-structures">数据结构</a></li>
<li><a href="#database">数据库</a></li>
<li><a href="#date-and-time">时间日期工具库</a></li>
<li><a href="#dependency-injection">依赖注入</a></li>
<li><a href="#development">开发流程增强工具</a></li>
<li><a href="#distributed-applications">分布式应用</a></li>
<li><a href="#distributed-databases">分布式数据库</a></li>
<li><a href="#distribution">发布</a></li>
<li><a href="#document-processing">文档处理工具</a></li>
<li><a href="#functional-programming">函数式编程</a></li>
<li><a href="#game-development">游戏开发</a></li>
<li><a href="#gui">GUI</a></li>
<li><a href="#high-performance">高性能计算</a></li>
<li><a href="#ide">IDE</a></li>
<li><a href="#imagery">图像处理</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#jvm-and-jdk">JVM与JDK</a></li>
<li><a href="#languages">基于JVM的语言</a></li>
<li><a href="#logging">日志</a></li>
<li><a href="#machine-learning">机器学习</a></li>
<li><a href="#messaging">消息传递</a></li>
<li><a href="#miscellaneous">杂项</a></li>
<li><a href="#monitoring">应用监控工具</a></li>
<li><a href="#native">原生开发库</a></li>
<li><a href="#natural-language-processing">自然语言处理</a></li>
<li><a href="#networking">网络</a></li>
<li><a href="#orm">ORM</a></li>
<li><a href="#pdf">PDF</a></li>
<li><a href="#performance-analysis">性能分析</a></li>
<li><a href="#reactive-libraries">响应式开发库</a></li>
<li><a href="#rest-frameworks">REST框架</a></li>
<li><a href="#science">科学计算与分析</a></li>
<li><a href="#search">搜索引擎</a></li>
<li><a href="#security">安全</a></li>
<li><a href="#serialization">序列化</a></li>
<li><a href="#server">应用服务器</a></li>
<li><a href="#template-engine">模板引擎</a></li>
<li><a href="#testing">测试</a></li>
<li><a href="#utility">通用工具库</a></li>
<li><a href="#web-crawling">网络爬虫</a></li>
<li><a href="#web-frameworks">Web框架</a></li>
<li><a href="#Business-Process-Management">业务流程管理套件</a></li>
</ul></li>
<li><a href="#resources">资源</a>
<ul>
<li><a href="#communities">社区</a></li>
<li><a href="#influential-books">有影响力的书</a></li>
<li><a href="#podcasts">播客</a></li>
<li><a href="#weibo-weixin">微博、微信公众号</a></li>
<li><a href="#twitter">Twitter</a></li>
<li><a href="#websites">知名网站</a></li>
</ul></li>
</ul>

<h2 id="ancients">古董级工具</h2>

<p><em>这些工具伴随着Java一起出现，在各自辉煌之后还在一直使用。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-ant/">Apache Ant</a>：基于XML的构建管理工具。<a href="http://ant.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/cglib/">cglib</a>：字节码生成库。<a href="https://github.com/cglib/cglib">官网</a></li>
<li><a href="http://hao.jobbole.com/glassfish/">GlassFish</a>：应用服务器，由Oracle赞助支持的Java EE参考实现。<a href="https://glassfish.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/hudson/">Hudson</a>：持续集成服务器，目前仍在活跃开发。<a href="http://hudson-ci.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/javaserver-faces/">JavaServer Faces</a>：Mojarra是JSF标准的一个开源实现，由Oracle开发。<a href="https://javaserverfaces.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/javaserver-pages/">JavaServer Pages</a>：支持自定义标签库的网站通用模板库。<a href="https://jsp.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/liquibase/">Liquibase</a>：与具体数据库独立的追踪、管理和应用数据库Scheme变化的工具。<a href="http://www.liquibase.org/">官网</a></li>
</ul>

<h3 id="build">构建工具</h3>

<p><em>构建及应用依赖关系处理工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/maven/">Apache Maven</a>：Maven是一款声明式构建及依赖管理工具，采用约定优于配置方式进行管理。相对Apache Ant更推荐使用Maven，前者采用了过程式管理，维护相对困难。<a href="http://maven.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/bazel/">Bazel</a>：来自Google的构建工具，可以快速、可靠地构建代码。<a href="http://bazel.io">官网</a></li>
<li><a href="http://hao.jobbole.com/gradle/">Gradle</a>：使用Groovy（非XML）进行增量构建，可以很好地与Maven依赖管理配合工作。<a href="http://gradle.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/buck/">Buck</a>：Facebook构建工具。<a href="https://buckbuild.com/">官网</a></li>
</ul>

<h3 id="bytecode-manipulation">字节码操作</h3>

<p><em>编程方式操作字节码的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/asm/">ASM</a>：通用底层字节码操作和分析开发库。<a href="http://asm.ow2.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/byte-buddy/">Byte Buddy</a>：使用流式API进一步简化字节码生成。<a href="http://bytebuddy.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/byteman/">Byteman</a>：在运行时通过DSL（规则）操作字节码进行测试和故障排除。<a href="http://byteman.jboss.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/javassist/">Javassist</a>：一个简化字节码编辑尝试。<a href="http://jboss-javassist.github.io/javassist">官网</a></li>
</ul>

<h3 id="cluster-management">集群管理</h3>

<p><em>在集群内动态管理应用程序的框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-aurora/">Apache Aurora</a>：Apache Aurora是一个Mesos框架，用于长时间运行服务和定时任务（cron job）。<a href="http://aurora.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/singularity/">Singularity</a>：Singularity是一个Mesos框架，方便部署和操作。它支持Web Service、后台运行、调度作业和一次性任务。<a href="http://getsingularity.com/">官网</a></li>
</ul>

<h3 id="code-analysis">代码分析</h3>

<p><em>测量代码指标和质量工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/checkstyle/">Checkstyle</a>：代码编写规范和标准静态分析工具。<a href="https://github.com/checkstyle/checkstyle">官网</a></li>
<li><a href="http://hao.jobbole.com/error-prone/">Error Prone</a>：将常见编程错误作为运行时错误报告。<a href="https://github.com/google/error-prone">官网</a></li>
<li>FindBugs：通过字节码静态分析查找隐藏bug。<a href="http://findbugs.sourceforge.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/jqassistant/">jQAssistant</a>：使用基于Neo4J查询语言进行代码静态分析。<a href="http://jqassistant.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/pmd/">PMD</a>：对源代码分析查找不良的编程习惯。<a href="https://github.com/pmd/pmd">官网</a></li>
<li><a href="http://hao.jobbole.com/sonarqube/">SonarQube</a>：通过插件集成其它分析组件，对过去一段时间内的数据进行统计。<a href="http://www.sonarqube.org/">官网</a></li>
</ul>

<h3 id="compiler-compiler">编译器生成工具</h3>

<p><em>用来创建解析器、解释器或编译器的框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/antlr/">ANTLR</a>：复杂的全功能自顶向下解析框架。<a href="http://www.antlr.org/">官网</a></li>
<li><a href="JavaCC%EF%BC%9AJava%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7">JavaCC</a>：JavaCC是更加专门的轻量级工具，易于上手且支持语法超前预测。<a href="https://javacc.java.net/">官网</a></li>
</ul>

<h3 id="configuration">外部配置工具</h3>

<p><em>支持外部配置的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/config/">config</a>：针对JVM语言的配置库。<a href="https://github.com/typesafehub/config">官网</a></li>
<li><a href="http://hao.jobbole.com/owner/">owner</a>：减少冗余配置属性。<a href="https://github.com/lviggiano/owner">官网</a></li>
</ul>

<h3 id="constraint-satisfaction-problem-solver">约束满足问题求解程序</h3>

<p><em>帮助解决约束满足问题的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/choco/">Choco</a>：可直接使用的约束满足问题求解程序，使用了约束规划技术。<a href="http://choco-solver.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jacop/">JaCoP</a>：为FlatZinc语言提供了一个接口，可以执行MiniZinc模型。<a href="https://github.com/radsz/jacop/">官网</a></li>
<li><a href="http://hao.jobbole.com/optaplanner/">OptaPlanner</a>：业务规划与资源调度优化求解程序。<a href="http://www.optaplanner.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/sat4j/">Sat4J</a>：逻辑代数与优化问题最先进的求解程序。<a href="http://www.sat4j.org/">官网</a></li>
</ul>

<h3 id="continuous-integration">持续集成</h3>

<ul>
<li><a href="http://hao.jobbole.com/bamboo/">Bamboo</a>：Atlassian解决方案，可以很好地集成Atlassian的其他产品。可以选择开源许可，也可以购买商业版。<a href="https://www.atlassian.com/software/bamboo">官网</a></li>
<li>CircleCI：提供托管服务，可以免费试用。<a href="https://circleci.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/codeship/">Codeship</a>：提供托管服务，提供有限的免费模式。<a href="https://codeship.com/features">官网</a></li>
<li><a href="hao.jobbole.com/fabric8/">fabric8</a>：容器集成平台。<a href="http://fabric8.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/go/">Go</a>：ThoughtWork开源解决方案。<a href="https://www.gocd.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/jenkins/">Jenkins</a>：支持基于服务器的部署服务。<a href="http://jenkins-ci.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/teamcity/">TeamCity</a>：JetBrain的持续集成解决方案，有免费版。<a href="http://www.jetbrains.com/teamcity/">官网</a></li>
<li><a href="http://hao.jobbole.com/travis/">Travis</a>：通常用作开源项目的托管服务。<a href="https://travis-ci.org">官网</a></li>
<li><a href="http://hao.jobbole.com/buildkite/">Buildkite</a>: 持续集成工具，用简单的脚本就能设置pipeline，而且能快速构建，可以免费试用。<a href="https://buildkite.com/">官网</a></li>
</ul>

<h3 id="csv">CSV解析</h3>

<p><em>简化CSV数据读写的框架与开发库</em></p>

<ul>
<li><a href="http://hao.jobbole.com/univocity-parsers/">uniVocity-parsers</a>：速度最快功能最全的CSV开发库之一，同时支持TSV与固定宽度记录的读写。<a href="https://github.com/uniVocity/univocity-parsers">官网</a></li>
</ul>

<h3 id="database">数据库</h3>

<p><em>简化数据库交互的相关工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-phoenix/">Apache Phoenix</a>：HBase针对低延时应用程序的高性能关系数据库层。<a href="http://phoenix.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/crate/">Crate</a>：实现了数据同步、分片、缩放、复制的分布式数据存储。除此之外还可以使用基于SQL的语法跨集群查询。<a href="https://crate.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/flyway/">Flyway</a>：简单的数据库迁移工具。<a href="http://flywaydb.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/h2/">H2</a>：小型SQL数据库，以可以作为内存数据库使用著称。<a href="http://h2database.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/hikaricp/">HikariCP</a>：高性能JDBC连接工具。<a href="https://github.com/brettwooldridge/HikariCP">官网</a></li>
<li><a href="http://hao.jobbole.com/jdbi/">JDBI</a>：便捷的JDBC抽象。<a href="http://jdbi.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jooq/">jOOQ</a>：为SQL schema生成typesafe代码。<a href="http://www.jooq.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/mapdb/">MapDB</a>：以磁盘或堆内存中并发集合为基础的嵌入式数据库引擎。<a href="http://www.mapdb.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/presto/">Presto</a>：针对大数据的分布式SQL查询引擎。<a href="https://github.com/facebook/presto">官网</a></li>
<li><a href="http://hao.jobbole.com/querydsl/">Querydsl</a>：Typesafe统一查询。<a href="http://www.querydsl.com/">官网</a></li>
</ul>

<h3 id="data-structures">数据结构</h3>

<ul>
<li><a href="http://hao.jobbole.com/apache-parquet/">Apache Parquet</a>：Google Dremel论文中发布的基于组装算法的列式（Columnar）存储格式。<a href="http://parquet.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/protobuf/">Protobuf</a>：Google数据交换格式。<a href="https://github.com/google/protobuf">官网</a></li>
<li><a href="http://hao.jobbole.com/sbe/">SBE</a>：简单二进制编码，是最快速的消息格式之一。<a href="https://github.com/real-logic/simple-binary-encoding">官网</a></li>
<li><a href="http://hao.jobbole.com/wire/">Wire</a>：整洁轻量级协议缓存。<a href="https://github.com/square/wire">官网</a></li>
</ul>

<h3 id="date-and-time">时间日期工具库</h3>

<p><em>处理时间和日期的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/joda-time/">Joda-Time</a>：在Java 8发布前，Joda-Time是实际使用的时间日期库标准。<a href="http://www.joda.org/joda-time/">官网</a></li>
<li><a href="http://hao.jobbole.com/time4j/">Time4J</a>：高级时间和日期库。<a href="https://github.com/MenoData/Time4J">官网</a></li>
<li><a href="http://hao.jobbole.com/ThreeTen/">ThreeTen</a>：JSR-310实现，为JDK提供更具特点的时间和日期API。<a href="http://www.threeten.org">官网</a></li>
</ul>

<h3 id="dependency-injection">依赖注入</h3>

<p><em>帮实现依赖翻转范式的开发库。</em> <a href="https://en.wikipedia.org/wiki/Inversion_of_control">官网</a></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-deltaspike/">Apache DeltaSpike</a>：CDI扩展框架。<a href="https://deltaspike.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/dagger2/">Dagger2</a>：编译时注入框架，不需要使用反射。<a href="http://google.github.io/dagger/">官网</a></li>
<li><a href="http://hao.jobbole.com/guice/">Guice</a>：可以匹敌Dagger的轻量级注入框架。<a href="https://github.com/google/guice">官网</a></li>
<li><a href="http://hao.jobbole.com/hk2/">HK2</a>：轻量级动态依赖注入框架。<a href="https://hk2.java.net">官网</a></li>
</ul>

<h3 id="development">开发流程增强工具</h3>

<p><em>从最基本的层面增强开发流程。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/adt4j/">ADT4J</a>：针对代数数据类型的JSR-269代码生成器。<a href="https://github.com/sviperll/adt4j">官网</a></li>
<li><a href="http://hao.jobbole.com/aspectj/">AspectJ</a>：面向切面编程（AOP）的无缝扩展。<a href="https://eclipse.org/aspectj/">官网</a></li>
<li><a href="http://hao.jobbole.com/auto/">Auto</a>：源代码生成器集合。<a href="https://github.com/google/auto">官网</a></li>
<li><a href="http://hao.jobbole.com/dcevm/">DCEVM</a>：通过修改JVM在运行时支持对已加载的类进行无限次重定义。<a href="http://dcevm.github.io/">官网</a></li>
<li>HotswapAgent：支持无限次重定义运行时类与资源。<a href="https://github.com/HotswapProjects/HotswapAgent">官网</a></li>
<li>Immutables：类似Scala的条件类。<a href="http://immutables.github.io/">官网</a></li>
<li>JHipster：基于Spring Boot与AngularJS应用程序的Yeoman源代码生成器。<a href="https://github.com/jhipster/generator-jhipster">官网</a></li>
<li><a href="http://hao.jobbole.com/jrebel/">JRebel</a>：无需重新部署，可以即时重新加载代码与配置的商业软件。<a href="http://zeroturnaround.com/software/jrebel/">官网</a></li>
<li>Lombok：减少冗余的代码生成器。<a href="https://projectlombok.org/">官网</a></li>
<li>Spring Loaded：类重载代理。<a href="https://github.com/spring-projects/spring-loaded">官网</a></li>
<li><a href="http://hao.jobbole.com/vert-x/">vert.x</a>：多语言事件驱动应用框架。<a href="http://vertx.io/">官网</a></li>
</ul>

<h3 id="distributed-applications">分布式应用</h3>

<p><em>用来编写分布式容错应用的开发库和框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/akka/">Akka</a>：用来编写分布式容错并发事件驱动应用程序的工具和运行时。<a href="http://akka.io">官网</a></li>
<li><a href="http://hao.jobbole.com/storm/">Apache Storm</a>：实时计算系统。<a href="http://storm.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/zookeeper/">Apache ZooKeeper</a>：针对大型分布式系统的协调服务，支持分布式配置、同步和名称注册。<a href="http://zookeeper.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/Hazelcast/">Hazelcast</a>：高可扩展内存数据网格。<a href="http://hazelcast.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/hystrix/">Hystrix</a>：提供延迟和容错。<a href="https://github.com/Netflix/Hystrix">官网</a></li>
<li><a href="http://hao.jobbole.com/jgroups/">JGroups</a>：提供可靠的消息传递和集群创建的工具。<a href="http://www.jgroups.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/orbit/">Orbit</a>：支持虚拟角色（Actor），在传统角色的基础上增加了另外一层抽象。<a href="http://orbit.bioware.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/quasar/">Quasar</a>：为JVM提供轻量级线程和角色。<a href="http://www.paralleluniverse.co/quasar/">官网</a></li>
</ul>

<h3 id="distributed-databases">分布式数据库</h3>

<p><em>对应用程序而言，在分布式系统中的数据库看起来就像是只有一个数据源。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/cassandra/">Apache Cassandra</a>：列式数据库，可用性高且没有单点故障。<a href="http://cassandra.apache.org">官网</a></li>
<li><a href="http://hao.jobbole.com/hbase/">Apache HBase</a>：针对大数据的Hadoop数据库。<a href="http://hbase.apache.org">官网</a></li>
<li><a href="http://hao.jobbole.com/druid/">Druid</a>：实时和历史OLAP数据存储，在聚集查询和近似查询方面表现不俗。<a href="http://druid.io">官网</a></li>
<li><a href="http://hao.jobbole.com/infinispan/">Infinispan</a>：针对缓存的高并发键值对数据存储。<a href="http://infinispan.org/">官网</a></li>
</ul>

<h3 id="distribution">发布</h3>

<p><em>以本机格式发布应用程序的工具。</em></p>

<ul>
<li>Bintray：发布二进制文件版本控制工具。可以于Maven或Gradle一起配合使用。提供开源免费版本和几种商业收费版本。<a href="https://bintray.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/central-repository/">Central Repository</a>：最大的二进制组件仓库，面向开源社区提供免费服务。Apache Maven默认使用Central <a href="http://search.maven.org/">官网</a>Repository，也可以在所有其他构建工具中使用。</li>
<li>IzPack：为跨平台部署建立创作工具（Authoring Tool）。<a href="http://izpack.org/">官网</a></li>
<li>JitPack：打包GitHub仓库的便捷工具。可根据需要构建Maven、Gradle项目，发布可立即使用的组件。<a href="https://jitpack.io/">官网</a></li>
<li>Launch4j：将JAR包装为轻量级本机Windows可执行程序。<a href="http://launch4j.sourceforge.net/">官网</a></li>
<li>Nexus：支持代理和缓存功能的二进制管理工具。<a href="http://www.sonatype.com/nexus">官网</a></li>
<li>packr：将JAR、资源和JVM打包成Windows、Linux和Mac OS X本地发布文件。<a href="https://github.com/libgdx/packr/">官网</a></li>
</ul>

<h3 id="document-processing">文档处理工具</h3>

<p><em>处理Office文档的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/poi/">Apache POI</a>：支持OOXML规范（XLSX、DOCX、PPTX）以及OLE2规范（XLS、DOC、PPT）。<a href="http://poi.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/documents4j/">documents4j</a>：使用第三方转换器进行文档格式转换，转成类似MS Word这样的格式。<a href="http://documents4j.com">官网</a></li>
<li><a href="http://hao.jobbole.com/jopendocument/">jOpenDocument</a>：处理OpenDocument格式（由Sun公司提出基于XML的文档格式）。<a href="http://www.jopendocument.org/">官网</a></li>
</ul>

<h3 id="functional-programming">函数式编程</h3>

<p><em>函数式编程支持库。</em></p>

<ul>
<li>Cyclops：支持一元（Monad）操作和流操作工具类、comprehension（List语法）、模式匹配、trampoline等特性。<a href="https://github.com/aol/cyclops">官网</a></li>
<li>Fugue：Guava的函数式编程扩展。<a href="https://bitbucket.org/atlassian/fugue">官网</a></li>
<li>Functional Java：实现了多种基础和高级编程抽象，用来辅助面向组合开发（composition-oriented development）。<a href="http://www.functionaljava.org">官网</a></li>
<li>Javaslang：一个函数式组件库，提供持久化数据类型和函数式控制结构。<a href="http://javaslang.com">官网</a></li>
<li>jOOλ：旨在填补Java 8 lambda差距的扩展，提供了众多缺失的类型和一组丰富的顺序流API。<a href="https://github.com/jOOQ/jOOL">官网</a></li>
</ul>

<h3 id="game-development">游戏开发</h3>

<p><em>游戏开发框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jmonkeyengine/">jMonkeyEngine</a>：现代3D游戏开发引擎。<a href="http://jmonkeyengine.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/libgdx/">libGDX</a>：全面的跨平台高级框架。<a href="https://libgdx.badlogicgames.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/lwjgl/">LWJGL</a>：对OpenGL/CL/AL等技术进行抽象的健壮框架。<a href="https://www.lwjgl.org/">官网</a></li>
</ul>

<h3 id="gui">GUI</h3>

<p><em>现代图形化用户界面开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/javafx/">JavaFX</a>：Swing的后继者。<a href="http://www.oracle.com/technetwork/java/javase/overview/javafx-overview-2158620.html">官网</a></li>
<li><a href="http://hao.jobbole.com/scene_builder/">Scene Builder</a>：开发JavaFX应用的可视化布局工具。<a href="http://docs.oracle.com/javase/8/scene-builder-2/get-started-tutorial/overview.htm#JSBGS164">官网</a></li>
</ul>

<h3 id="high-performance">高性能计算</h3>

<p><em>涵盖了从集合到特定开发库的高性能计算相关工具。</em></p>

<ul>
<li>Agrona：高性能应用中常见的数据结构和工具方法。<a href="https://github.com/real-logic/Agrona">官网</a></li>
<li>Disruptor：线程间消息传递开发库。<a href="http://lmax-exchange.github.io/disruptor/">官网</a></li>
<li>fastutil：快速紧凑的特定类型集合（Collection）。<a href="http://fastutil.di.unimi.it/">官网</a></li>
<li>GS Collections：受Smalltalk启发的集合框架。<a href="https://github.com/goldmansachs/gs-collections">官网</a></li>
<li><a href="http://hao.jobbole.com/hppc/">HPPC</a>：基础类型集合。<a href="http://labs.carrotsearch.com/hppc.html">官网</a></li>
<li>Javolution：实时和嵌入式系统的开发库。<a href="http://javolution.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jctools/">JCTools</a>：JDK中缺失的并发工具。<a href="https://github.com/JCTools/JCTools">官网</a></li>
<li><a href="http://hao.jobbole.com/koloboke/">Koloboke</a>：Hash set和hash map。<a href="https://github.com/OpenHFT/Koloboke">官网</a></li>
<li>Trove：基础类型集合。<a href="http://trove.starlight-systems.com/">官网</a></li>
<li>High-scale-lib:Cliff Click 个人开发的高性能并发库<a href="https://github.com/stephenc/high-scale-lib">官网</a></li>
</ul>

<h3 id="ide">IDE</h3>

<p><em>简化开发的集成开发环境。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/eclipse/">Eclipse</a>：老牌开源项目，支持多种插件和编程语言。<a href="http://www.eclipse.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/intellij-idea/">IntelliJ IDEA</a>：支持众多JVM语言，是安卓开发者好的选择。商业版主要针对企业客户。<a href="http://www.jetbrains.com/idea/">官网</a></li>
<li><a href="http://hao.jobbole.com/netbeans/">NetBeans</a>：为多种技术提供集成化支持，包括Java SE、Java EE、数据库访问、HTML5等。<a href="https://netbeans.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/scala-ide/">Scala IDE</a>：一款基于Eclipse开源平台打造的Scala集成开发环境。<a href="http://scala-ide.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/springsource-tool-suite/">SpringSource Tool Suite（STS）</a>:一款基于Eclipse开源平台打造的Spring应用开发环境。<a href="http://spring.io/tools/sts/">官网</a></li>
</ul>

<h3 id="imagery">图像处理</h3>

<p><em>创建、评价和操作图片的支持库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/imgscalr/">Imgscalr</a>：纯Java 2D实现，简单、高效、支持硬件加速的图像缩放开发库。<a href="https://github.com/thebuzzmedia/imgscalr">官网</a></li>
<li><a href="http://hao.jobbole.com/picasso/">Picasso</a>：安卓图片下载和图片缓存开发库。<a href="http://square.github.io/picasso/">官网</a></li>
<li><a href="http://hao.jobbole.com/thumbnailator/">Thumbnailator</a>：Thumbnailator是一个高质量Java缩略图开发库。<a href="https://github.com/coobird/thumbnailator">官网</a></li>
<li><a href="http://hao.jobbole.com/zxing/">ZXing</a>：支持多种格式的一维、二维条形码图片处理开发库。<a href="https://github.com/zxing/zxing">官网</a></li>
<li><a href="http://hao.jobbole.com/im4java/">im4java</a>: 基于ImageMagick或GraphicsMagick命令行的图片处理开发库，基本上ImageMagick能够支持的图片格式和处理方式都能够处理。<a href="http://im4java.sourceforge.net/">官网</a></li>
<li>Apache Batik：在Java应用中程序以SVG格式显示、生成及处理图像的工具集，包括SVG解析器、SVG生成器、SVG DOM等模块，可以集成使用也可以单独使用，还可以扩展自定义的SVG标签。<a href="http://xmlgraphics.apache.org/batik/">官网</a></li>
</ul>

<h3 id="json">JSON</h3>

<p><em>简化JSON处理的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/genson/">Genson</a>：强大且易于使用的Java到JSON转换开发库。<a href="http://owlike.github.io/genson">官网</a></li>
<li><a href="http://hao.jobbole.com/gson/">Gson</a>：谷歌官方推出的JSON处理库，支持在对象与JSON之间双向序列化，性能良好且可以实时调用。<a href="https://github.com/google/gson">官网</a></li>
<li><a href="http://hao.jobbole.com/jackson/">Jackson</a>：与GSON类似，在频繁使用时性能更佳。<a href="http://wiki.fasterxml.com/JacksonHome">官网</a></li>
<li><a href="http://hao.jobbole.com/logansquare/">LoganSquare</a>：基于Jackson流式API，提供对JSON解析和序列化。比GSON与Jackson组合方式效果更好。<a href="https://github.com/bluelinelabs/LoganSquare">官网</a></li>
<li><a href="http://hao.jobbole.com/fastjson/">Fastjson</a>：一个Java语言编写的高性能功能完善的JSON库。<a href="https://github.com/Alibaba/fastjson">官网</a></li>
<li>Kyro：快速、高效、自动化的Java对象序列化和克隆库。<a href="https://github.com/EsotericSoftware/kryo">官网</a></li>
</ul>

<h3 id="jvm-and-jdk">JVM与JDK</h3>

<p><em>目前的JVM和JDK实现。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jdk-9/">JDK 9</a>：JDK 9的早期访问版本。<a href="https://jdk9.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/openjdk/">OpenJDK</a>：JDK开源实现。<a href="http://openjdk.java.net/">官网</a></li>
</ul>

<h3 id="languages">基于JVM的语言</h3>

<p><em>除Java外，可以用来编写JVM应用程序的编程语言。</em></p>

<ul>
<li>Scala：融合了面向对象和函数式编程思想的静态类型编程语言。<a href="http://www.scala-lang.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/groovy/">Groovy</a>：类型可选（Optionally typed）的动态语言，支持静态类型和静态编译。目前是一个Apache孵化器项目。<a href="http://www.groovy-lang.org/">官网</a></li>
<li>Clojure：可看做现代版Lisp的动态类型语言。<a href="http://clojure.org/">官网</a></li>
<li>Ceylon：RedHat开发的面向对象静态类型编程语言。<a href="http://ceylon-lang.org/">官网</a></li>
<li>Kotlin：JetBrain针对JVM、安卓和浏览器提供的静态类型编程语言。<a href="http://kotlinlang.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/xtend/">Xtend</a>：一种静态编程语言，能够将其代码转换为简洁高效的Java代码，并基于JVM运行。<a href="http://www.eclipse.org/xtend/">官网</a></li>
</ul>

<h3 id="logging">日志</h3>

<p><em>记录应用程序行为日志的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/log4j2/">Apache Log4j 2</a>：使用强大的插件和配置架构进行完全重写。<a href="http://logging.apache.org/log4j/">官网</a></li>
<li><a href="http://hao.jobbole.com/kibana/">kibana</a>：分析及可视化日志文件。<a href="https://www.elastic.co/products/kibana">官网</a></li>
<li><a href="http://hao.jobbole.com/logback/">Logback</a>：强健的日期开发库，通过Groovy提供很多有趣的选项。<a href="http://logback.qos.ch/">官网</a></li>
<li><a href="http://hao.jobbole.com/logstash/">logstash</a>：日志文件管理工具。<a href="https://www.elastic.co/products/logstash">官网</a></li>
<li><a href="http://hao.jobbole.com/metrics/">Metrics</a>：通过JMX或HTTP发布参数，并且支持存储到数据库。<a href="https://github.com/dropwizard/metrics">官网</a></li>
<li><a href="http://hao.jobbole.com/slf4j/">SLF4J</a>：日志抽象层，需要与具体的实现配合使用。<a href="http://www.slf4j.org/">官网</a></li>
</ul>

<h3 id="machine-learning">机器学习</h3>

<p><em>提供具体统计算法的工具。其算法可从数据中学习。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-flink/">Apache Flink</a>：快速、可靠的大规模数据处理引擎。<a href="https://flink.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-hadoop/">Apache Hadoop</a>：在商用硬件集群上用来进行大规模数据存储的开源软件框架。<a href="http://hadoop.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-mahout/">Apache Mahout</a>：专注协同过滤、聚类和分类的可扩展算法。<a href="https://mahout.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-spark/">Apache Spark</a>：开源数据分析集群计算框架。<a href="http://spark.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/deepdive/">DeepDive</a>：从非结构化数据建立结构化信息并集成到已有数据库的工具。<a href="http://deepdive.stanford.edu">官网</a></li>
<li><a href="http://hao.jobbole.com/deeplearning4j/">Deeplearning4j</a>：分布式多线程深度学习开发库。<a href="http://deeplearning4j.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/h2o/">H2O</a>：用作大数据统计的分析引擎。<a href="http://h2o.ai/">官网</a></li>
<li><a href="http://hao.jobbole.com/weka/">Weka</a>：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。<a href="http://www.cs.waikato.ac.nz/ml/weka/">官网</a></li>
<li><a href="http://hao.jobbole.com/quickml/">QuickML</a>：高效机器学习库。<a href="http://quickml.org/">官网</a>、<a href="https://github.com/sanity/quickml">GitHub</a></li>
</ul>

<h3 id="messaging">消息传递</h3>

<p><em>在客户端之间进行消息传递，确保协议独立性的工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/aeron/">Aeron</a>：高效可扩展的单播、多播消息传递工具。<a href="https://github.com/real-logic/Aeron">官网</a></li>
<li><a href="http://hao.jobbole.com/activemq/">Apache ActiveMQ</a>：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。<a href="http://activemq.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-camel/">Apache Camel</a>：通过企业级整合模式（Enterprise Integration Pattern EIP）将不同的消息传输API整合在一起。<a href="http://camel.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/kafka/">Apache Kafka</a>：高吞吐量分布式消息系统。<a href="http://kafka.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/hermes/">Hermes</a>：快速、可靠的消息代理（Broker），基于Kafka构建。<a href="http://hermes.allegro.tech">官网</a></li>
<li>JBoss HornetQ：清晰、准确、模块化，可以方便嵌入的消息工具。<a href="http://hornetq.jboss.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jeromq/">JeroMQ</a>：ZeroMQ的纯Java实现。<a href="https://github.com/zeromq/jeromq">官网</a></li>
<li><a href="http://hao.jobbole.com/smack/">Smack</a>：跨平台XMPP客户端函数库。<a href="https://github.com/igniterealtime/Smack/">官网</a></li>
<li>Openfire：是开源的、基于XMPP、采用Java编程语言开发的实时协作服务器。 Openfire安装和使用都非常简单，并可利用Web界面进行管理。 <a href="http://www.igniterealtime.org/projects/openfire/index.jsp">官网</a> <a href="https://github.com/igniterealtime/Openfire">GitHub</a></li>
<li>Spark：是一个开源，跨平台IM客户端。它的特性支持集组聊天，电话集成和强大安全性能。如果企业内部部署IM使用Openfire+Spark是最佳的组合。 <a href="http://www.igniterealtime.org/projects/spark/index.jsp">官网</a> <a href="https://github.com/igniterealtime/Spark">GitHub</a></li>
<li>Tigase： 是一个轻量级的可伸缩的 Jabber/XMPP 服务器。无需其他第三方库支持，可以处理非常高的复杂和大量的用户数，可以根据需要进行水平扩展。 <a href="http://www.tigase.net">官网</a></li>
</ul>

<h3 id="miscellaneous">杂项</h3>

<p><em>未分类其它资源。</em></p>

<ul>
<li>Design Patterns：实现并解释了最常见的设计模式。<a href="https://github.com/iluwatar/java-design-patterns">官网</a></li>
<li>Jimfs：内存文件系统。<a href="https://github.com/google/jimfs">官网</a></li>
<li>Lanterna：类似curses的简单console文本GUI函数库。<a href="https://code.google.com/p/lanterna/">官网</a></li>
<li>LightAdmin：可插入式CRUD UI函数库，可用来快速应用开发。<a href="http://lightadmin.org/">官网</a></li>
<li>OpenRefine：用来处理混乱数据的工具，包括清理、转换、使用Web Service进行扩展并将其关联到数据库。<a href="http://openrefine.org/">官网</a></li>
<li>RoboVM：Java编写原生iOS应用。<a href="https://robovm.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/quartz/">Quartz</a>：强大的任务调度库.<a href="http://www.quartz-scheduler.org/">官网</a></li>
</ul>

<h3 id="monitoring">应用监控工具</h3>

<p><em>监控生产环境中应用程序的工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/appdynamics/">AppDynamics</a>：性能监测商业工具。<a href="http://www.appdynamics.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/javamelody/">JavaMelody</a>：性能监测和分析工具。<a href="https://github.com/javamelody/javamelody">官网</a></li>
<li><a href="http://hao.jobbole.com/Kamon/">Kamon</a>：Kamon用来监测在JVM上运行的应用程序。<a href="http://www.kamon.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/new-relic/">New Relic</a>：性能监测商业工具。<a href="http://newrelic.com/">官网</a></li>
<li>SPM：支持对JVM应用程序进行分布式事务追踪的性能监测商业工具。<a href="https://sematext.com/spm/">官网</a></li>
<li><a href="http://hao.jobbole.com/overops_takipi/">OverOps(Takipi)</a>：产品运行时错误监测及调试商业工具。<a href="https://www.takipi.com/">官网</a></li>
</ul>

<h3 id="native">原生开发库</h3>

<p><em>用来进行特定平台开发的原生开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jna/">JNA</a>：不使用JNI就可以使用原生开发库。此外，还为常见系统函数提供了接口。<a href="https://github.com/java-native-access/jna">官网</a></li>
</ul>

<h3 id="natural-language-processing">自然语言处理</h3>

<p><em>用来专门处理文本的函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-opennlp/">Apache OpenNLP</a>：处理类似分词等常见任务的工具。<a href="https://opennlp.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/stanford_corenlp/">CoreNLP</a>：斯坦佛CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。<a href="http://nlp.stanford.edu/software/coenlp.shtml">官网</a></li>
<li><a href="http://hao.jobbole.com/lingpipe/">LingPipe</a>：一组可以处理各种任务的工具集，支持POS标签、情感分析等。<a href="http://alias-i.com/lingpipe/">官网</a></li>
<li><a href="http://hao.jobbole.com/mallet/">Mallet</a>：统计学自然语言处理、文档分类、聚类、主题建模等。<a href="http://mallet.cs.umass.edu/">官网</a></li>
</ul>

<h3 id="networking">网络</h3>

<p><em>网络编程函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/async-http-client/">Async Http Client</a>：异步HTTP和WebSocket客户端函数库。<a href="https://github.com/AsyncHttpClient/async-http-client">官网</a></li>
<li><a href="http://hao.jobbole.com/grizzly/">Grizzly</a>：NIO框架，在Glassfish中作为网络层使用。<a href="https://grizzly.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/netty/">Netty</a>：构建高性能网络应用程序开发框架。<a href="http://netty.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/okhttp/">OkHttp</a>：一个Android和Java应用的HTTP+SPDY客户端。<a href="http://square.github.io/okhttp/">官网</a></li>
<li>Undertow：基于NIO实现了阻塞和非阻塞API的Web服务器，在WildFly中作为网络层使用。<a href="http://undertow.io/">官网</a></li>
</ul>

<h3 id="orm">ORM</h3>

<p><em>处理对象持久化的API。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/ebean/">Ebean</a>：支持快速数据访问和编码的ORM框架。<a href="http://ebean-orm.github.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/eclipselink/">EclipseLink</a>：支持许多持久化标准，JPA、JAXB、JCA和SDO。<a href="https://www.eclipse.org/eclipselink/">官网</a></li>
<li><a href="http://hao.jobbole.com/hibernate/">Hibernate</a>：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。<a href="http://hibernate.org/orm/">官网</a></li>
<li><a href="http://hao.jobbole.com/mybatis/">MyBatis</a>：带有存储过程或者SQL语句的耦合对象（Couples object）。<a href="http://mybatis.github.io/mybatis-3/">官网</a></li>
<li><a href="http://hao.jobbole.com/ormlite/">OrmLite</a>：轻量级开发包，免除了其它ORM产品中的复杂性和开销。<a href="http://ormlite.com/">官网</a></li>
<li>Nutz：另一个SSH。<a href="http://nutzam.com/">官网</a>，<a href="https://github.com/nutzam/nutz">Github</a>，<a href="https://nutz.cn/">论坛</a></li>
<li>JFinal：JAVA WEB + ORM框架。<a href="http://www.jfinal.com">官网</a>，<a href="https://github.com/jfinal/jfinal">Github</a></li>
<li><a href="http://openjpa.apache.org/">Apache OpenJPA</a>: 实现了 EJB 3.0 中的 JPA 标准,为开发者提供功能强大、使用简单的持久化数据管理框架。 <a href="http://openjpa.apache.org/">官网</a></li>
</ul>

<h3 id="pdf">PDF</h3>

<p><em>用来帮助创建PDF文件的资源。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache_fop/">Apache FOP</a>：从XSL-FO创建PDF。<a href="http://xmlgraphics.apache.org/fop/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-pdfbox/">Apache PDFBox</a>：用来创建和操作PDF的工具集。<a href="http://pdfbox.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/dynamicreports/">DynamicReports</a>：JasperReports的精简版。<a href="http://dynamicreports.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/flyingsaucer/">flyingsaucer</a>：XML/XHTML和CSS 2.1渲染器。<a href="https://github.com/flyingsaucerproject/flyingsaucer">官网</a></li>
<li><a href="http://hao.jobbole.com/itext/">iText</a>：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。<a href="http://itextpdf.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/jasperreports/">JasperReports</a>：一个复杂的报表引擎。<a href="http://community.jaspersoft.com/project/jasperreports-library">官网</a></li>
</ul>

<h3 id="performance-analysis">性能分析</h3>

<p><em>性能分析、性能剖析及基准测试工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jhiccup/">jHiccup</a>：提供平台中JVM暂停的日志和记录。<a href="https://github.com/giltene/jHiccup">官网</a></li>
<li><a href="http://hao.jobbole.com/jmh/">JMH</a>：JVM基准测试工具。<a href="http://openjdk.java.net/projects/code-tools/jmh/">官网</a></li>
<li><a href="http://hao.jobbole.com/jprofiler/">JProfiler</a>：商业分析器。<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">官网</a></li>
<li><a href="http://hao.jobbole.com/latencyutils/">LatencyUtils</a>：测量和报告延迟的工具。<a href="https://github.com/LatencyUtils/LatencyUtils">官网</a></li>
<li><a href="http://hao.jobbole.com/visualvm/">VisualVM</a>：对运行中的应用程序信息提供了可视化界面。<a href="http://visualvm.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/yourkit-java-profiler/">YourKit Java Profiler</a>：商业分析器。<a href="https://www.yourkit.com/features/">官网</a></li>
</ul>

<h3 id="reactive-libraries">响应式开发库</h3>

<p><em>用来开发响应式应用程序的开发库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/reactive-streams/">Reactive Streams</a>：异步流处理标准，支持非阻塞式反向压力（backpressure）。<a href="https://github.com/reactive-streams/reactive-streams-jv/">官网</a></li>
<li><a href="http://hao.jobbole.com/reactor/">Reactor</a>：构建响应式快速数据（fast-data）应用程序的开发库。<a href="http://projectreactor.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/rxjava/">RxJava</a>：通过JVM可观察序列（observable sequence）构建异步和基于事件的程序。<a href="https://github.com/ReactiveX/RxJava">官网</a></li>
</ul>

<h3 id="rest-frameworks">REST框架</h3>

<p><em>用来创建RESTful 服务的框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/dropwizard/">Dropwizard</a>：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。<a href="https://dropwizard.github.io/drpwizard/">官网</a></li>
<li><a href="http://hao.jobbole.com/feign/">Feign</a>：受Retrofit、JAXRS-2.0和WebSocket启发的HTTP客户端连接器（binder）。<a href="https://github.com/Netflix/feign">官网</a></li>
<li>Jersey：JAX-RS参考实现。<a href="https://jersey.java.net/">官网</a></li>
<li><a href="http://hao.jobbole.com/resteasy/">RESTEasy</a>：经过JAX-RS规范完全认证的可移植实现。<a href="http://resteasy.jboss.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/restexpress/">RestExpress</a>：一个Java类型安全的REST客户端。<a href="https://github.com/RestExpress/RestExpress">官网</a></li>
<li><a href="http://hao.jobbole.com/restx/">RestX</a>：基于注解处理和编译时源码生成的框架。<a href="http://restx.io">官网</a></li>
<li><a href="http://hao.jobbole.com/retrofit/">Retrofit</a>：类型安全的REST客户端。<a href="http://square.github.io/retrofit/">官网</a></li>
<li><a href="http://hao.jobbole.com/sparkjava/">Spark</a>：受到Sinatra启发的Java REST框架。<a href="http://sparkjava.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/swagger/">Swagger</a>：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。<a href="http://swagger.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/bladejava/">Blade</a>：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a href="https://github.com/biezhi/blade">官网</a></li>
</ul>

<h3 id="science">科学计算与分析</h3>

<p><em>用于科学计算和分析的函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/datamelt/">DataMelt</a>：用于科学计算、数据分析及数据可视化的开发环境。<a href="http://jwork.org/dmelt/">官网</a></li>
<li><a href="http://hao.jobbole.com/jgrapht/">JGraphT</a>：支持数学图论对象和算法的图形库。<a href="https://github.com/jgrapht/jgrapht">官网</a></li>
<li><a href="http://hao.jobbole.com/jscience/">JScience</a>：用来进行科学测量和单位的一组类。<a href="http://jscience.org/">官网</a></li>
</ul>

<h3 id="search">搜索引擎</h3>

<p><em>文档索引引擎，用于搜索和分析。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/solr/">Apache Solr</a>：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。<a href="http://lucene.apache.org/solr/">官网</a></li>
<li>Elasticsearch：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTful Web接口和无schema的JSON文档。<a href="http://www.elsticsearch.org/">官网</a></li>
<li>Apache Lucene：是一个开放源代码的全文检索引擎工具包，是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。<a href="http://lucene.apache.org/">官网</a></li>
</ul>

<h3 id="security">安全</h3>

<p><em>用于处理安全、认证、授权或会话管理的函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/shiro/">Apache Shiro</a>：执行认证、授权、加密和会话管理。<a href="http://shiro.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/bouncy-castle/">Bouncy Castle</a>，涵盖了从基础的帮助函数到PGP/SMIME操作。<a href="https://www.bouncycastle.org/java.html">官网</a>：多途加密开发库。支持JCA提供者（JCA provider)</li>
<li><a href="http://hao.jobbole.com/cryptomator/">Cryptomator</a>：在云上进行客户端跨平台透明加密。<a href="https://cryptomator.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/keycloak/">Keycloak</a>：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。<a href="http://keycloak.jboss.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/picketlink/">PicketLink</a>：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。<a href="http://picketlink.org/">官网</a></li>
</ul>

<h3 id="serialization">序列化</h3>

<p><em>用来高效处理序列化的函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/flatbuffers/">FlatBuffers</a>：高效利用内存的序列化函数库，无需解包和解析即可高效访问序列化数据。<a href="https://github.com/google/flatbuffers">官网</a></li>
<li><a href="http://hao.jobbole.com/kryo/">Kryo</a>：快速、高效的对象图形序列化框架。<a href="https://github.com/EsotericSoftware/kryo">官网</a></li>
<li><a href="http://hao.jobbole.com/fst/">FST</a>：提供兼容JDK的高性能对象图形序列化。<a href="https://github.com/RuedigerMoeller/fast-serialization">官网</a></li>
<li><a href="http://hao.jobbole.com/messagepack/">MessagePack</a>：一种高效的二进制序列化格式。<a href="https://github.com/msgpack/msgpack-java">官网</a></li>
</ul>

<h3 id="server">应用服务器</h3>

<p><em>用来部署应用程序的服务器。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-tomcat/">Apache Tomcat</a>：针对Servlet和JSP的应用服务器，健壮性好且适用性强。<a href="http://tomcat.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/tomee/">Apache TomEE</a>：Tomcat加Java EE。<a href="http://tomee.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jetty/">Jetty</a>：轻量级、小巧的应用服务器，通常会嵌入到项目中。<a href="http://www.eclipse.org/jetty/">官网</a></li>
<li><a href="http://hao.jobbole.com/websphere-liberty/">WebSphere Liberty</a>：轻量级、模块化应用服务器，由IBM开发。<a href="https://developer.ibm.com/wasdev/">官网</a></li>
<li><a href="http://hao.jobbole.com/wildfly/">WildFly</a>：之前被称作JBoss，由Red Hat开发。支持很多Java EE功能。<a href="http://www.wildfly.org/">官网</a></li>
</ul>

<h3 id="template-engine">模板引擎</h3>

<p><em>在模板中替换表达式的工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/velocity/">Apache Velocity</a>：提供HTML页面模板、email模板和通用开源代码生成器模板。<a href="http://velocity.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/freemarker/">FreeMarker</a>：通用模板引擎，不需要任何重量级或自己使用的依赖关系。<a href="http://freemarker.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/handlebars-java/">Handlebars.java</a>：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semantic Mustache）。<a href="http://jknack.github.io/handlebars.java/">官网</a></li>
<li><a href="http://hao.jobbole.com/thymeleaf/">Thymeleaf</a>：旨在替换JSP，支持XML文件的工具。<a href="http://www.thymeleaf.org/">官网</a></li>
<li><a href="http://ibeetl.com/">Beetl</a>：新一代的模板引擎，功能强大，性能良好，超过当前流行的模板引擎。而且还易学易用。<a href="http://ibeetl.com/">官网</a></li>
</ul>

<h3 id="testing">测试</h3>

<p><em>测试内容从对象到接口，涵盖性能测试和基准测试工具。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jmeter/">Apache JMeter</a>：功能性测试和性能评测。<a href="http://jmeter.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/arquillian/">Arquillian</a>：集成测试和功能行测试平台，集成Java EE容器。<a href="http://arquillian.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/assertj/">AssertJ</a>：支持流式断言提高测试的可读性。<a href="http://joel-costigliola.github.io/assertj/">官网</a></li>
<li><a href="http://hao.jobbole.com/awaitility/">Awaitility</a>：用来同步异步操作的DSL。<a href="https://github.com/jayway/awaitility">官网</a></li>
<li><a href="http://hao.jobbole.com/cucumber-jvm/">Cucumber</a>：BDD测试框架。<a href="https://github.com/cucumber/cucumber-jvm">官网</a></li>
<li>Gatling：设计为易于使用、可维护的和高性能负载测试工具。<a href="http://gatling.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/hamcrest/">Hamcrest</a>：可用来灵活创建意图（intent）表达式的匹配器。<a href="http://hamcrest.org/JavaHamcrest/">官网</a></li>
<li>JMockit：用来模拟静态、final方法等。<a href="http://jmockit.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/junit/">JUnit</a>：通用测试框架。<a href="http://junit.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/mockito/">Mockito</a>：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。<a href="https://github.com/mockito/mockito">官网</a></li>
<li><a href="http://hao.jobbole.com/powermock/">PowerMock</a>： 支持模拟静态方法、构造函数、final类和方法、私有方法以及移除静态初始化器的模拟工具。<a href="https://github.com/jayway/powermock">官网</a></li>
<li><a href="http://hao.jobbole.com/rest-assured/">REST Assured</a>：为REST/HTTP服务提供方便测试的Java DSL。<a href="https://github.com/jayway/rest-assured">官网</a></li>
<li><a href="http://hao.jobbole.com/selenide/">Selenide</a>：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。<a href="http://selenide.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/selenium/">Selenium</a>：为Web应用程序提供可移植软件测试框架。<a href="http://docs.seleniumhq.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/spock/">Spock</a>：JUnit-compatible framework featuring an expressive Groovy-derived specification language.<a href="http://docs.spockframework.org/">官网</a>兼容JUnit框架，支持衍生的Groovy范的语言。</li>
<li><a href="http://hao.jobbole.com/testng/">TestNG</a>：测试框架。<a href="http://testng.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/truth/">Truth</a>：Google的断言和命题（proposition）框架。<a href="https://github.com/google/truth">官网</a></li>
<li><a href="http://hao.jobbole.com/unitils/">Unitils</a>：模块化测试函数库，支持单元测试和集成测试。<a href="http://www.unitils.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/wiremock/">WireMock</a>：Web Service测试桩（Stub）和模拟函数。<a href="http://wiremock.org/">官网</a></li>
</ul>

<h3 id="utility">通用工具库</h3>

<p><em>通用工具类函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-commons/">Apache Commons</a>：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。<a href="http://commons.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/args4j/">args4j</a>：命令行参数解析器。<a href="http://args4j.kohsuke.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/crash/">CRaSH</a>：为运行进行提供CLI。<a href="http://www.crashub.org">官网</a></li>
<li><a href="http://hao.jobbole.com/gephi/">Gephi</a>：可视化跨平台网络图形化操作程序。<a href="https://github.com/gephi/gephi/">官网</a></li>
<li><a href="http://hao.jobbole.com/guava/">Guava</a>：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I/O等。<a href="https://github.com/google/guava">官网</a></li>
<li><a href="http://hao.jobbole.com/jade/">JADE</a>：构建、调试多租户系统的框架和环境。<a href="http://jade.tilab.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/javatuples/">javatuples</a>：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。<a href="http://www.javatuples.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/jcommander/">JCommander</a>：命令行参数解析器。<a href="http://jcommander.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/protege/">Protégé</a>：提供存在论（ontology）编辑器以及构建知识系统的框架。<a href="http://protege.stanford.edu/">官网</a></li>
</ul>

<h3 id="web-crawling">网络爬虫</h3>

<p><em>用于分析网站内容的函数库。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/nutch/">Apache Nutch</a>：可用于生产环境的高度可扩展、可伸缩的网络爬虫。<a href="http://nutch.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/crawler4j/">Crawler4j</a>：简单的轻量级网络爬虫。<a href="https://github.com/yasserg/crawler4j">官网</a></li>
<li><a href="http://hao.jobbole.com/jsoup/">JSoup</a>：刮取、解析、操作和清理HTML。<a href="http://jsoup.org/">官网</a></li>
<li><a href="https://github.com/code4craft/webmagic/">webmagic</a>：一个可扩展的Java爬虫框架，架构类似Python的Scrapy。</li>
</ul>

<h3 id="web-frameworks">Web框架</h3>

<p><em>用于处理Web应用程序不同层次间通讯的框架。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/apache-tapestry/">Apache Tapestry</a>：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。<a href="http://tapestry.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/apache-wicket/">Apache Wicket</a>：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。<a href="http://wicket.apache.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/gwt/">Google Web Toolkit</a>：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCP <a href="http://www.gwtproject.org/">官网</a>API、JUnit集成、国际化支持和GUI控件。</li>
<li><a href="http://hao.jobbole.com/grails/">Grails</a>：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。<a href="https://grails.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/ninja/">Ninja</a>：Java全栈Web开发框架。非常稳固、快速和高效。<a href="http://www.ninjaframework.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/pippo/">Pippo</a>：小型、高度模块化的类Sinatra框架。<a href="http://www.pippo.ro/">官网</a></li>
<li><a href="http://hao.jobbole.com/play-framework/">Play</a>：使用约定而非配置，支持代码热加载并在浏览器中显示错误。<a href="https://www.playframework.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/primefaces/">PrimeFaces</a>：JSF框架，提供免费和带支持的商业版本。包括若干前端组件。<a href="http://primefaces.org/">官网</a></li>
<li><a href="http://hao.jobbole.com/ratpack/">Ratpack</a>：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。<a href="https://ratpack.io/">官网</a></li>
<li><a href="http://hao.jobbole.com/spring-boot/">Spring Boot</a>：微框架，简化了Spring新程序的开发过程。<a href="http://projects.spring.io/spring-boot/">官网</a></li>
<li><a href="http://hao.jobbole.com/spring-framework/">Spring</a>：旨在简化Java EE的开发过程，提供依赖注入相关组件并支持面向切面编程。<a href="http://projects.spring.io/spring-framework/">官网</a></li>
<li><a href="http://hao.jobbole.com/vaadin/">Vaadin</a>：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。<a href="https://vaadin.com/">官网</a></li>
<li>Blade：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a href="https://github.com/biezhi/blade">官网</a></li>
</ul>

<h3 id="Business-Process-Management">业务流程管理套件</h3>

<p><em>流程驱动的软件系统构建。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/jbpm/">jBPM</a>：非常灵活的业务流程管理框架，致力于构建开发与业务分析人员之间的桥梁。<a href="http://www.jbpm.org/">官网</a></li>
<li>Activity：轻量级工作流和业务流程管理框架。<a href="http://www.activiti.org/">官网</a> <a href="https://github.com/Activiti/Activiti">github</a></li>
</ul>

<h2 id="resources">资源</h2>

<h3 id="communities">社区</h3>

<ul>
<li>r/java：Reddit的Java子社区。<a href="https://www.reddit.com/r/java">官网</a></li>
<li>stackoverflow：问答平台。<a href="http://stackoverflow.com/questions/tagged/java">官网</a></li>
<li>vJUG：虚拟Java用户组。<a href="http://virtualjug.com/">官网</a></li>
</ul>

<h3 id="influential-books">有影响力的书</h3>

<p><em>具有广泛影响且值得阅读的Java经典书籍。</em></p>

<ul>
<li><a href="http://hao.jobbole.com/effective-java/">Effective Java (2nd Edition)</a></li>
<li><a href="http://hao.jobbole.com/java-8-in-action/">Java 8 in Action</a></li>
<li><a href="http://hao.jobbole.com/java-concurrency-in-practice/">Java Concurrency in Practice | Java并发编程实战</a></li>
<li><a href="http://hao.jobbole.com/thinking-in-java/">Thinking in Java | Java编程思想</a></li>
<li><a href="http://hao.jobbole.com/java-puzzlers/">Java Puzzlers | Java解惑</a></li>
</ul>

<h3 id="podcasts">播客</h3>

<p><em>可以一边编程一边听的东西。</em></p>

<ul>
<li>Java Council：<a href="http://virtualjug.com/podcast/">官网</a></li>
<li>Java Posse：Discontinued as of 02/2015.<a href="http://www.javaposse.com/">官网</a></li>
</ul>

<h3 id="weibo-weixin">微博、微信公众号</h3>

<ul>
<li>ImportNew：是最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。 
<br><img src="http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg" alt=""/></li>
<li>ImportNew 微博：<a href="http://weibo.com/importnew">@ImportNew</a></li>
</ul>

<h3 id="twitter">Twitter</h3>

<ul>
<li><a href="https://twitter.com/AdamBien/">Adam Bien</a>：自由职业者、作家、JavaONE明星演讲者、顾问、Java Champion。</li>
<li><a href="https://twitter.com/agoncal/">Antonio Goncalves</a>：Java Champion、JUG Leader、Devoxx France、Java EE 6/7、JCP、作家。</li>
<li><a href="https://twitter.com/arungupta/">Arun Gupta</a>：Java Champion、JavaONE明星演讲者、JUG Leader、Devoxx4Kids成员、Red Hatter。</li>
<li><a href="https://twitter.com/brunoborges">Bruno Borges</a>：Oracle产品经理、Java Jock。</li>
<li><a href="https://twitter.com/edburns">Ed Burns</a>：Oracle技术团队顾问。</li>
<li><a href="https://twitter.com/baeldung">Eugen Paraschiv</a>：Spring安全课程作者。</li>
<li><a href="https://twitter.com/JavaFXpert">James Weaver</a>：Java、JavaFX、IoT开发者、作者和演讲者。</li>
<li><a href="https://twitter.com/Java_EE/">Java EE</a>：Java EE Twitter官方账号。</li>
<li><a href="https://twitter.com/Oraclejavamag">Java Magazine</a>：Java杂志官方账号。</li>
<li><a href="https://twitter.com/javanetbuzz/">Java.net</a>：Java.net官方账号。</li>
<li><a href="https://twitter.com/java/">Java</a>：Java Twitter官方账号。</li>
<li><a href="https://twitter.com/javinpaul">Javin Paul</a>：知名Java博客作者。</li>
<li><a href="https://twitter.com/lukaseder">Lukas Eder</a>：Data Geekery（jOOQ）创始人兼CEO。</li>
<li><a href="https://twitter.com/mariofusco">Mario Fusco</a>：RedHatter、JUG协调、活跃讲师和作者。</li>
<li><a href="https://twitter.com/mreinhold">Mark Reinhold</a>：Oracle首席架构师、Java平台开发组。</li>
<li><a href="https://twitter.com/karianna">Martijn Verburg</a>：London JUG co-leader、演讲者、作家、Java Champion等。</li>
<li><a href="https://twitter.com/OpenJDK">OpenJDK</a>：OpenJDK官方账号。</li>
<li><a href="https://twitter.com/reza_rahman">Reza Rahman</a>：Java EE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。</li>
<li><a href="https://twitter.com/sjmaple">Simon Maple</a>：Java Champion、virtualJUG创始人、LJC leader、RebelLabs作者。</li>
<li><a href="https://twitter.com/jodastephen">Stephen Colebourne</a>： Java Champion、演讲者。</li>
<li><a href="https://twitter.com/kablosna">Tim Boudreau</a>：作家、NetBeans大牛。</li>
<li><a href="https://twitter.com/trisha_gee">Trisha Gee</a>：Java Champion、演讲者。</li>
</ul>

<h3 id="weibo-weixin">微博、微信公众号</h3>

<ul>
<li>ImportNew 微博：<a href="http://weibo.com/importnew">@ImportNew</a></li>
<li>ImportNew：最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。
<br><img src="http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg" width=150 height=150></li>
</ul>

<h3 id="websites">知名网站</h3>

<p><em>值得关注的Java技术站点。</em></p>

<h4>中文站点</h4>

<ul>
<li><a href="http://www.importnew.com/">ImportNew</a>（ImportNew 专注 Java 技术）</li>
</ul>

<h4>英文站点</h4>

<ul>
<li><a href="https://android-arsenal.com">Android Arsenal</a></li>
<li><a href="http://hao.jobbole.com/google-java-style/">Google Java Style</a>：<a href="https://google.github.io/styleguide/javaguide.html">官网</a></li>
<li><a href="http://hao.jobbole.com/infoq/">InfoQ</a>：<a href="http://www.infoq.com/">官网</a></li>
<li><a href="http://www.javacodegeeks.com/">Java Code Geeks</a></li>
<li><a href="http://blog.jooq.org/">Java, SQL, and jOOQ</a></li>
<li><a href="http://java.net/">Java.net</a></li>
<li><a href="http://java.dzone.com/">Javalobby</a></li>
<li><a href="http://hao.jobbole.com/javaworld/">JavaWorld</a>：<a href="http://www.javaworld.com/">官网</a></li>
<li><a href="http://hao.jobbole.com/jaxenter/">JAXenter</a>：<a href="https://jaxenter.com/">官网</a></li>
<li><a href="http://zeroturnaround.com/rebellabs/">RebelLabs</a></li>
<li><a href="http://hao.jobbole.com/javaspecialists/">The Java Specialist&#39; Newsletter</a>：<a href="http://www.javaspecialists.eu/archive/archive.jsp">官网</a></li>
<li><a href="http://blog.takipi.com/">The Takipi Blog</a></li>
<li><a href="http://hao.jobbole.com/theserverside/">TheServerSide.com</a>：服务器编程交流平台是一个老牌的IT信息网站，关注服务器端编程的，以Java和.Net周边信息为主。<a href="http://www.theserverside.com/">官网</a></li>
<li><a href="http://www.thoughts-on-java.org/">Thoughts On Java</a></li>
<li><a href="http://vanillajava.blogspot.ch/">Vanilla Java</a></li>
<li><a href="http://vladmihalcea.com/">Vlad Mihalcea on Hibernate</a></li>
<li><a href="https://www.voxxed.com/">Voxxed</a></li>
<li><a href="http://hao.jobbole.com/onjava/">OnJava</a>：O&#39;Reilly Java包含最新的Java技术资讯，优质代码，完全的实例和详解。<a href="http://www.onjava.com/">官网</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[B树]]></title>
    <link href="https://books.sangkf.cn/15534816349223.html"/>
    <updated>2019-03-25T10:40:34+08:00</updated>
    <id>https://books.sangkf.cn/15534816349223.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>B树的目的是为了硬盘快速读取数据(降低IO操作次数)而设计的一种平衡的多路查找树。目前大多数据库及文件索引，都是使用B树或者B树的变形来存储实现。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">为什么B树效率高</h2>

<p>在大规模数据存储操作中，由于无法一次性加载到内存里。所以避免不了发生内外存交换。所以次数越少，效率表现也越高。</p>

<p>来看下面这张图：</p>

<p><img src="media/15534816349223/15534826634243.jpg" alt=""/></p>

<p>这是个典型的b树结构，初始因子为1000，高度仅为3的b树，就可以存储1002001000的数据了。</p>

<p>假设要查询最后一个数据:</p>

<ul>
<li>从硬盘加载根节点搜索，IO一次。</li>
<li>根据根节点的指针信息，去加载第二层的节点， IO一次。</li>
<li>重复2，IO一次。</li>
</ul>

<p>IO只用了3次，就查询了需要的数据，所以说B树效率是非常高的。</p>

<p>B树的节点，在硬盘里表现为：柱面里的页(page)或盘块(block) ，如果把索引持久化到内存，只需要一次就够了。</p>

<p>B树的高效的前提是数据已排序。</p>

<h2 id="toc_1">B树结构</h2>

<p><img src="media/15534816349223/15534828070934.jpg" alt=""/></p>

<p>这是B树存储在硬盘的逻辑结构图。</p>

<p>其中根节点中17，35在称为关键字(key) ，实际中往往附带更多复杂类型数据。</p>

<p>可以看出一个节点包含 keys  ChildNotePointer  2部分信息。</p>

<p><img src="media/15534816349223/15534831629323.jpg" alt=""/></p>

<p>根据这张图介绍下b树的基础定义：</p>

<p>这是颗5阶B树的图，阶简写m。</p>

<ol>
<li>树中每个结点最多含有m个子节点（m&gt;=2）。 </li>
<li>每个内节点至少 [ceil(m / 2)] 个子节点。  内节点即非根节点非页子节点，也可以叫中间节点。</li>
<li>关键字key的数量   [ceil(m / 2)-1]&lt;= n &lt;= m-1，关键字按递增排序。</li>
<li>每个叶节点具有相同的深度，即树的高度h，而且不包含关键字信息。</li>
</ol>

<p>上图也可称为最小度数为3的b树，(degree) ，简写t。<br/><br/>
t其实是上面第二条定义中 [ceil(m / 2)] 的值，即t=[ceil(m/2)], 3=ceil(5/2) 。</p>

<ol>
<li>每个非根节点至少有t-1个关键字，非根内节点至少有t个子节点。 t称为度数(degree)，t&gt;=2  。</li>
<li>每个节点至多有2t-1关键字，每个内节点最多有2t个子节点。</li>
<li>每个叶节点具有相同的深度，即树的高度h，而且不包含关键字信息。</li>
</ol>

<p>度和阶都是描述子节点的数量的。</p>

<p>算法导论译版中是用度来描述的。</p>

<p>数据结构与算法分析是用阶来描述，网上大多也是。</p>

<p>下面简单的描述实现逻辑。</p>

<p>搜索：从根节点搜索，找到返回，找不到递归子节点。一直搜索到叶子节点，找到返回，找不到则说明key不存在。</p>

<pre><code class="language-java">//伪代码
entry BTreeSearch(node, key) {
    if(node == null)
           return null;
    for(int i = 0; i &lt; node.keys.length; i++)
    {
        if(node.keys[i] == key)
               return node.data[i];
    }
    return BTreeSearch(ChildrenNode[i].node,key);
}
 
var  entry = BTreeSearch(root, my_key);
</code></pre>

<p>插入：根节点插入，不满直接插入。节点满进行分裂，再满递归分裂。</p>

<p><img src="media/15534816349223/15534844258361.jpg" alt=""/></p>

<p>删除：查询到节点，然后进行删除操作，不满足B数节点的定义则进行节点合并。</p>

<p><img src="media/15534816349223/15534844510809.jpg" alt=""/></p>

<p>更新：查询到子节点，更新数据。</p>

<h2 id="toc_2">B树缺点</h2>

<p>从上面的得知，在查询单条数据是非常快的。但如果范围查的话，b树每次都要从根节点查询一遍。</p>

<p>所以在实际应用中，往往采用b树的变形，b+树来存储，只有叶子节点存储数据，每个叶子节点都指向下一个。</p>

<p>【转载】<a href="https://www.cnblogs.com/mushroom/p/4100087.html">https://www.cnblogs.com/mushroom/p/4100087.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM原理讲解]]></title>
    <link href="https://books.sangkf.cn/15516889064939.html"/>
    <updated>2019-03-04T16:41:46+08:00</updated>
    <id>https://books.sangkf.cn/15516889064939.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本文从 JVM 结构入手，介绍了 Java 内存管理、对象创建、常量池等基础知识，对面试中 JVM 相关的基础题目进行了讲解。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">基本问题</h2>

<ul>
<li>介绍下Java内存区域（运行时数据区）</li>
<li>Java对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</li>
<li>对象的访问定位的两种方式（句柄和直接指针两种方式）</li>
</ul>

<h2 id="toc_1">拓展问题</h2>

<ul>
<li>String类和常量池</li>
<li>8种基本类型的包装类和常量池</li>
</ul>

<h2 id="toc_2">概述</h2>

<p>对于Java程序员来说，在虚拟机自动内存管理机制下，不再需要像C++程序员这样为每一个new操作去写对应的delete/free操作，不容易出现内存泄漏和内存溢出问题，正是因为Java程序员把内存控制权交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>

<h2 id="toc_3">运行时数据区</h2>

<p>Java虚拟机在执行Java程序的过程中会把它管理的内存分成若干个不同的数据区域。</p>

<p><img src="media/15516889064939/15516900494445.jpg" alt=""/></p>

<p><strong>线程私有的</strong>：<em><u>程序计数器，虚拟机栈，本地方法栈</u></em><br/>
<strong>线程共享的</strong>：<em><u>堆，方法区，直接内存</u></em></p>

<h3 id="toc_4">程序计数器</h3>

<p>程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器来选择去下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等功能都需要依赖这个计数器来完成。</p>

<p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>

<p>从上面的介绍中我们知道程序计数器主要有两个作用:</p>

<ul>
<li>字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如顺序执行，选择，循环，异常处理</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了</li>
</ul>

<p><strong>注意</strong>：程序计数器是唯一不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>

<h3 id="toc_5">Java虚拟机栈</h3>

<p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是Java方法执行的内存模型。</p>

<p>Java内存可以粗糙的区分为堆内存(Heap)和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有局部变量表，操作数栈，动态链接，方法出口信息）</p>

<p>局部变量表主要存放可编译器可知的各种数据类型(boolean, byte, char, short, int, float, long, double)，对象引用（refrence类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>

<p>Java虚拟机栈会出现两种异常: StackOverFlowError 和 OutOfMemoryError。</p>

<ul>
<li>StackOverFlowEror：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li>
<li>OutOfMemoryError: 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li>
</ul>

<p>Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>

<h3 id="toc_6">本地方法栈</h3>

<p>和虚拟机栈发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在HotSpot虚拟机中和Java虚拟机栈合二为一。</p>

<p>本地方法被执行的时候，在本地方法栈会创建一个栈桢，用于存放该本地方法的局部变量表，操作数栈，动态链接，出口信息。</p>

<p>方法执行完毕后相应的栈桢也会出栈并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError两种异常。</p>

<h3 id="toc_7">堆</h3>

<p>Java虚拟机所管理的内存中最大的一块，Java堆使所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。几乎所有的对象实例以及数组都在这里分配内存。</p>

<p>Java堆是垃圾收集管理器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap)。从垃圾回收的角度，由于现在收集器基本采用的分代垃圾收集算法，所以Java堆还可以细分为: 新生代和老年代，再细致一点: Eden空间，From Survivor, To Survivor空间等。进一步划分的目的是更好的回收内存，或者更快的分配内存。</p>

<p><img src="media/15516889064939/15517535928182.jpg" alt=""/></p>

<p>在JDK1.8中移除了整个永久代，取而代之的是一个叫元空间(Metaspace)的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</p>

<p>【参考】<a href="https://www.cnblogs.com/paddix/p/5309550.html">Java8内存模型--永久代(PermGen)和元空间(Metaspace)</a></p>

<h3 id="toc_8">方法区</h3>

<p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是他却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java堆区分开来。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消息队列]]></title>
    <link href="https://books.sangkf.cn/15514282455736.html"/>
    <updated>2019-03-01T16:17:25+08:00</updated>
    <id>https://books.sangkf.cn/15514282455736.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>简单介绍了消息队列的优缺点，以及使用场景，如何保证消息的幂等性和高可用<br/>
<span id="more"></span><!-- more --></p>
</blockquote>

<h2 id="toc_0">为什么使用消息队列</h2>

<p>其实就是问问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景用消息队列的什么</p>

<p>先说一下消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有三个：解耦，异步，削峰。</p>

<h3 id="toc_1">解耦</h3>

<p>看这个场景。A系统发送数据到BCD三个系统，通过接口调用发送。如果E系统也要这个数据呢？那如果C系统现在不需要了呢？A系统负责人几乎崩溃。。。</p>

<p><img src="media/15514282455736/15514297168174.jpg" alt="" style="width:600px;"/></p>

<p>在这个场景中，A系统跟其他各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要A系统将这个数据发送过来。A系统要时时刻刻考虑BCDE四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？</p>

<p>如果使用MQ，A系统产生一条数据，发送到MQ里面，那个系统需要消费数据自己去MQ里面消费。如果新系统需要数据，直接从MQ里面消费即可；如果某个系统不需要这条数据了，就取消对MQ消息的消费即可。这样下来，A系统压根儿不需要去考虑给谁发送数据，不需要维护这个代码，也不需要考虑人家是否带哦用成功，失败超时等情况。</p>

<p><img src="media/15514282455736/15514304696275.jpg" alt="" style="width:600px;"/></p>

<p><strong>总结</strong>：通过一个MQ，Pub/Sub发布订阅这么一个模型，A系统就跟其他系统彻底解耦了。</p>

<p>你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个MQ去进行系统的解耦。</p>

<h3 id="toc_2">异步</h3>

<p>再看一个场景，A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要300ms，450ms，200ms。最终请求总延时是3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么懂你心，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p>

<p><img src="media/15514282455736/15514312973749.jpg" alt="" style="width:600px;"/></p>

<p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p>

<p>如果使用MQ，那么A系统连续发送三条消息到MQ队列中，假如耗时5ms，A系统从接受一个请求到返回响应给用户，时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p>

<p><img src="media/15514282455736/15514315070750.jpg" alt="" style="width:600px;"/></p>

<h3 id="toc_3">削峰</h3>

<p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p>

<p>一般的MySQL，扛到每秒 2K 个请求就差不多了，如果每秒请求到 5K的话，可能直接把 MySQL给打死了，导致系统崩溃，用户也就没法再使用系统了。</p>

<p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p>

<p><img src="media/15514282455736/15514319566756.jpg" alt="" style="width:600px;"/></p>

<p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p>

<p><img src="media/15514282455736/15514322373227.jpg" alt=""/></p>

<p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p>

<h2 id="toc_4">消息队列有什么优缺点</h2>

<p>优点上面已经说了，就是<strong>在特殊场景下有其对应的好处，解耦，异步，削峰</strong>。</p>

<p>缺点有以下几个：</p>

<ul>
<li><p>系统可用性降低<br/>
系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用，可以<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md">点击这里查看</a>。</p></li>
<li><p>系统复杂度提高<br/>
硬生生加个 MQ 进来，你怎么<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed.md">保证消息没有重复消费</a>？怎么<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.md">处理消息丢失的情况</a>？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</p></li>
<li><p>一致性问题<br/>
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p></li>
</ul>

<p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p>

<h3 id="toc_5">Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3>

<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>

<tbody>
<tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody>
</table>

<p>综上，各种对比之后，有如下建议：</p>

<p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p>

<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p>

<p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p>

<p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>

<p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。   </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的volatile关键字解析]]></title>
    <link href="https://books.sangkf.cn/15513224851488.html"/>
    <updated>2019-02-28T10:54:45+08:00</updated>
    <id>https://books.sangkf.cn/15513224851488.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">内存模型的相关概念</h2>

<p>计算机的没一条指令都是在CPU中执行的，执行指令的过程中会涉及到数据的读取和写入。由于程序运行过程中的临时数据是放在主存（物理内存）中的，但是由于CPU的执行速度很快，而从内存读取数据和向内存写入数据的过程相对慢很多，因此任何时候对数据的操作会由于要和内存进行交互而拖慢了指令的执行速度。因此CPU里面就有了高速缓存。</p>

<h3 id="toc_1">高速缓存</h3>

<p>程序运行过程中，会将运算需要的数据从主存中复制一份到CPU的告诉缓存中，那么CPU进行计算时就可以直接从它的高速缓存中读取和写入数据，当运算结束时，再将高速缓存中的数据刷新到主存当中。<br/>
但是，由于每个CPU都有自己的高速缓存，当一个变量存在多个CPU的高速缓存中（即多个线程访问共享变量），就可能出现缓存不一致的情况。</p>

<p>所以就出现了缓存一致性协议。</p>

<h3 id="toc_2">缓存一致性协议</h3>

<p><strong>核心思想</strong>：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发信号通知其他CPU将该变量的缓存行置为无效的状态，因此当其他CPU需要读取这个变量时，发现自己缓存中该变量的缓存行是无效的，那么他就会从内存中重新读取。<br/>
<img src="media/15513224851488/15513240773229.jpg" alt="" style="width:400px;"/></p>

<h2 id="toc_3">并发编程中的三个概念</h2>

<ul>
<li><p><strong>原子性</strong><br/>
即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p></li>
<li><p><strong>可见性</strong><br/>
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></li>
<li><p><strong>有序性</strong><br/>
程序执行的顺序按照代码的先后顺序执行。<br/>
因为处理器为了提高程序的运行效率，可能会对代码进行优化，即指令重排序。它不保证程序中的各个语句的执行顺序同代码一致，但是它会保证程序的最终执行结果和代码顺序执行结果是一致的。</p></li>
</ul>

<h2 id="toc_4">Java内存模型</h2>

<p>在Java虚拟机规范中试图定义一种Java内存模型来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台都达到一致的内存访问效果。</p>

<p>Java内存模型规定了程序中变量的访问规则，往大了说也就是程序执行的次序。为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升执行速度，也就没有限制编译器对指令进行重排序。因此，<strong><em>在Java内存模型中也存在缓存一致性和指令重排序的问题</em></strong>。</p>

<p>Java内存模型规定所有的变量都存在与主存当中（类似前面说的物理内存），每个线程有自己的工作内存（类似前面说的高速缓存），线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>

<p>例：在java中，执行下面这个语句：</p>

<pre><code class="language-java">i = 10
</code></pre>

<p><u>执行线程必须现在自己的工作内存中对变量i所在的缓存行进行赋值操作，然后再写入主存中。而不是直接将数值10写入到主存当中。</u></p>

<p>那么Java语言本身对原子性，可见性以及有序性提供了那些保证呢？</p>

<ul>
<li><p><strong>原子性</strong><br/>
对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被打断的，要么执行，要么不执行</p>
<p>例：请分析下面那些操作是原子性操作</p>
<pre><code class="language-java">x = 10;         //语句1
y = x;         //语句2<br/>
x++;           //语句3<br/>
x = x + 1;     //语句4
</code></pre>
<p>上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说, <u>只有简单的读取，赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</u></p>
<p>注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出，Java内存模型只保证了基本的读取和赋值是原子性操作，如果实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></li>
<li><p><strong>可见性</strong><br/>
<strong>对于可见性，Java提供了volatile关键字来保证可见性。</strong></p>
<p><strong>当一个共享变量被volatile修饰时，它会保证修改的值会立刻被更新到主存，当有其他线程需要读取时，它会从内存中读取新值。</strong></p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，<strong>通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且释放锁之前会将对变量的修改刷新到主存中</strong>，因此保证了可见性。</p></li>
<li><p><strong>有序性</strong><br/>
在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p><strong>volatile关键字可以保证一定的有序性。另外通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然保证了有序性。</strong></p></li>
</ul>

<h2 id="toc_5">深入剖析volatile关键字</h2>

<h3 id="toc_6">volatile关键字的两层语义</h3>

<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>

<ul>
<li><p><strong>保证了不同线程对变量操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</strong></p></li>
<li><p><strong>禁止进行指令重排序。</strong></p></li>
</ul>

<p>先看一段代码，假如线程1先执行，线程2后执行：</p>

<pre><code class="language-java">//线程1
boolean stop = false;
while(!stop){
    doSomething();
}
 
//线程2
stop = true;
</code></pre>

<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>

<p>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>

<p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>

<p>但是用volatile修饰之后就变得不一样了：　　</p>

<ol>
<li><strong>使用volatile关键字会强制将修改的值立即写入主存；</strong></li>
<li><strong>使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效；</strong></li>
<li><strong>由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</strong></li>
</ol>

<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>

<p>那么线程1读取到的就是最新的正确的值。</p>

<h3 id="toc_7">volatile保证原子性吗</h3>

<p>下面看一个例子：</p>

<pre><code class="language-java">public class Test {
    public volatile int inc = 0;
     
    public void increase() {
        inc++;
    }
     
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
         
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>

<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>

<p>　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>

<p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>

<p>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>

<p>　　假如某个时刻变量inc的值为10，</p>

<p>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>

<p>　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>

<p>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>

<p>　　那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>

<p>　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>

<p>　　根源就在这里，<strong>自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</strong></p>

<p>把上面的代码改成以下任何一种都可以达到效果：<br/>
采用synchronized：</p>

<pre><code class="language-java">public class Test {
    public  int inc = 0;
    
    public synchronized void increase() {
        inc++;
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>

<p>采用Lock：</p>

<pre><code class="language-java">public class Test {
    public  int inc = 0;
    Lock lock = new ReentrantLock();
    
    public  void increase() {
        lock.lock();
        try {
            inc++;
        } finally{
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>

<p>采用AtomicInteger：</p>

<pre><code class="language-java">public class Test {
    public  AtomicInteger inc = new AtomicInteger();
     
    public  void increase() {
        inc.getAndIncrement();
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>

<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>

<h3 id="toc_8">volatile能保证有序性吗</h3>

<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性<br/>
volatile关键字禁止指令重排序有两层意思：</p>

<ul>
<li><p><strong>当程序执行到volatile变量的读操作或者写操作时,在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行;</strong></p></li>
<li><p><strong>在进行指令优化是，不能将在volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</strong></p></li>
</ul>

<p>可能上面说的比较绕，举个简单的例子：</p>

<pre><code class="language-java">//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
volatile flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
</code></pre>

<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>

<p>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>

<p>那么我们回到前面举的一个例子：</p>

<pre><code class="language-java">//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
</code></pre>

<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>

<p>　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>

<h3 id="toc_9">volatile的原理和实现机制</h3>

<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>

<p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>

<p>　　1）<strong>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</strong></p>

<p>　　2）<strong>它会强制将对缓存的修改操作立即写入主存；</strong></p>

<p>　　3）<strong>如果是写操作，它会导致其他CPU中对应的缓存行无效。</strong></p>

<h3 id="toc_10">使用volatile关键字的场景</h3>

<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>

<ul>
<li><p>对变量的写操作不依赖于当前值</p></li>
<li><p>对变量没有包含在具有其他变量的不变式中</p></li>
</ul>

<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>

<p>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>

<h4 id="toc_11">volatile使用场景</h4>

<p>下面列举几个Java中使用volatile的几个场景。</p>

<ul>
<li><p><strong>状态标记量</strong></p>
<pre><code class="language-java">volatile boolean flag = false;
while(!flag){<br/>
    doSomething();<br/>
}<br/>
public void setFlag() {<br/>
    flag = true;<br/>
}
</code></pre>
<pre><code class="language-java">volatile boolean inited = false;
//线程1:<br/>
context = loadContext();  <br/>
inited = true;            <br/>
//线程2:<br/>
while(!inited ){<br/>
    sleep()<br/>
}<br/>
doSomethingwithconfig(context);
</code></pre>
<p>将volatile变量作为状态标志使用：线程以volatile变量作为循环控制变量（例如控制线程是否继续执行，控制线程的生命周期），由另外一个线程控制该变量的值（true or false）。这种情况下需要变量具有可见性，volatile变量适合。然而，使用synchnorized块编写循环要比使用volatile状态标志编写麻烦很多。由于volaitle简化了代码，并且状态标志不依赖于程序内任何其他状态，因此此处非常适合使用volatile。</p></li>
<li><p><strong>double check</strong></p>
<pre><code class="language-java">class Singleton{
    private volatile static Singleton instance = null;<br/>
    private Singleton() {<br/>
    }<br/>
    public static Singleton getInstance() {<br/>
        if(instance==null) {<br/>
            synchronized (Singleton.class) {<br/>
                if(instance==null)<br/>
                    instance = new Singleton();<br/>
            }<br/>
        }<br/>
        return instance;<br/>
    }<br/>
}
</code></pre></li>
</ul>

<h4 id="toc_12">正确使用volatile关键字</h4>

<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。</p>

<p>volatile变量具有synchronized的可见性特性，但是不具备原子性。这就是说线程能够自动发现volatile变量的最新值。volatile变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用volatile还不足以实现计数器，互斥锁或任何具有多个变量相关的不变式的类。</p>

<p>出于简易性或可伸缩性的考虑，您可能倾向于使用 volatile 变量而不是锁。当使用 volatile 变量而非锁时，某些习惯用法（idiom）更加易于编码和阅读。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。</p>

<p><strong>使用条件</strong></p>

<p>您只能在有限的一些情形下使用 volatile 变量替代锁。<strong>要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件</strong>：</p>

<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ul>

<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>

<p>第一个条件就是不能是自增自减等操作。第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由（读取－修改－写入）操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。</p>

<p>第二个条件我们来举个例子它包含了一个不变式 ：下界总是小于或等于上界。</p>

<pre><code class="language-java">public class NumberRange {  
    private int lower, upper;  
  
    public int getLower() { return lower; }  
    public int getUpper() { return upper; }  
  
    public void setLower(int value) {   
        if (value &gt; upper)   
            throw new IllegalArgumentException(...);  
        lower = value;  
    }  
  
    public void setUpper(int value) {   
        if (value &lt; lower)   
            throw new IllegalArgumentException(...);  
        upper = value;  
    }  
}  
</code></pre>

<p>这种方式限制了范围的状态变量。因此将 lower 和 upper 字段定义为 volatile 类型不能够充分实现类的线程安全；而仍然需要使用同步——使 setLower() 和 setUpper() 操作原子化。</p>

<p>否则，如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是(0, 5)，同一时间内，线程 A 调用setLower(4) 并且线程 B 调用setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是(4, 3) —— 一个无效值，这显然是不对的。</p>

<h4 id="toc_13">volatile 与 synchronized 的比较</h4>

<p>（1）volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住；</p>

<p>（2）volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的；</p>

<p>（3）volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性；</p>

<p>（4）volatile不会造成线程的阻塞，即volatile不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞；synchronized可能会造成线程的阻塞；</p>

<p>（5）当一个域的值依赖于它之前的值时，volatile就无法工作了，如n=n+1,n++等。如果某个域的值受到其他域的值的限制，那么volatile也无法工作，如Range类的lower和upper边界，必须遵循lower&lt;=upper的限制。</p>

<p>（6）volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>

<p><strong>总结</strong>：</p>

<p>与锁相比，volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件即变量真正独立于其他变量和自己以前的值 ，在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。</p>

<p>[<strong>参考</strong>]  <a href="https://www.cnblogs.com/xiaoxi/p/7251171.html">https://www.cnblogs.com/xiaoxi/p/7251171.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HashMap源码解读(JDK1.7)]]></title>
    <link href="https://books.sangkf.cn/15512563500691.html"/>
    <updated>2019-02-27T16:32:30+08:00</updated>
    <id>https://books.sangkf.cn/15512563500691.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p>

<h2 id="toc_0">什么是哈希表</h2>

<p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p>

<h3 id="toc_1">数据结构</h3>

<ul>
<li><p><strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p></li>
<li><p><strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p></li>
<li><p><strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p></li>
<li><p><strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p></li>
</ul>

<p>　　我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构和链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p>

<p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>

<p>　　<strong>存储位置 = f(关键字)</strong></p>

<p>　　其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p>

<p>　　<img src="media/15512563500691/15512566971728.jpg" alt="" style="width:500px;"/></p>

<p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>

<h3 id="toc_2">哈希冲突</h3>

<p>　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单和散列地址分布均匀</strong>,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式，</p>

<h2 id="toc_3">HashMap实现原理</h2>

<p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>

<pre><code class="language-java">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。
transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;
</code></pre>

<p>Entry是HashMap中的一个静态内部类。代码如下</p>

<pre><code class="language-java">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final K key;
        V value;
        Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构
        int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算

        /**
         * Creates new entry.
         */
        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
            value = v;
            next = n;
            key = k;
            hash = h;
        } 
}
</code></pre>

<p>所以，HashMap的整体结构如下<br/>
<img src="media/15512563500691/15512580662636.jpg" alt="" style="width:700px;"/></p>

<p>简单来说，<strong>HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，只需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p>

<p>其他几个重要字段</p>

<pre><code class="language-java">//实际存储的key-value键值对的个数
transient int size;
//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到
int threshold;
//负载因子，代表了table的填充度有多少，默认是0.75
final float loadFactor;
//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException
transient int modCount;
</code></pre>

<p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值。initialCapacity默认为16，loadFactory默认为0.75</p>

<pre><code class="language-java">public HashMap(int initialCapacity, float loadFactor) {
　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(2的30次方)
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);

        this.loadFactor = loadFactor;
        threshold = initialCapacity;
　　　　　
        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现
    }
</code></pre>

<p>从上面这段代码我们可以看出，<strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong></p>

<p>OK,接下来我们来看看put操作的实现吧</p>

<pre><code class="language-java"> public V put(K key, V value) {
        //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(2的4次方=16)
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
       //如果key为null，存储位置为table[0]或table[0]的冲突链上
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀
        int i = indexFor(hash, table.length);//获取在table中的实际位置
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value
            Object k;
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
        modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败
        addEntry(hash, key, value, i);//新增一个entry
        return null;
    }  
</code></pre>

<p>先来看看inflateTable这个方法</p>

<pre><code class="language-java">private void inflateTable(int toSize) {
        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂
        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1
        table = new Entry[capacity];
        initHashSeedAsNeeded(capacity);
    }
</code></pre>

<p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>

<pre><code class="language-java">private static int roundUpToPowerOf2(int number) {
        // assert number &gt;= 0 : &quot;number must be non-negative&quot;;
        return number &gt;= MAXIMUM_CAPACITY
                ? MAXIMUM_CAPACITY
                : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;    
</code></pre>

<p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>

<h3 id="toc_4">hash函数</h3>

<pre><code class="language-java">//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀
final int hash(Object k) {
        int h = hashSeed;
        if (0 != h &amp;&amp; k instanceof String) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode();

        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    }
</code></pre>

<p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>

<pre><code class="language-java">/**
 * 返回数组下标
 */
static int indexFor(int h, int length) {
    return h &amp; (length-1);
}
</code></pre>

<p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p>

<pre><code class="language-java">    1  0  0  1  0
&amp;   0  1  1  1  1
__________________
    0  0  0  1  0    = 2
</code></pre>

<p>最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p>

<p>所以最终存储位置的确定流程是这样的：</p>

<p><img src="media/15512563500691/15512596171164.jpg" alt="" style="width:700px;"/></p>

<p>再来看看addEntry的实现：</p>

<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }
</code></pre>

<p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>

<h2 id="toc_5">为何HashMap的数组长度一定是2的次幂？</h2>

<p>我们来继续看上面提到的resize方法</p>

<pre><code class="language-java">void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }

        Entry[] newTable = new Entry[newCapacity];
        transfer(newTable, initHashSeedAsNeeded(newCapacity));
        table = newTable;
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    }
</code></pre>

<p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p>

<pre><code class="language-java">void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）
        for (Entry&lt;K,V&gt; e : table) {
            while(null != e) {
                Entry&lt;K,V&gt; next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                int i = indexFor(e.hash, newCapacity);
　　　　　　　　　 //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            }
        }
    }
</code></pre>

<p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p>

<p>　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p>

<p>　　<img src="media/15512563500691/1024555-20161115215812138-679881037.png" alt="" style="width:600px;"/></p>

<p> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p>

<p><img src="media/15512563500691/1024555-20161116001404732-625340289.png" alt="" style="width:600px;"/></p>

<p>　　我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>

<p><img src="media/15512563500691/1024555-20161116001717560-1455096254.png" alt="" style="width:600px;"/></p>

<p>　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。<br/>
　　</p>

<h3 id="toc_6">get方法</h3>

<pre><code class="language-java"> public V get(Object key) {
　　　　 //如果key为null,则直接去table[0]处去检索即可。
        if (key == null)
            return getForNullKey();
        Entry&lt;K,V&gt; entry = getEntry(key);
        return null == entry ? null : entry.getValue();
 }
</code></pre>

<p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p>

<pre><code class="language-java">final Entry&lt;K,V&gt; getEntry(Object key) {
            
        if (size == 0) {
            return null;
        }
        //通过key的hashcode值计算hash值
        int hash = (key == null) ? 0 : hash(key);
        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录
        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp; 
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                return e;
        }
        return null;
    }  
</code></pre>

<p>可以看出，get方法的实现相对简单，key(hashcode)--&gt;hash--&gt;indexFor--&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>

<h2 id="toc_7">重写equals方法需同时重写hashCode方法</h2>

<p>　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p>

<pre><code class="language-java">/**
 * Created by chengxiao on 2016/11/15.
 */
public class MyTest {
    private static class Person{
        int idCard;
        String name;

        public Person(int idCard, String name) {
            this.idCard = idCard;
            this.name = name;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()){
                return false;
            }
            Person person = (Person) o;
            //两个对象是否等值，通过idCard来确定
            return this.idCard == person.idCard;
        }

    }
    public static void main(String []args){
        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();
        Person person = new Person(1234,&quot;乔峰&quot;);
        //put到hashmap中去
        map.put(person,&quot;天龙八部&quot;);
        //get取出，从逻辑上讲应该能输出“天龙八部”
        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));
    }
}
</code></pre>

<p>实际输出结果：</p>

<pre><code class="language-java">结果：null
</code></pre>

<p>　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)--&gt;hash--&gt;indexFor--&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)--&gt;hash--&gt;indexFor--&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p>

<p>　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>

<p>[<strong>转载</strong>]：<a href="https://www.cnblogs.com/chengxiao/p/6059914.html">https://www.cnblogs.com/chengxiao/p/6059914.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HashMap源码解读(JDK1.8)]]></title>
    <link href="https://books.sangkf.cn/15512560778974.html"/>
    <updated>2019-02-27T16:27:57+08:00</updated>
    <id>https://books.sangkf.cn/15512560778974.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>在JDK1.8之前，HashMap采用<code>数组+链表</code>实现，即使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">概述</h2>

<p>在JDK1.8之前，HashMap采用<code>数组+链表</code>实现，即使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用<code>数组+链表+红黑树</code>实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>

<p>下图中代表jdk1.8之前的hashmap结构，左边部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。</p>

<p><img src="media/15512560778974/249993-20170725101800296-127995101.png" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>                jdk1.8之前hashmap结构图</p>

<p>     jdk1.8之前的hashmap都采用上图的结构，都是基于一个数组和多个单链表，hash值冲突的时候，就将对应节点以链表的形式存储。如果在一个链表中查找其中一个节点时，将会花费O（n）的查找时间，会有很大的性能损失。到了jdk1.8，当同一个hash值的节点数不小于8时，不再采用单链表形式存储，而是采用红黑树，如下图所示。</p>

<p><img src="media/15512560778974/249993-20170725102326906-1051203702.png" alt="" style="width:300px;"/></p>

<p><img src="media/15512560778974/249993-20170725102510515-1481424113.png" alt="" style="width:500px;"/><br/>
                jdk1.8 hashmap结构图</p>

<p>说明：上图很形象的展示了HashMap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红黑树，红黑树的引入是为了提高效率。</p>

<h2 id="toc_1">涉及到的数据结构：处理hash冲突的链表和红黑树以及位桶</h2>

<h3 id="toc_2">链表的实现</h3>

<p><img src="media/15512560778974/249993-20170725130741693-207764447.png" alt="" style="width:400px;"/></p>

<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。来看具体代码：</p>

<pre><code class="language-java">//Node是单向链表，它实现了Map.Entry接口
static class Node implements Map.Entry { final int hash; final K key;
    V value;
    Node next; //构造函数Hash值 键 值 下一个节点
    Node(int hash, K key, V value, Node next) { this.hash = hash; this.key = key; this.value = value; this.next = next;
    } public final K getKey()        { return key; } public final V getValue()      { return value; } public final String toString() { return key + = + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value);
    } public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue; return oldValue;
    } //判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true
    public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) {
            Map.Entry e = (Map.Entry)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true;
        } return false;
    }
}
</code></pre>

<p>可以看到，node中包含一个next变量，这个就是链表的关键点，hash结果相同的元素就是通过这个next进行关联的。</p>

<h3 id="toc_3">红黑树</h3>

<pre><code class="language-java">//红黑树
static final class TreeNode extends LinkedHashMap.Entry {
    TreeNode parent;  // 父节点
    TreeNode left; //左子树
    TreeNode right;//右子树
    TreeNode prev;    // needed to unlink next upon deletion
    boolean red;    //颜色属性
    TreeNode(int hash, K key, V val, Node next) { super(hash, key, val, next);
    } //返回当前节点的根节点
    final TreeNode root() { for (TreeNode r = this, p;;) { if ((p = r.parent) == null) return r;
            r = p;
        }
    }
}
</code></pre>

<p>红黑树比链表多了四个变量，parent父节点、left左节点、right右节点、prev上一个同级节点，红黑树内容较多，不在赘述。</p>

<h3 id="toc_4">位桶</h3>

<pre><code class="language-java">transient Node[] table;//存储（位桶）的数组
</code></pre>

<p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。</p>

<p>     有了以上3个数据结构，只要有一点数据结构基础的人，都可以大致联想到HashMap的实现了。首先有一个每个元素都是链表（可能表述不准确）的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。</p>

<h2 id="toc_5">HashMap源码分析</h2>

<h3 id="toc_6">类的继承关系</h3>

<pre><code class="language-java">public class HashMap extends AbstractMap implements Map, Cloneable, Serializable
</code></pre>

<p>     可以看到HashMap继承自父类（AbstractMap），实现了Map、Cloneable、Serializable接口。其中，Map接口定义了一组通用的操作；Cloneable接口则表示可以进行拷贝，在HashMap中，实现的是浅层次拷贝，即对拷贝对象的改变会影响被拷贝的对象；Serializable接口表示HashMap实现了序列化，即可以将HashMap对象保存至本地，之后可以恢复状态。</p>

<h3 id="toc_7">类的属性</h3>

<pre><code class="language-java">public class HashMap extends AbstractMap implements Map, Cloneable, Serializable { // 序列号
    private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16
    static final int DEFAULT_INITIAL_CAPACITY = 1 ; // 最大容量
    static final int MAXIMUM_CAPACITY = 1 ; // 默认的填充因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树
    static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表
    static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小
    static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍
    transient Node[] table; // 存放具体元素的集
    transient Set&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。
    transient int size; // 每次扩容和更改map结构的计数器
    transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容
    int threshold; // 填充因子
    final float loadFactor;
}
</code></pre>

<p>说明：类的数据成员很重要，以上也解释得很详细了。</p>

<h3 id="toc_8">类的构造函数</h3>

<h4 id="toc_9">HashMap(int, float)型构造函数</h4>

<pre><code class="language-java">public HashMap(int initialCapacity, float loadFactor) { // 初始容量不能小于0，否则报错
    if (initialCapacity ) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // 初始容量不能大于最大值，否则为最大值
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY; // 填充因子不能小于或等于0，不能为非数字
    if (loadFactor Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // 初始化填充因子 
    this.loadFactor = loadFactor; // 初始化threshold大小
    this.threshold = tableSizeFor(initialCapacity);    
}
</code></pre>

<p>说明：tableSizeFor(initialCapacity)返回大于initialCapacity的最小的二次幂数值。</p>

<pre><code class="language-java">static final int tableSizeFor(int cap) { int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16; return (n = MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre>

<p>说明：&gt;&gt;&gt; 操作符表示无符号右移，高位取0。</p>

<h4 id="toc_10">HashMap(int)型构造函数</h4>

<pre><code class="language-java">public HashMap(int initialCapacity) { // 调用HashMap(int, float)型构造函数
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
</code></pre>

<h4 id="toc_11">HashMap()型构造函数</h4>

<pre><code class="language-java">public HashMap() { // 初始化填充因子
    this.loadFactor = DEFAULT_LOAD_FACTOR; 
}
</code></pre>

<h4 id="toc_12">HashMap(Map)型构造函数</h4>

<pre><code class="language-java">public HashMap(Mapextends K, ? extends V&gt; m) { // 初始化填充因子
    this.loadFactor = DEFAULT_LOAD_FACTOR; // 将m中的所有元素添加至HashMap中
    putMapEntries(m, false);
}
</code></pre>

<p>说明：putMapEntries(Map m, boolean evict)函数将m的所有元素存入本HashMap实例中。　</p>

<pre><code class="language-java">final void putMapEntries(Mapextends K, ? extends V&gt; m, boolean evict) { int s = m.size(); if (s &gt; 0) { // 判断table是否已经初始化
        if (table == null) { // pre-size // 未初始化，s为m的实际元素个数
            float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值
            if (t &gt; threshold)
                threshold = tableSizeFor(t);
        } // 已初始化，并且m元素个数大于阈值，进行扩容处理
        else if (s &gt; threshold)
            resize(); // 将m中的所有元素添加至HashMap中
        for (Map.Entryextends K, ? extends V&gt; e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        }
    }
}
</code></pre>

<h3 id="toc_13">hash算法</h3>

<p>在JDK 1.8中，hash方法如下：</p>

<pre><code class="language-java">static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>

<p>（1）首先获取对象的hashCode()值，然后将hashCode值右移16位，然后将右移后的值与原来的hashCode做<strong>异或</strong>运算，返回结果。（其中h&gt;&gt;&gt;16，在JDK1.8中，优化了高位运算的算法，使用了零扩展，无论正数还是负数，都在高位插入0）。</p>

<p>（2）在putVal源码中，我们通过(n-1)&amp;hash获取该对象的键在hashmap中的位置。（其中hash的值就是（1）中获得的值）其中n表示的是hash桶数组的长度，并且该长度为2的n次方，这样(n-1)&amp;hash就等价于hash%n。因为&amp;运算的效率高于%运算。</p>

<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    ... 
    if ((p = tab[i = (n - 1) &amp; hash]) == null)//获取位置
        tab[i] = newNode(hash, key, value, null);
    ...
}
</code></pre>

<p>      tab即是table，n是map集合的容量大小，hash是上面方法的返回值。因为通常声明map集合时不会指定大小，或者初始化的时候就创建一个容量很大的map对象，所以这个通过容量大小与key值进行hash的算法在开始的时候只会对低位进行计算，虽然容量的2进制高位一开始都是0，但是key的2进制高位通常是有值的，因此先在hash方法中将key的hashCode右移16位在与自身异或，使得高位也可以参与hash，更大程度上减少了碰撞率。</p>

<p>下面举例说明下，n为table的长度。</p>

<p><img src="media/15512560778974/249993-20170725154200021-869603681.png" alt="" style="width:500px;"/></p>

<h3 id="toc_14">重要方法分析</h3>

<p><strong>（1）putVal方法</strong></p>

<p>首先说明，HashMap并没有直接提供putVal接口给用户调用，而是提供的put方法，而put方法就是通过putVal来插入元素的。</p>

<pre><code class="language-java">public V put(K key, V value) { // 对key的hashCode()做hash 
    return putVal(hash(key), key, value, false, true);  
} 
</code></pre>

<p>putVal方法执行过程可以通过下图来理解：</p>

<p><img src="media/15512560778974/249993-20170725160254943-1515467235.png" alt="" style="width:700px;"/></p>

<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>

<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>

<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>

<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>

<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>

<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>

<p>具体源码如下：</p>

<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node[] tab; Node p; int n, i; // 步骤①：tab为空则创建 // table未初始化或者长度为0，进行扩容
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素
    else {
        Node e; K k; // 步骤③：节点key存在，直接覆盖value // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等
        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 将第一个元素赋值给e，用e来记录
                e = p; // 步骤④：判断该链为红黑树 // hash值不相等，即key不相等；为红黑树结点
        else if (p instanceof TreeNode) // 放入树中
            e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 // 为链表结点
        else { // 在链表最末插入结点
            for (int binCount = 0; ; ++binCount) { // 到达链表的尾部
                if ((e = p.next) == null) { // 在尾部插入新结点
                    p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
 treeifyBin(tab, hash); // 跳出循环
                    break;
                } // 判断链表中结点的key值与插入的元素的key值是否相等
                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循环
                    break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表
                p = e;
            }
        } // 表示在桶中找到key值、hash值与插入元素相等的结点
        if (e != null) { // 记录e的value
            V oldValue = e.value; // onlyIfAbsent为false或者旧值为null
            if (!onlyIfAbsent || oldValue == null) //用新值替换旧值
                e.value = value; // 访问后回调
 afterNodeAccess(e); // 返回旧值
            return oldValue;
        }
    } // 结构性修改
    ++modCount; // 步骤⑥：超过最大容量 就扩容 // 实际大小大于阈值则扩容
    if (++size &gt; threshold)
        resize(); // 插入后回调
 afterNodeInsertion(evict); return null;
}
</code></pre>

<h5 id="toc_15">HashMap的数据存储实现原理</h5>

<p><strong>流程：</strong></p>

<p>1. 根据key计算得到key.hash = (h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)；</p>

<p>2. 根据key.hash计算得到桶数组的索引index = key.hash &amp; (table.length - 1)，这样就找到该key的存放位置了：</p>

<p>① 如果该位置没有数据，用该数据新生成一个节点保存新数据，返回null；</p>

<p>② 如果该位置有数据是一个红黑树，那么执行相应的插入 / 更新操作；</p>

<p>③ 如果该位置有数据是一个链表，分两种情况一是该链表没有这个节点，另一个是该链表上有这个节点，注意这里判断的依据是key.hash是否一样：</p>

<p>如果该链表没有这个节点，那么采用尾插法新增节点保存新数据，返回null；如果该链表已经有这个节点了，那么找到该节点并更新新数据，返回老数据。</p>

<p>注意：</p>

<p>HashMap的put会返回key的上一次保存的数据，比如：</p>

<pre><code class="language-java">HashMap map = new HashMap();
System.out.println(map.put(&quot;a&quot;, &quot;A&quot;)); // 打印null
System.out.println(map.put(&quot;a&quot;, &quot;AA&quot;)); // 打印A
System.out.println(map.put(&quot;a&quot;, &quot;AB&quot;)); // 打印AA
</code></pre>

<p><strong>（2）getNode方法</strong></p>

<p>说明：HashMap同样并没有直接提供getNode接口给用户调用，而是提供的get方法，而get方法就是通过getNode来取得元素的。</p>

<pre><code class="language-java">public V get(Object key) {
    Node e; return (e = getNode(hash(key), key)) == null ? null : e.value;
}
</code></pre>

<pre><code class="language-java">final Node getNode(int hash, Object key) {
    Node[] tab; Node first, e; int n; K k; // table已经初始化，长度大于0，根据hash寻找table中的项也不为空
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 桶中第一项(数组元素)相等
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个结点
        if ((e = first.next) != null) { // 为红黑树结点
            if (first instanceof TreeNode) // 在红黑树中查找
                return ((TreeNode)first).getTreeNode(hash, key); // 否则，在链表中查找
            do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e;
            } while ((e = e.next) != null);
        }
    } return null;
}
</code></pre>

<p><strong>（3）resize方法</strong></p>

<p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p>

<p>②.每次扩展的时候，都是扩展2倍；</p>

<p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p>

<pre><code class="language-java">final Node[] resize() {
    Node[] oldTab = table;//oldTab指向hash桶数组
    int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) {//如果oldCap不为空的话，就是hash桶数组不为空
        if (oldCap &gt;= MAXIMUM_CAPACITY) {//如果大于最大容量了，就赋值为整数最大的阀值
            threshold = Integer.MAX_VALUE; return oldTab;//返回
        }//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16
        else if ((newCap = oldCap oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr // double threshold 双倍扩容阀值threshold
 } else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr; else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    } if (newThr == 0) { float ft = (float)newCap * loadFactor;
        newThr = (newCap float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node[] newTab = (Node[])new Node[newCap];//新建hash桶数组
    table = newTab;//将新数组的值复制给旧的hash桶数组
    if (oldTab != null) {//进行扩容操作，复制Node对象值到新的hash桶数组
        for (int j = 0; j j) {
            Node e; if ((e = oldTab[j]) != null) {//如果旧的hash桶数组在j结点处不为空，复制给e
                oldTab[j] = null;//将旧的hash桶数组在j结点处设置为空，方便gc
                if (e.next == null)//如果e后面没有Node结点
                    newTab[e.hash &amp; (newCap - 1)] = e;//直接对e的hash值对新的数组长度求模获得存储位置
                else if (e instanceof TreeNode)//如果e是红黑树的类型，那么添加到红黑树中
                    ((TreeNode)e).split(this, newTab, j, oldCap); else { // preserve order
                    Node loHead = null, loTail = null;
                    Node hiHead = null, hiTail = null;
                    Node next; do {
                        next = e.next;//将Node结点的next赋值给next
                        if ((e.hash &amp; oldCap) == 0) {//如果结点e的hash值与原hash桶数组的长度作与运算为0
                            if (loTail == null)//如果loTail为null
                                loHead = e;//将e结点赋值给loHead
                            else loTail.next = e;//否则将e赋值给loTail.next
                            loTail = e;//然后将e复制给loTail
 } else {//如果结点e的hash值与原hash桶数组的长度作与运算不为0
                            if (hiTail == null)//如果hiTail为null
                                hiHead = e;//将e赋值给hiHead
                            else hiTail.next = e;//如果hiTail不为空，将e复制给hiTail.next
                            hiTail = e;//将e复制个hiTail
 }
                    } while ((e = next) != null);//直到e为空
                    if (loTail != null) {//如果loTail不为空
                        loTail.next = null;//将loTail.next设置为空
                        newTab[j] = loHead;//将loHead赋值给新的hash桶数组[j]处
 } if (hiTail != null) {//如果hiTail不为空
                        hiTail.next = null;//将hiTail.next赋值为空
                        newTab[j + oldCap] = hiHead;//将hiHead赋值给新的hash桶数组[j+旧hash桶数组长度]
 }
                }
            }
        }
    } return newTab;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java基础知识整理]]></title>
    <link href="https://books.sangkf.cn/15511460518747.html"/>
    <updated>2019-02-26T09:54:11+08:00</updated>
    <id>https://books.sangkf.cn/15511460518747.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>不积跬步无以至千里，不积小流无以成江海<br/>
千里之行，始于足下</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">数据类型</h2>

<ul>
<li><p><strong>基本类型</strong></p>
<ul>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
<li>boolean/~</li>
</ul>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 并不支持 boolean 数组，而是使用 byte 数组来表示 int 数组来表示。</p></li>
<li><p><strong>包装类型</strong></p>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<pre><code class="language-java">Integer x = 2;     // 装箱
int y = x;         // 拆箱
</code></pre></li>
<li><p><strong>缓存池</strong></p>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<pre><code class="language-java">Integer x = new Integer(123);
Integer y = new Integer(123);<br/>
System.out.println(x == y);    // false<br/>
Integer z = Integer.valueOf(123);<br/>
Integer k = Integer.valueOf(123);<br/>
System.out.println(z == k);   // true
</code></pre>
<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<pre><code class="language-java">public static Integer valueOf(int i) {
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br/>
        return IntegerCache.cache[i + (-IntegerCache.low)];<br/>
    return new Integer(i);<br/>
}
</code></pre>
<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<pre><code class="language-java">static final int low = -128;
static final int high;<br/>
static final Integer cache[];<br/>
static {<br/>
    // high value may be configured by property<br/>
    int h = 127;<br/>
    String integerCacheHighPropValue =<br/>
        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);<br/>
    if (integerCacheHighPropValue != null) {<br/>
        try {<br/>
            int i = parseInt(integerCacheHighPropValue);<br/>
            i = Math.max(i, 127);<br/>
            // Maximum array size is Integer.MAX_VALUE<br/>
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);<br/>
        } catch( NumberFormatException nfe) {<br/>
            // If the property cannot be parsed into an int, ignore it.<br/>
        }<br/>
    }<br/>
    high = h;<br/>
    cache = new Integer[(high - low) + 1];<br/>
    int j = low;<br/>
    for(int k = 0; k &lt; cache.length; k++)<br/>
        cache[k] = new Integer(j++);<br/>
    // range [-128, 127] must be interned (JLS7 5.1.7)<br/>
    assert IntegerCache.high &gt;= 127;<br/>
}
</code></pre>
<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p>
<pre><code class="language-java">Integer m = 123;
Integer n = 123;<br/>
System.out.println(m == n); // true
</code></pre>
<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p></li>
</ul>

<h2 id="toc_1">String</h2>

<ul>
<li><p><strong>概览</strong><br/>
String 被声明为 final，因此它不可被继承。<br/>
在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {<br/>
    /** The value is used for character storage. */<br/>
    private final char value[];<br/>
}
</code></pre>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</p>
<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {<br/>
    /** The value is used for character storage. */<br/>
    private final byte[] value;<br/>
    /** The identifier of the encoding used to encode the bytes in {@code value}. */<br/>
    private final byte coder;<br/>
}
</code></pre>
<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p></li>
<li><p><strong>不可变的好处</strong></p>
<ol>
<li>可以缓存 hash 值<br/>
因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li>String Pool 的需要<br/>
如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。
<img src="media/15511460518747/15511491243385.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></li>
<li>安全性<br/>
String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
<li>线程安全<br/>
String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ol></li>
<li><p><strong>String, StringBuffer and StringBuilder</strong></p>
<ol>
<li>可变性
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul></li>
<li>线程安全
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul></li>
</ol></li>
<li><p><strong>String Pool</strong></p>
<p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<pre><code class="language-java">String s1 = new String(&quot;aaa&quot;);
String s2 = new String(&quot;aaa&quot;);<br/>
System.out.println(s1 == s2);           // false<br/>
String s3 = s1.intern();<br/>
String s4 = s1.intern();<br/>
System.out.println(s3 == s4);           // true
</code></pre>
<p>如果是采用 &quot;bbb&quot; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<pre><code class="language-java">String s5 = &quot;bbb&quot;;
String s6 = &quot;bbb&quot;;<br/>
System.out.println(s5 == s6);  // true
</code></pre>
<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p></li>
<li><p><strong>new String(&quot;abc&quot;)</strong></p>
<p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &quot;abc&quot; 字符串对象）。</p>
<ul>
<li>&quot;abc&quot; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &quot;abc&quot; 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。<br/>
创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</li>
</ul>
<pre><code class="language-java">public class NewStringTest {
    public static void main(String[] args) {<br/>
        String s = new String(&quot;abc&quot;);<br/>
    }<br/>
}
</code></pre>
<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<pre><code class="language-java">// ...
Constant pool:<br/>
// ...<br/>
   #2 = Class              #18            // java/lang/String<br/>
   #3 = String             #19            // abc<br/>
// ...<br/>
  #18 = Utf8               java/lang/String<br/>
  #19 = Utf8               abc<br/>
// ...<br/>
  public static void main(java.lang.String[]);<br/>
    descriptor: ([Ljava/lang/String;)V<br/>
    flags: ACC_PUBLIC, ACC_STATIC<br/>
    Code:<br/>
      stack=3, locals=2, args_size=1<br/>
         0: new           #2                  // class java/lang/String<br/>
         3: dup<br/>
         4: ldc           #3                  // String abc<br/>
         6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V<br/>
         9: astore_1<br/>
// ...
</code></pre>
<p>在 Constant Pool 中，#19 存储这字符串字面量 &quot;abc&quot;，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<pre><code class="language-java">public String(String original) {
    this.value = original.value;<br/>
    this.hash = original.hash;<br/>
}
</code></pre></li>
</ul>

<h2 id="toc_2">运算</h2>

<ul>
<li><strong>参数传递</strong>
Java 的参数是以值传递的形式传入方法中，而不是引用传递。</li>
</ul>

<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p>

<pre><code class="language-java">public class Dog {

    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }

    void setName(String name) {
        this.name = name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
</code></pre>

<pre><code class="language-java">public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog(&quot;B&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
</code></pre>

<p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p>

<pre><code class="language-java">class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName(&quot;B&quot;);
    }
}
</code></pre>

<ul>
<li><strong>float 与 double</strong>
Java 不能隐式执行向下转型，因为这会使得精度降低。<br/>
1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</li>
</ul>

<pre><code class="language-java">// float f = 1.1;
</code></pre>

<p>1.1f 字面量才是 float 类型。</p>

<pre><code class="language-java">float f = 1.1f;
</code></pre>

<ul>
<li><strong>隐式类型转换</strong>
因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</li>
</ul>

<pre><code class="language-java">short s1 = 1;
// s1 = s1 + 1;
</code></pre>

<p>但是使用 += 或者 ++ 运算符可以执行隐式类型转换。</p>

<pre><code class="language-java">s1 += 1;
// s1++;
</code></pre>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>

<pre><code class="language-java">s1 = (short) (s1 + 1);
</code></pre>

<ul>
<li><strong>switch</strong>
从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</li>
</ul>

<pre><code class="language-java">String s = &quot;a&quot;;
switch (s) {
    case &quot;a&quot;:
        System.out.println(&quot;aaa&quot;);
        break;
    case &quot;b&quot;:
        System.out.println(&quot;bbb&quot;);
        break;
}
</code></pre>

<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>

<pre><code class="language-java">// long x = 111;
// switch (x) { // Incompatible types. Found: &#39;long&#39;, required: &#39;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#39;
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }
</code></pre>

<h2 id="toc_3">继承</h2>

<h3 id="toc_4">访问权限</h3>

<p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>

<p>可以对类或类中的成员（字段以及方法）加上访问修饰符。<br/>
    <strong>类可见表示其它类可以用这个类创建实例对象。<br/>
    成员可见表示其它类可以用这个类的实例对象访问到该成员；</strong></p>

<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>

<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>

<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p>

<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>

<pre><code class="language-java">public class AccessExample {
    public String id;
}
</code></pre>

<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>

<pre><code class="language-java">public class AccessExample {

    private int id;

    public String getId() {
        return id + &quot;&quot;;
    }

    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}
</code></pre>

<p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>

<pre><code class="language-java">public class AccessWithInnerClassExample {

    private class InnerClass {
        int x;
    }

    private InnerClass innerClass;

    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }

    public int getValue() {
        return innerClass.x;  // 直接访问
    }
}
</code></pre>

<h3 id="toc_5">抽象类与接口</h3>

<ul>
<li><strong>抽象类</strong></li>
</ul>

<p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p>

<p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p>

<pre><code class="language-java">public abstract class AbstractClassExample {
    
    protected int x;
    private int y;
    
    public abstract void func1();
    
    public void func2() {
        System.out.println(&quot;func2&quot;);
    }
}
</code></pre>

<pre><code class="language-java">public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println(&quot;func1&quot;);
    }
}
</code></pre>

<pre><code class="language-java">// AbstractClassExample ac1 = new AbstractClassExample(); 
// &#39;AbstractClassExample&#39; is abstract; cannot be instantiated
AbstractClassExample ac2 = new AbstractExtendClassExample();
ac2.func1();
</code></pre>

<ul>
<li><strong>接口</strong></li>
</ul>

<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>

<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p>

<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p>

<p>接口的字段默认都是 static 和 final 的。</p>

<pre><code class="language-java">    public interface InterfaceExample {
    
    void func1();
    
    default void func2(){
        System.out.println(&quot;func2&quot;);
    }
    
    int x = 123;
    // int y;               // Variable &#39;y&#39; might not have been initialized
    public int z = 0;       // Modifier &#39;public&#39; is redundant for interface fields
    // private int k = 0;   // Modifier &#39;private&#39; not allowed here
    // protected int l = 0; // Modifier &#39;protected&#39; not allowed here
    // private void fun3(); // Modifier &#39;private&#39; not allowed here
} 
</code></pre>

<pre><code class="language-java">public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println(&quot;func1&quot;);
    }
}
</code></pre>

<pre><code class="language-java"> // InterfaceExample ie1 = new InterfaceExample(); // &#39;InterfaceExample&#39; is abstract; cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
</code></pre>

<ul>
<li><p><strong>比较</strong>   </p>
<ul>
<li>从设计层面来看，抽象类提供了一种IS-A关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种LIKE-A关系，他只是提供一个方法实现契约，并不要求接口和实现的类具有IS—A关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但不能继承多个抽象类。</li>
<li>接口的字段只能是static和final类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是public的，而抽象类的成员可以有多重访问权限。</li>
</ul></li>
<li><p><strong>使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/">深入理解 abstract class 和 interface</a></li>
<li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface">When to Use Abstract Class and Interface</a></li>
</ul></li>
</ul>

<h3 id="toc_6">super</h3>

<ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>

<pre><code class="language-java">public class SuperExample {

    protected int x;
    protected int y;

    public SuperExample(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void func() {
        System.out.println(&quot;SuperExample.func()&quot;);
    }
}
</code></pre>

<pre><code class="language-java">public class SuperExtendExample extends SuperExample {

    private int z;

    public SuperExtendExample(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    public void func() {
        super.func();
        System.out.println(&quot;SuperExtendExample.func()&quot;);
    }
}
</code></pre>

<pre><code class="language-java">SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();
</code></pre>

<pre><code class="language-java">SuperExample.func()
SuperExtendExample.func()
</code></pre>

<h3 id="toc_7">重写与重载</h3>

<h4 id="toc_8">重写</h4>

<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。<br/>
为了满足里式替换原则，重写有有以下两个限制：</p>

<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。<br/>
使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</li>
</ul>

<h4 id="toc_9">重载</h4>

<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>

<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>

<h4 id="toc_10">实例</h4>

<pre><code class="language-java">class A {
    public String show(D obj) {
        return (&quot;A and D&quot;);
    }

    public String show(A obj) {
        return (&quot;A and A&quot;);
    }
}

class B extends A {
    public String show(B obj) {
        return (&quot;B and B&quot;);
    }

    public String show(A obj) {
        return (&quot;B and A&quot;);
    }
}

class C extends B {
}

class D extends B {
}
</code></pre>

<pre><code class="language-java">public class Test {

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new B();
        B b = new B();
        C c = new C();
        D d = new D();
        System.out.println(a1.show(b)); // A and A
        System.out.println(a1.show(c)); // A and A
        System.out.println(a1.show(d)); // A and D
        System.out.println(a2.show(b)); // B and A
        System.out.println(a2.show(c)); // B and A
        System.out.println(a2.show(d)); // A and D
        System.out.println(b.show(b));  // B and B
        System.out.println(b.show(c));  // B and B
        System.out.println(b.show(d));  // A and D
    }
}
</code></pre>

<pre><code class="language-java">public class Test {

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new B();
        B b = new B();
        C c = new C();
        D d = new D();
        System.out.println(a1.show(b)); // A and A
        System.out.println(a1.show(c)); // A and A
        System.out.println(a1.show(d)); // A and D
        System.out.println(a2.show(b)); // B and A
        System.out.println(a2.show(c)); // B and A
        System.out.println(a2.show(d)); // A and D
        System.out.println(b.show(b));  // B and B
        System.out.println(b.show(c));  // B and B
        System.out.println(b.show(d));  // A and D
    }
}
</code></pre>

<p>涉及到重写时，方法调用的优先级为：</p>

<ul>
<li>this.show(O)</li>
<li>super.show(O)</li>
<li>this.show((super)O)</li>
<li>super.show((super)O)</li>
</ul>

<h2 id="toc_11">Object 通用方法</h2>

<h3 id="toc_12">概览</h3>

<pre><code class="language-java">public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class&lt;?&gt; getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
</code></pre>

<h3 id="toc_13">equals()</h3>

<h4 id="toc_14">等价关系</h4>

<ul>
<li><strong>自反性</strong></li>
</ul>

<pre><code class="language-java">x.equals(x); // true
</code></pre>

<ul>
<li><strong>对称性</strong></li>
</ul>

<pre><code class="language-java">x.equals(y) == y.equals(x); // true
</code></pre>

<ul>
<li><strong>传递性</strong></li>
</ul>

<pre><code class="language-java">if (x.equals(y) &amp;&amp; y.equals(z))
    x.equals(z); // true;
</code></pre>

<ul>
<li><strong>一致性</strong></li>
</ul>

<p>多次调用 equals() 方法结果不变</p>

<pre><code class="language-java">x.equals(y) == x.equals(y); // true
</code></pre>

<ul>
<li><strong>与NULL的比较</strong></li>
</ul>

<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>

<pre><code class="language-java">x.equals(null); // false;
</code></pre>

<h4 id="toc_15">等价与相等</h4>

<ul>
<li>对于基本类型，==判断两个值是否相等，基本类型没有equals()方法</li>
<li>对于引用类型，==判断两个变量是否引用同一个对象，而equals()判断引用的对象是否等价</li>
</ul>

<pre><code class="language-java">Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false
</code></pre>

<h4 id="toc_16">实现</h4>

<ul>
<li>检查是否为同一个对象的引用，如果是直接返回true</li>
<li>检查是否为同一类型，如果不是，直接返回false</li>
<li>将Object对象进行转型</li>
<li>判断每个关键域是否相等</li>
</ul>

<pre><code class="language-java">public class EqualExample {

    private int x;
    private int y;
    private int z;

    public EqualExample(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EqualExample that = (EqualExample) o;

        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}
</code></pre>

<h3 id="toc_17">hashCode()</h3>

<p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p>

<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p>

<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p>

<pre><code class="language-java">EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
</code></pre>

<p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p>

<p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>

<pre><code class="language-java">@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
</code></pre>

<h3 id="toc_18">toString()</h3>

<p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>

<pre><code class="language-java">public class ToStringExample {

    private int number;

    public ToStringExample(int number) {
        this.number = number;
    }
}
</code></pre>

<pre><code class="language-java">ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());
</code></pre>

<pre><code class="language-java">ToStringExample@4554617c
</code></pre>

<h3 id="toc_19">clone()</h3>

<h4 id="toc_20">cloneable</h4>

<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>

<pre><code class="language-java">public class CloneExample {
    private int a;
    private int b;
}
</code></pre>

<pre><code class="language-java">CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;
</code></pre>

<p>重写 clone() 得到以下实现：</p>

<pre><code class="language-java">public class CloneExample {
    private int a;
    private int b;

    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
</code></pre>

<pre><code class="language-java">CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
</code></pre>

<pre><code class="language-java">java.lang.CloneNotSupportedException: CloneExample
</code></pre>

<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>

<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>

<pre><code class="language-java">public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>

<h4 id="toc_21">浅拷贝</h4>

<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>

<pre><code class="language-java">public class ShallowCloneExample implements Cloneable {

    private int[] arr;

    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}
</code></pre>

<pre><code class="language-java">ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 222
</code></pre>

<h4 id="toc_22">深拷贝</h4>

<p>拷贝对象和原始对象的引用类型引用不同对象。</p>

<pre><code class="language-java">public class DeepCloneExample implements Cloneable {

    private int[] arr;

    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone();
        result.arr = new int[arr.length];
        for (int i = 0; i &lt; arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;
    }
}
</code></pre>

<pre><code class="language-java">DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
</code></pre>

<h4 id="toc_23">clone的替代方案</h4>

<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>

<pre><code class="language-java">public class CloneConstructorExample {

    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i &lt; original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
</code></pre>

<pre><code class="language-java">CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
</code></pre>

<h2 id="toc_24">关键字</h2>

<h3 id="toc_25">final</h3>

<h4 id="toc_26">数据</h4>

<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>

<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>

<pre><code class="language-java">final int x = 1;
// x = 2;  // cannot assign value to final variable &#39;x&#39;
final A y = new A();
y.a = 1;
</code></pre>

<h4 id="toc_27">方法</h4>

<p>声明方法不能被子类重写。</p>

<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>

<h4 id="toc_28">类</h4>

<p>声明类不允许被继承。</p>

<h3 id="toc_29">static</h3>

<h4 id="toc_30">静态变量</h4>

<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>

<pre><code class="language-java">public class A {

    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field &#39;x&#39; cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
</code></pre>

<h4 id="toc_31">静态方法</h4>

<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>

<pre><code class="language-java">public abstract class A {
    public static void func1(){
    }
    // public abstract static void func2();  // Illegal combination of modifiers: &#39;abstract&#39; and &#39;static&#39;
}
</code></pre>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p>

<pre><code class="language-java">public class A {

    private static int x;
    private int y;

    public static void func1(){
        int a = x;
        // int b = y;  // Non-static field &#39;y&#39; cannot be referenced from a static context
        // int b = this.y;     // &#39;A.this&#39; cannot be referenced from a static context
    }
}
</code></pre>

<h4 id="toc_32">静态语句块</h4>

<p>静态语句块在类初始化时运行一次。</p>

<pre><code class="language-java">public class A {
    static {
        System.out.println(&quot;123&quot;);
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}
</code></pre>

<pre><code class="language-java">123
</code></pre>

<h4 id="toc_33">静态内部类</h4>

<p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p>

<pre><code class="language-java">public class OuterClass {

    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // &#39;OuterClass.this&#39; cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
</code></pre>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>

<h4 id="toc_34">静态导包</h4>

<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>

<pre><code class="language-java">import static com.xxx.ClassName.*
</code></pre>

<h4 id="toc_35">初始化顺序</h4>

<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>

<pre><code class="language-java">public static String staticField = &quot;静态变量&quot;;
</code></pre>

<pre><code class="language-java">static {
    System.out.println(&quot;静态语句块&quot;);
}
</code></pre>

<pre><code class="language-java">public String field = &quot;实例变量&quot;;
</code></pre>

<pre><code class="language-java">{
    System.out.println(&quot;普通语句块&quot;);
}
</code></pre>

<p>最后才是构造函数的初始化。</p>

<pre><code class="language-java">public InitialOrderTest() {
    System.out.println(&quot;构造函数&quot;);
}
</code></pre>

<p>存在继承的情况下，初始化顺序为：</p>

<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>

<h2 id="toc_36">反射</h2>

<p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>

<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>

<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>

<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>

<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 创建新的对象。</li>
</ul>

<p><strong>反射的优点：</strong></p>

<ul>
<li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>

<p><strong>反射的缺点：</strong></p>

<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>

<ul>
<li><p><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p></li>
<li><p><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p></li>
<li><p><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p></li>
<li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Trail: The Reflection API</a></p></li>
<li><p><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1）- 基础</a></p></li>
</ul>

<h2 id="toc_37">异常</h2>

<p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>

<ul>
<li><strong>受检异常</strong> ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>

<p><img src="media/15511460518747/PPjwP.png" alt="" style="width:600px;"/></p>

<ul>
<li><a href="https://www.tianmaying.com/tutorial/Java-Exception">Java 入门之异常处理</a></li>
<li><a href="http://www.importnew.com/7383.html">Java 异常的面试问题及答案 -Part 1</a></li>
</ul>

<h2 id="toc_38">泛型</h2>

<pre><code class="language-java">public class Box&lt;T&gt; {
    // T stands for &quot;Type&quot;
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
</code></pre>

<ul>
<li><a href="http://www.importnew.com/24029.html">Java 泛型详解</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1033693">10 道 Java 泛型面试题</a></li>
</ul>

<h2 id="toc_39">注解</h2>

<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>

<p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解 Annotation 实现原理与自定义注解例子</a></p>

<h2 id="toc_40">特性</h2>

<h3 id="toc_41">Java 各版本的新特性</h3>

<p><strong>New highlights in Java SE 8</strong></p>

<ol>
<li>Lambda Expressions</li>
<li>Pipelines and Streams</li>
<li>Date and Time API</li>
<li>Default Methods</li>
<li>Type Annotations</li>
<li>Nashhorn JavaScript Engine</li>
<li>Concurrent Accumulators</li>
<li>Parallel operations</li>
<li>PermGen Error Removed</li>
</ol>

<p><strong>New highlights in Java SE 7</strong></p>

<ol>
<li>Strings in Switch Statement</li>
<li>Type Inference for Generic Instance Creation</li>
<li>Multiple Exception Handling</li>
<li>Support for Dynamic Languages</li>
<li>Try with Resources</li>
<li>Java nio Package</li>
<li>Binary Literals, Underscore in literals</li>
<li><p>Diamond Syntax</p></li>
</ol>

<ul>
<li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17">Difference between Java 1.8 and Java 1.7?</a></li>
<li><a href="http://www.importnew.com/19345.html">Java 8 特性</a></li>
</ul>

<h2 id="toc_42">Java 与 C++ 的区别</h2>

<ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
<li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li>
</ul>

<h2 id="toc_43">JRE or JDK</h2>

<ul>
<li>JRE is the JVM program, Java application need to run on JRE.</li>
<li>JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler &quot;javac&quot;</li>
</ul>

<h2 id="toc_44">参考资料</h2>

<ul>
<li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li>
<li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li>
</ul>

<h2 id="toc_45">进阶指南</h2>

<p><a href="https://github.com/CyC2018/Backend-Interview-Guide">https://github.com/CyC2018/Backend-Interview-Guide</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务架构下处理分布式事务的典型方案]]></title>
    <link href="https://books.sangkf.cn/15511042581022.html"/>
    <updated>2019-02-25T22:17:38+08:00</updated>
    <id>https://books.sangkf.cn/15511042581022.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>根据微服务架构的鼻祖Martin Fowler的忠告，微服务架构中应当尽量避免分布式事务。然而，在某些领域，分布式事务如同宿命中的对手无法避免。在工程领域，分布式事务的讨论主要聚焦于强一致性和最终一致性的解决方案。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">引述</h2>

<p>根据微服务架构的鼻祖Martin Fowler的忠告，微服务架构中应当尽量避免分布式事务。然而，在某些领域，分布式事务如同宿命中的对手无法避免。在工程领域，分布式事务的讨论主要聚焦于强一致性和最终一致性的解决方案。典型方案包括：</p>

<ul>
<li>两阶段提交（2PC, Two-phase Commit）方案；</li>
<li>eBay 事件队列方案；</li>
<li>TCC 补偿模式；</li>
<li>缓存数据最终一致性。</li>
</ul>

<h2 id="toc_1">一致性理论</h2>

<p>分布式事务的目的是保障分库数据一致性，而跨库事务会遇到各种不可控制的问题，如个别节点永久性宕机，像单机事务一样的ACID是无法奢望的。另外，业界著名的CAP理论也告诉我们，对分布式系统，需要将数据一致性和系统可用性、分区容忍性放在天平上一起考虑。</p>

<p>两阶段提交协议（简称2PC）是实现分布式事务较为经典的方案，但2PC 的可扩展性很差，在分布式架构下应用代价较大，eBay 架构师Dan Pritchett 提出了BASE 理论，用于解决大规模分布式系统下的数据一致性问题。BASE 理论告诉我们：可以通过放弃系统在每个时刻的强一致性来换取系统的可扩展性。</p>

<ul>
<li><p>CAP理论</p>
<ul>
<li><p>在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）3 个要素最多只能同时满足两个，不可兼得。其中，分区容忍性又是不可或缺的。</p>
<ul>
<li>一致性：分布式环境下多个节点的数据是否强一致。</li>
<li>可用性：分布式服务能一直保证可用状态。当用户发出一个请求后，服务能在有限时间内返回结果。</li>
<li>分区容忍性：特指对网络分区的容忍性。</li>
</ul></li>
</ul></li>
</ul>

<p>举例：Cassandra、Dynamo 等，默认优先选择AP，弱化C；HBase、MongoDB 等，默认优先选择CP，弱化A。</p>

<ul>
<li><p>BASE 理论</p>
<ul>
<li><p>核心思想：</p>
<ul>
<li>基本可用（Basically Available）：指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。</li>
<li>软状态（Soft State）：指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。</li>
<li>最终一致性（Eventual Consistency）：指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态。</li>
</ul></li>
<li><p>一致性模型</p>
<ul>
<li><p>数据的一致性模型可以分成以下 3 类：</p>
<ul>
<li>强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。</li>
<li>弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。</li>
<li>最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>分布式系统数据的强一致性、弱一致性和最终一致性可以通过Quorum NRW算法分析。</p>

<h2 id="toc_2">分布式事务解决方案</h2>

<h3 id="toc_3">2PC方案——强一致性</h3>

<p>2PC的核心原理是通过提交分阶段和记日志的方式，记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个状态节点重试，如Coordinator重启后，通过日志可以确定提交处于Prepare还是PrepareAll状态，若是前者，说明有节点可能没有Prepare成功，或所有节点Prepare成功但还没有下发Commit，状态恢复后给所有节点下发RollBack；若是PrepareAll状态，需要给所有节点下发Commit，数据库节点需要保证Commit幂等。</p>

<ul>
<li><p>2PC方案的问题：</p>
<ul>
<li>同步阻塞；</li>
<li>数据不一致；</li>
<li>单点问题。</li>
</ul></li>
<li><p>升级的3PC方案旨在解决这些问题，主要有两个改进：</p>
<ul>
<li>增加超时机制。</li>
<li>两阶段之间插入准备阶段。</li>
</ul></li>
</ul>

<p>但三阶段提交也存在一些缺陷，要彻底从协议层面避免数据不一致，可以采用Paxos或者Raft 算法。</p>

<h3 id="toc_4">eBay 事件队列方案——最终一致性</h3>

<p>eBay 的架构师Dan Pritchett，曾在一篇解释BASE 原理的论文《Base：An Acid Alternative》中提到一个eBay 分布式系统一致性问题的解决方案。它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。</p>

<p>描述的场景为，有用户表user 和交易表transaction，用户表存储用户信息、总销售额和总购买额，交易表存储每一笔交易的流水号、买家信息、卖家信息和交易金额。如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。</p>

<p>论文中提出的解决方法是将更新交易表记录和用户表更新消息放在一个本地事务来完成，为了避免重复消费用户表更新消息带来的问题，增加一个操作记录表updates_applied来记录已经完成的交易相关的信息。</p>

<p>这个方案的核心在于第二阶段的重试和幂等执行。失败后重试，这是一种补偿机制，它是能保证系统最终一致的关键流程。</p>

<h3 id="toc_5">TCC （Try-Confirm-Cancel）补偿模式——最终一致性</h3>

<p>某业务模型如图，由服务 A、服务B、服务C、服务D 共同组成的一个微服务架构系统。服务A 需要依次调用服务B、服务C 和服务D 共同完成一个操作。当服务A 调用服务D 失败时，若要保证整个系统数据的一致性，就要对服务B 和服务C 的invoke 操作进行回滚，执行反向的revert 操作。回滚成功后，整个微服务系统是数据一致的。</p>

<ul>
<li><p>实现关键要素：</p>
<ol>
<li>服务调用链必须被记录下来；</li>
<li>每个服务提供者都需要提供一组业务逻辑相反的操作，互为补偿，同时回滚操作要保证幂等；</li>
<li>必须按失败原因执行不同的回滚策略。</li>
</ol></li>
<li><p>实现难点：</p></li>
</ul>

<p>补偿模式的特点是实现简单，但是想形成一定程度的通用方案比较困难，特别是服务链的记录，因为大部分时候，业务参数或者业务逻辑千差万别。</p>

<p>另外，很多业务特征使得该服务无法提供一个安全的回滚操作。</p>

<h3 id="toc_6">缓存数据最终一致性</h3>

<p>在我们的业务系统中，缓存（Redis 或者Memcached）通常被用在数据库前面，作为数据读取的缓冲，使得I/O 操作不至于直接落在数据库上。以商品详情页为例，假如卖家修改了商品信息，并写回到数据库，但是这时候用户从商品详情页看到的信息还是从缓存中拿到的过时数据，这就出现了缓存系统和数据库系统中的数据不一致的现象。</p>

<ul>
<li>要解决该场景下缓存和数据库数据不一致的问题我们有以下两种解决方案：</li>
</ul>

<p>为缓存数据设置过期时间。当缓存中数据过期后，业务系统会从数据库中获取数据，并将新值放入缓存。这个过期时间就是系统可以达到最终一致的容忍时间。</p>

<p>更新数据库数据后同时清除缓存数据。数据库数据更新后，同步删除缓存中数据，使得下次对商品详情的获取直接从数据库中获取，并同步到缓存。</p>

<blockquote>
<p>选择建议</p>
</blockquote>

<p>在面临数据一致性问题的时候，首先要从业务需求的角度出发，确定我们对于3 种一致性模型的接受程度，再通过具体场景来决定解决方案。</p>

<p>从应用角度看，分布式事务的现实场景常常无法规避，在有能力给出其他解决方案前，2PC也是一个不错的选择。</p>

<p>对购物转账等电商和金融业务，中间件层的2PC最大问题在于业务不可见，一旦出现不可抗力或意想不到的一致性破坏，如数据节点永久性宕机，业务难以根据2PC的日志进行补偿。金融场景下，数据一致性是命根，业务需要对数据有百分之百的掌控力，建议使用TCC这类分布式事务模型，或基于消息队列的柔性事务框架，这两种方案都在业务层实现，业务开发者具有足够掌控力，可以结合SOA框架来架构，包括Dubbo、Spring Cloud等。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式系统常见的事务处理机制]]></title>
    <link href="https://books.sangkf.cn/15511041776834.html"/>
    <updated>2019-02-25T22:16:17+08:00</updated>
    <id>https://books.sangkf.cn/15511041776834.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>为保障系统的可用性、可靠性以及性能，在分布式系统中，往往会设置数据冗余，即对数据进行复制。举例来说，当一个数据库的副本被破环以后，那么系统只需要转换到其他数据副本就能继续运行下去。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">引述</h2>

<p>为保障系统的可用性、可靠性以及性能，在分布式系统中，往往会设置数据冗余，即对数据进行复制。举例来说，当一个数据库的副本被破环以后，那么系统只需要转换到其他数据副本就能继续运行下去。<br/>
另外一个例子，当访问单一服务器管理的数据的进程数不断增加时，系统就需要对服务器的数量进行扩充，此时，对服务器进行复制，随后让它们分担工作负荷，就可以提高性能。但同时，如何保障多个数据节点之间数据的一致以及如何处理分布式事务，将成为为一个复杂的话题。本文将介绍常用的事务处理机制。</p>

<h2 id="toc_1">CAP 定理</h2>

<p>CAP 定理（也称为 Brewer 定理），是由计算机科学家 Eric Brewer 提出的，即在分布式计算机系统不可能同时提供以下全部三个保证：</p>

<ul>
<li><p><strong>一致性</strong>（Consistency）：所有节点同一时间看到是相同的数据；</p></li>
<li><p><strong>可用性</strong>（Availability）：不管是否成功，确保每一个请求都能接收到响应；</p></li>
<li><p><strong>分区容错性</strong>（Partition tolerance）：系统任意分区后，在网络故障时，仍能操作</p></li>
</ul>

<p>显然，为了保障性能和可靠性，我们将数据复制多份，分布到多个节点上，同时也带来了一个难点，那就是如何保持各个副本数据的一致性。换句话说，我们选择了 AP ，则必须要牺牲掉 C 了。</p>

<p>但是，在实际的应用场景中，数据的一致性往往也是需要保证的。那么这是否违背了 CAP 定理呢？</p>

<h2 id="toc_2">一致性模型</h2>

<p>其实，数据的一致性也分几种情况，大致可以分为：</p>

<ul>
<li><p>Weak 弱一致性：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些存储系统，搜索引擎，实时游戏，语音聊天等，这些数据本文对完整性要求不高，数据是否一致关系也不大。</p></li>
<li><p>Eventually 最终一致性：当你写入一个新值后，并不一定能马上读出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件，消息中间件等系统，大部分分布式系统技术都采用这类模式。</p></li>
<li><p>Strong 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS都是强一致性的。</p></li>
</ul>

<p>也就是说，在设计分布式系统时，我们并不一定要求是强一致性的，根据应用场景可以选择弱一致性或者是最终一致性。</p>

<h2 id="toc_3">事务的作用</h2>

<p>事务有如下作用：</p>

<ul>
<li><p>保证执行结果的正确性</p></li>
<li><p>保证数据的一致性</p></li>
<li><p>ACID</p></li>
</ul>

<h2 id="toc_4">常见的事务处理机制</h2>

<h3 id="toc_5">Master-Slave 复制</h3>

<p>Slave 一般是 Master 的备份。在这样的系统中，一般是如下设计的：</p>

<ul>
<li><p>读写请求都由 Master 负责。</p></li>
<li><p>写请求写到 Master 上后，由 Master 同步到 Slave 上。</p></li>
</ul>

<p>这种机制的特点是：</p>

<ul>
<li><p>数据同步通常是异步的</p></li>
<li><p>有良好的吞吐量，低延迟 *　在大多数　RDBMS　中支持，比如　MySQL二进制日志</p></li>
<li><p>弱/最终一致性</p></li>
</ul>

<p>这种机制的缺点是，如果 Master 挂了，Slave 只能提供读服务，而没有写服务。</p>

<h3 id="toc_6">Master-Master 多主复制</h3>

<p>指一个系统存在两个或多个Master，每个Master都提供读写服务。这个机制是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。 Master-Master的好处是，一台Master挂了，别的Master可以正常做读写服务，他和Master-Slave一样，当数据没有被复制到别的Master上时，数据会丢失。很多数据库都支持Master-Master的Replication的机制。</p>

<p>这种机制的特点是：</p>

<ul>
<li><p>异步</p></li>
<li><p>最终的一致性</p></li>
<li><p>多个节点间需要序列化协议</p></li>
</ul>

<h3 id="toc_7">两阶段提交</h3>

<p>两阶段提交协议 （Two-phase commit protocol，2PC）的过程涉及到协调者和参与者。协调者可以看做成事务的发起者，同时也是事务的一个参与者。对于一个分布式事务来说，一个事务是涉及到多个参与者的。具体的两阶段提交的过程如下：</p>

<h4 id="toc_8">第一阶段（准备阶段）</h4>

<ul>
<li><p>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p></li>
<li><p>参与者节点执行询问发起为止的所有事务操作，并将 Undo 信息和 Redo 信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p></li>
<li><p>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个“同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个“中止”消息。</p></li>
</ul>

<h4 id="toc_9">第二阶段（提交阶段）</h4>

<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p>

<ul>
<li><p>当协调者节点从所有参与者节点获得的相应消息都为“同意”时:</p></li>
<li><p>协调者节点向所有参与者节点发出“正式提交(commit)”的请求。</p></li>
<li><p>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</p></li>
<li><p>参与者节点向协调者节点发送“完成”消息。</p></li>
<li><p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p></li>
<li><p>协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</p></li>
<li><p>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p></li>
<li><p>参与者节点向协调者节点发送”回滚完成”消息。</p></li>
<li><p>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p></li>
<li><p>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务</p></li>
</ul>

<p>不管最后结果如何，第二阶段都会结束当前事务。</p>

<p>二段式提交协议的优缺点：</p>

<p>优点：原理简单，实现方便；</p>

<p>缺点：</p>

<ul>
<li><p>同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。</p></li>
<li><p>单点故障。由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。</p></li>
<li><p>数据不一致。在阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到 commit 请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p></li>
<li><p>二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p></li>
</ul>

<p>为了解决两阶段提交协议的种种问题，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p>

<h4 id="toc_10">三阶段提交</h4>

<p>三阶段提交协议（Three-phase commit protocol，3PC），是二阶段提交（2PC）的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点：</p>

<ul>
<li><p>引入超时机制。同时在协调者和参与者中都引入超时机制。</p></li>
<li><p>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</p></li>
</ul>

<p>即 3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。</p>

<h4 id="toc_11">CanCommit 阶段</h4>

<p>CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p>

<ul>
<li><p>事务询问：协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p></li>
<li><p>响应反馈：参与者接到 CanCommit 请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No</p></li>
</ul>

<h4 id="toc_12">PreCommit 阶段</h4>

<p>协调者根据参与者的反应情况来决定是否可以记性事务的 PreCommit 操作。根据响应情况，有以下两种可能。</p>

<ul>
<li><p>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。</p></li>
<li><p>发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入Prepared 阶段。</p></li>
<li><p>事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将undo 和 redo 信息记录到事务日志中。</p></li>
<li><p>响应反馈：如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。</p></li>
<li><p>假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p></li>
<li><p>发送中断请求：协调者向所有参与者发送 abort 请求。</p></li>
<li><p>中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p></li>
</ul>

<h4 id="toc_13">doCommit 阶段</h4>

<p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>

<ul>
<li><p>执行提交</p></li>
<li><p>发送提交请求：协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。</p></li>
<li><p>事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p></li>
<li><p>响应反馈：事务提交完之后，向协调者发送 ACK 响应。</p></li>
<li><p>完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。</p></li>
<li><p>中断事务：协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。</p></li>
<li><p>发送中断请求：协调者向所有参与者发送 abort 请求</p></li>
<li><p>事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p></li>
<li><p>反馈结果：参与者完成事务回滚之后，向协调者发送 ACK 消息</p></li>
<li><p>中断事务：协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。</p></li>
</ul>

<p>在 doCommit 阶段，如果参与者无法及时接收到来自协调者的 doCommit 或者 rebort 请求时，会在等待超时之后，会继续进行事务的提交。即当进入第三阶段时，由于网络超时等原因，虽然参与者没有收 到 commit 或者 abort 响应，事务仍然会提交。</p>

<p>三阶段提交不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作，这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。</p>

<h3 id="toc_14">Paxos 算法</h3>

<p>Paxos 算法是 Leslie Lamport 于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法。Paxos 算法目前在 Google 的 Chubby、MegaStore、Spanner 等系统中得到了应用，Hadoop 中的 ZooKeeper 也使用了 Paxos 算法。</p>

<p>在 Paxos 算法中，分为4种角色：</p>

<ul>
<li><p>Proposer ：提议者</p></li>
<li><p>Acceptor：决策者</p></li>
<li><p>Client：产生议题者</p></li>
<li><p>Learner：最终决策学习者</p></li>
</ul>

<p>算法可以分为两个阶段来执行：</p>

<h4 id="toc_15">阶段1</h4>

<ul>
<li><p>Proposer 选择一个议案编号 n，向 acceptor 的多数派发送编号也为 n 的 prepare 请求。</p></li>
<li><p>Acceptor：如果接收到的 prepare 请求的编号 n 大于它已经回应的任何prepare 请求，它就回应已经批准的编号最高的议案（如果有的话），并承诺不再回应任何编号小于 n 的议案；</p></li>
</ul>

<h4 id="toc_16">阶段2</h4>

<ul>
<li><p>Proposer：如果收到了多数 acceptor 对 prepare 请求（编号为 n）的回应，它就向这些 acceptor 发送议案{n, v}的 accept 请求，其中 v 是所有回应中编号最高的议案的决议，或者是 proposer 选择的值，如果回应说还没有议案。</p></li>
<li><p>Acceptor：如果收到了议案{n, v}的 accept 请求，它就批准该议案，除非它已经回应了一个编号大于 n 的议案。</p></li>
<li><p>Proposer 可以提出多个议案，只要它遵循上面的算法。它可以在任何时刻放弃一个议案。（这不会破坏正确性，即使在议案被放弃后，议案的请求或者回应消息才到达目标）如果其它的 proposer 已经开始提出更高编号的议案，那么最好能放弃当前的议案。因此，如果 acceptor 忽略一个 prepare 或者 accept 请求（因为已经收到了更高编号的 prepare 请求），它应该告知 proposer 放弃议案。这是一个性能优化，而不影响正确性。</p></li>
</ul>

<h2 id="toc_17">参考文献</h2>

<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf">http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf</a></li>
<li><a href="https://www.oschina.net/question/2720166_2235329">https://www.oschina.net/question/2720166_2235329</a></li>
<li><a href="https://github.com/waylau/distributed-systems-technologies-and-cases-analysis">《分布式系统常用技术及案例分析》</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[😋 技术必备基础知识]]></title>
    <link href="https://books.sangkf.cn/15511034481464.html"/>
    <updated>2019-02-25T22:04:08+08:00</updated>
    <id>https://books.sangkf.cn/15511034481464.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本项目包含了技术面试必备的基础知识，浅显易懂，你不需要花很长的时间去阅读和理解成堆的技术书籍就可以快速掌握这些知识，从而节省宝贵的面试复习时间。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>本项目包含了技术面试必备的基础知识，浅显易懂，你不需要花很长的时间去阅读和理解成堆的技术书籍就可以快速掌握这些知识，从而节省宝贵的面试复习时间。你也可以阅读 <a href="https://github.com/CyC2018/Backend-Interview-Guide">面试进阶指南</a>，包含了学习指导和面试技巧，让你更轻松拿到满意的 Offer。</p>

<h2 id="toc_0">✏️ 算法</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md">剑指 Offer 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode%20%E9%A2%98%E8%A7%A3.md">Leetcode 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%AE%97%E6%B3%95.md">算法</a></li>
</ul>

<h2 id="toc_1">💻 操作系统</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md">计算机操作系统</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Linux.md">Linux</a></li>
</ul>

<h2 id="toc_2">☁️ 网络</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md">计算机网络</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md">HTTP</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Socket.md">Socket</a></li>
</ul>

<h2 id="toc_3">🎨 面向对象</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md">设计模式</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md">面向对象思想</a></li>
</ul>

<h2 id="toc_4">💾 数据库</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">数据库系统原理</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md">SQL</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md">Leetcode-Database 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md">MySQL</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md">Redis</a></li>
</ul>

<h2 id="toc_5">☕️ Java</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md">Java 基础</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md">Java 容器</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md">Java 并发</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md">Java 虚拟机</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md">Java I/O</a></li>
</ul>

<h2 id="toc_6">💡 系统设计</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md">系统设计基础</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md">分布式</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9B%86%E7%BE%A4.md">集群</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md">攻击技术</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md">缓存</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md">消息队列</a></li>
</ul>

<h2 id="toc_7">🔧 工具</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Git.md">Git</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Docker.md">Docker</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md">构建工具</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md">正则表达式</a></li>
</ul>

<h2 id="toc_8">🍉 编码实践</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.md">代码可读性</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.md">代码风格规范</a></li>
</ul>

<blockquote>
<p>原文地址 <a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式事务]]></title>
    <link href="https://books.sangkf.cn/15510945917129.html"/>
    <updated>2019-02-25T19:36:31+08:00</updated>
    <id>https://books.sangkf.cn/15510945917129.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>解决分布式事务的最好办法其实就是不考虑分布式事务，将一个大的业务进行拆分，整个大的业务流程，转化成若干个小的业务流程，然后通过设计补偿流程从而考虑最终一致性。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">概述</h2>

<p>分布式事务场景如何设计系统架构及解决数据一致性问题，个人理解最终方案把握以下原则就可以了，那就是：大事务=小事务（原子事务）+异步（消息通知），<br/>
<strong>解决分布式事务的最好办法其实就是不考虑分布式事务，将一个大的业务进行拆分，整个大的业务流程，转化成若干个小的业务流程，然后通过设计补偿流程从而考虑最终一致性。</strong></p>

<h4 id="toc_1">What’s 事务</h4>

<p>事务（Transaction）及其ACID属性</p>

<p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性：</p>

<ul>
<li>原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li>隔离性（Isoation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li>持久性（Durabe）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>

<h4 id="toc_2">典型场景：银行转账业务</h4>

<p>例如：李雷账户中有500块钱，韩梅梅账户有200块钱，李雷要从自己的账户中转100块钱给韩梅梅，转账（事务）成功执行完成后应该是李雷账户减100变为400，韩梅梅账户加100变为300，不能出现其他情况，即在事务开始和结束时数据都必须保持一致状态（一致性），事务结束时所有的数据及结构都必须是正确的。并且同样的转账操作（同一流水，即一次转账操作）无论执行多少次结果都相同（幂等性）。</p>

<h4 id="toc_3">电商场景：流量充值业务</h4>

<p>再说我们做的一个项目：中国移动-流量充值能力中心，核心业务流程为：</p>

<pre><code class="language-text">  1. 用户进入流量充值商品购买页面，选择流量商品；
  2. 购买流量充值商品，有库存限制则判断库存，生成流量购买订单；
  3. 选择对应的支付方式（和包、银联、支付宝、微信）进行支付操作；
  4. 支付成功后，近实时流量到账即可使用流量商品；

</code></pre>

<p>此业务流程看似不是很复杂对吧，不涉及到类似电商业务的实物购买，但是我认为其中的区别并不是很大，只是缺少电商中的物流发货流程，其他流程几乎是一样的，也有库存以及优惠折扣等业务存在。</p>

<p>整个系统交互如下图：</p>

<p><img src="media/15510945917129/15510949905392.png" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<h4 id="toc_4">分布式事务</h4>

<p>上述两个场景的业务需求已经说完了，接着谈谈分布式事务，要说分布式事务那就先聊聊本地事务与分布式事务：</p>

<p>Ps：相同点：首先都是要保证数据正确（即ACID），本地事务与分布式事务还可以对应为：刚性事务与柔性事务，在我个人理解刚性事务与柔性事务的最大区别就是：一个完整的事务操作是否可以在同一物理介质（例如：内存）上同时完成；柔性事务就是一个完整事务需要跨物理介质或跨物理节点（网络通讯），那么排它锁、共享锁等等就没有用武之地了（这里并不是指大事务拆小事务【本地事务】后），无法保证原子性（Atomicity）完成事务。个人理解分布式（柔性）事务本质意义上就是-伪事务，柔性事务其实就是根据不同的业务场景使用不同的方法实现最终一致性，因为可以根据业务的特性做部分取舍，在业务过程中可以容忍一定时间内的数据不一致。</p>

<p>在知乎上面看过一篇文章，支付宝的柔性事务实现方式有四种分别针对不同的业务场景，如下图：</p>

<p><img src="media/15510945917129/2.png" alt="image" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<ol>
<li>两阶段型</li>
<li>补偿型</li>
<li>异步确保型</li>
<li>最大努力通知型</li>
</ol>

<p>回到我们流量交易中心的业务场景：</p>

<p>通过Dubbo实现了微服务化，大致拆分如下：</p>

<ol>
<li>商品服务</li>
<li>订单服务</li>
<li>库存服务</li>
<li>支付服务</li>
<li>直充服务</li>
<li>消息服务</li>
<li>等其他服务</li>
</ol>

<h4 id="toc_5">场景一：</h4>

<p>库存数量与订单数量一致性，采用补偿型+最大努力通知型，采用原因为不涉及跨机房和长事务（正常情况下库存与订单服务处理很快）：</p>

<ol>
<li>用户下单先减库存，库存减成功后；</li>
<li>调用下单服务：</li>
<li>2-1. 下单成功，两事务均提交完成；</li>
<li>2-2. 下单失败，库存回滚，两事务均失败，此处还有一个保障机制（最大努力通知型），就是如果调用库存服务异常，确定库存回滚失败了，则放入消息服务（延时消息队列）分阶段定时重试，努力重试保证库存服务正常后成功回滚。</li>
</ol>

<h4 id="toc_6">场景二：</h4>

<p>订单信息、支付信息、充值信息三者之间的一致性，采用异步确保型的原因是，整个业务链路太长且跨不同的机房系统，网络延迟较高，业务方面恰好不需要非常高的实时性，所以采用小事务+异步通知，目前正常情况下用户从下单到完成支付到流量到账平均为1-5分钟左右：</p>

<ol>
<li>下单成功即订单服务创建订单成功并发送支付请求到支付网关系统（订单状态-待支付，超过1小时未支付则流转为超时未付撤销，此处用到了RocketMQ的延时消费恰好实现定时器业务场景）。</li>
<li>返回支付页面，用户在支付交易系统完成支付业务流程，支付网关异步通知流量中心，流量中心接收到支付成功状态后修改订单状态-支付成功，并给支付网关返回成功结果（此处并发压力目前不大，暂时没有再进行异步解耦）。</li>
<li>流量中心修改完订单状态后，调用消息服务将直充业务放入消息队列，对直充业务进行解耦（原因是直充需要调用31省移动CRM系统，此链路过长，且部分省CRM系统耗时非常大，每个省的处理能力不同，经常出现20秒以上的超时，因此要考虑部分超时较高的省份拖垮系统，进行业务的削峰填谷）；</li>
<li>3-1. 当直充成功时，修改订单状态-已完成；</li>
<li>3-2. 当直充失败时（移动特性，例如：直充时正好用户销户或者停机了），修改订单状态为待退款，并调用支付网关系统的退款接口，退款成功后支付网关异步通知流量中心，流量中心修改订单状态为-退款成功；</li>
<li>3-3. 当直充超时时，调用定时任务服务进行超时重试机制（第一次重试在10分钟后执行、第二次在30分钟后、第三次…..），直到最大超时重试次数后还得不到直充结果，订单状态会卡在支付成功状态，依赖T+1对账稽核流程保证最终一致性，订单状态根据对账结果流转为：已完成或待退款–&gt;退款成功。</li>
</ol>

<h4 id="toc_7">场景三：</h4>

<p>直充到账后的消息通知（APP消息推送或短信通知），采用最大努力通知型，这个业务场景比较简单，在直充成功后，订单状态流转为已完成，此时通过消息服务进行到账通知业务的解耦，调用消息服务失败的情况下，使用定时任务努力通知。</p>

<h4 id="toc_8">场景四：</h4>

<p><strong>对账稽核：</strong></p>

<p>按照支付账期每日进行T+1对账，对账原则：以支付交易记录为准，对流量中心订单记录+支付网关交易记录+省CRM充值记录三方比对，将某些中间状态的订单（例如：支付成功、待退款）核对后将订单状态流转完结（已完成、退款成功）。</p>

<p><strong>结算稽核：</strong></p>

<p>对账成功后的数据定期进入结算流程，对支付网关周期内的支付金额与结算数据的金额进行核对，稽核成功后进行财务结算流程，将钱结算给省公司，并提供结算明细给省公司，供省公司与直充成本记录进行复核。 Ps：以下是流量中心的部分架构设计，总体原则方向：微服务化</p>

<p><strong>流量中心-架构设计</strong></p>

<p><img src="media/15510945917129/3.png" alt="image" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>架构设计思想：在系统初期设计时以及部分硬性环境约束下，我们根据业务拆分为多个子系统（微服务）：商品服务、订单服务、库存服务、支付网关、统一接口平台、对账服务、结算服务、网关对接服务等，后续还会增加：账户服务、虚拟货币服务、卡券服务等等…。按照微服务的核心设计思想，所有服务完全独立、隔离，因此所有服务从上至下：请求接入（连接管理）、请求处理（计算服务）、数据存储（存储服务）进行拆分，接入与计算尽最大可能实现无状态，数据存储进行垂直+水平拆分，垂直拆分：商品库-mysql（读多写少，主从架构+读写分离）+redis（读多写少，集群方式）、订单库-mysql（读写均衡，多主多从+水平拆分）、库存专用库-redis（分布式+主备容灾）、外部交易系统-支付网关、外部办理系统-统一接口平台。</p>

<p>Ps：此架构目前已支撑总交易额3.6亿，总订单4680万，日均交易额500万，日订单量50万，后续业务量持续增加的情况下按照微服务思想继续拆分，例如将订单服务再拆分为：下单服务、查单服务，直到根据业务需求与系统关系耦合性拆分到最细粒度为止。</p>

<ol>
<li>性能扩展：应用层计算服务（无状态应用）通过增加服务节点同比提升运算性能，配套质量（性能）监控服务dubbo monitor及整合Netflix的Hystrix熔断器对业务质量进行管理实现应用层的动态扩缩容。</li>
<li>容量扩展：数据层存储服务（有状态应用）通过对数据水平拆分实现容量的无限扩容，Nosql类方案：Codis中间件；关系型数据库：Mycat数据库分库分表中间件。目前项目中采用twitter的snowflake唯一ID生成器（根据业务场景优化后）自己实现数据的水平拆分和路由规则。</li>
<li>存储性能：Nosql：针对读多写少场景-使用淘宝的Tedis（多写随机读的特性提高性能），读写均衡使用-Codis；Mysql：读多写少场景使用一主多从架构（例如商品信息），读写均衡场景使用多主多从架构（例如订单信息）。</li>
</ol>

<p><strong>整体拆分原则如下图：</strong></p>

<p><img src="media/15510945917129/4.png" alt="image" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事务]]></title>
    <link href="https://books.sangkf.cn/15510944838066.html"/>
    <updated>2019-02-25T19:34:43+08:00</updated>
    <id>https://books.sangkf.cn/15510944838066.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>原子性、一致性、隔离性、持久性是事务的四个基本特性。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">事务特性</h2>

<p>原子性、一致性、隔离性、持久性，这四个属性通常称为ACID特性。</p>

<ul>
<li>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
<li>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
<li>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ul>

<h2 id="toc_1">分布式事务</h2>

<ul>
<li><a href="15510945917129.html">分布式事务</a></li>
<li><a href="15511041776834.html">分布式系统常见的事务处理机制</a></li>
<li><a href="15511042581022.html">微服务架构下处理分布式事务的典型方案</a></li>
<li>解决分布式系统事务一致性的几种方案对比</li>
<li>多库多事务降低数据不一致概率</li>
<li>蚂蚁技术专家：一篇文章带你学习分布式事务</li>
</ul>

<h2 id="toc_2">开源框架</h2>

<ul>
<li>tcc-transaction是TCC型事务java实现</li>
<li>TCC分布式事务的实现原理</li>
<li>分布式事务 TCC-Transaction 源码分析 —— Dubbo 支持</li>
<li>分布式事务 TCC-Transaction 源码分析 —— 项目实战</li>
<li>GTS来了！阿里微服务架构下的分布式事务解决方案</li>
<li>Atomikos</li>
<li>微服务架构下分布式事务解决方案 —— 阿里GTS</li>
<li>ByteJTA是一个兼容JTA规范的基于XA/2PC的分布式事务管理器</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 生态圈知识汇总]]></title>
    <link href="https://books.sangkf.cn/15510844326202.html"/>
    <updated>2019-02-25T16:47:12+08:00</updated>
    <id>https://books.sangkf.cn/15510844326202.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>多读书、多看报，多研究常用开源框架的源码，比如：github.com，这里汇集了全球工程师的智慧！</p>
</blockquote>

<span id="more"></span><!-- more -->

<h3 id="toc_0">前言</h3>

<p>有人认为编程是一门技术活，要有一定的天赋，非天资聪慧者不能及也。其实不然，笔者虽是计算机专业出身，但工作年限并不长，对于技术这碗饭有一些心得体会，大多数人成为某领域顶级专家可能会有些难度，但应对日常工作，成长为资深研发工程师、技术专家、甚至成为小团队的Team Leader，其实并不难。</p>

<p><strong>多读书、多看报，多研究常用开源框架的源码，比如：github.com，这里汇集了全球工程师的智慧！</strong></p>

<p>言归正传，下文会列举工作中常用的一些技术，以及如何锻炼提升自己的架构能力。</p>

<p>由于每块技术市场上基本都有对应的网络资料或书籍，所以本文只是少篇幅列举工作中用到的核心知识点，抛砖引玉，属于进阶型，不适用初学者。</p>

<h3 id="toc_1"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"></a>基础知识</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fjava.md">java</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspring.md">spring</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspringboot.md">spring boot</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspringcloud.md">spring cloud</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fibatis.md">ibatis</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2F%25E5%25B8%25B8%25E7%2594%25A8%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F.md">设计模式</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2FLog4j.md">Log日志</a></li>
</ul>

<h3 id="toc_2"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E6%95%B0%E6%8D%AE%E5%BA%93"></a>数据库</h3>

<p>目前使用最多还是mysql，虽然单机性能比不上oracle，但免费开源，单机成本低且借助于分布式集群，可以有强大的输出能力。</p>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fdatabase-connection-pool.md">连接池</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Ftransaction.md">事务</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2F%25E5%2588%2586%25E5%25BA%2593%25E5%2588%2586%25E8%25A1%25A8.md">分库分表</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fid-generate.md">id生成器</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F6909240">读写分离</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fsql-optimize.md">SQL调优</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fother.md">其它</a></li>
</ul>

<h3 id="toc_3"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#web%E5%AE%B9%E5%99%A8%E5%8D%8F%E8%AE%AE%E7%BD%91%E7%BB%9C"></a>web容器/协议/网络</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fload-balance.md">负载均衡</a></li>
<li>服务器
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2FNginx.md">Nginx</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Ftomcat.md">Tomcat</a></li>
</ul></li>
<li>协议
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fhttp%25E5%258D%258F%25E8%25AE%25AE.md">HTTP 协议</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Ftcp.md">TCP 协议</a></li>
</ul></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2FCDN.md">CDN</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fother.md">其它</a></li>
</ul>

<h3 id="toc_4"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E5%8C%85"></a>常用三方工具包</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FGoole-Guava.md">Google Guava</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FfastJson.md">fastJson</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F17913607">log4J</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-codec.md">commons-codec</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-lang3.md">commons-lang3</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-io.md">commons-io</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FQuartz.md">Quartz</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FHttpClient.md">HttpClient</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F7671294">Javassist</a></li>
</ul>

<h3 id="toc_5"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E4%B8%AD%E9%97%B4%E4%BB%B6"></a>中间件</h3>

<ul>
<li><p>RPC框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fdubbo.md">dubbo</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fdubbox">dubbox</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fweibocom%2Fmotan">motan</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fapache%2Fthrift">Thrift</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Frpc-compare.md">RPC框架性能比较</a></li>
</ul></li>
<li><p>MQ消息</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fapache%2Factivemq">ActiveMQ</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FRabbitMQ.md">RabbitMQ</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fkafka.md">Kafka</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FRocketMQ.md">RocketMQ</a></li>
</ul></li>
<li><p>分布式缓存</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fredis.md">redis</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster">codis</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F8035197">memcache</a></li>
</ul></li>
<li><p>本地缓存</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fguava.md">Guava</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fehcache.md">ehcache</a></li>
</ul></li>
<li><p>搜索</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Felasticsearch.md">Elasticsearch</a></li>
</ul></li>
<li><p>分布式数据框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fcobar.md">cobar</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fmycat.md">Mycat</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Ftsharding.md">tsharding</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Ftb_tddl">tddl</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fsharding-jdbc.md">sharding-jdbc</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgitee.com%2Frobertleepeak%2Fdbsplit">dbsplit</a></li>
</ul></li>
<li><p>分布式协调服务</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fzookeeper.md">zookeeper</a></li>
</ul></li>
<li><p>配置管理</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fsuper-diamond%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590.md">super-diamond</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fdisconf">disconf</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fapollo.md">apollo</a></li>
</ul></li>
<li><p>分布式文件系统</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FFastDFS.md">FastDFS</a></li>
</ul></li>
<li><p>分布式任务调度框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Felasticjob%2Felastic-job">Elastic-Job</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Fdangdang-distributed-work-framework-elastic-job">详解当当网的分布式作业框架elastic-job</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Ftaosir_zhang%2Farticle%2Fdetails%2F50728362">TBSchedule</a></li>
</ul></li>
<li><p>大数据</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHbase.md">Hbase</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FSpark.md">Spark</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHadoop.md">Hadoop</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHive.md">Hive</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fbig-data.md">other框架</a></li>
</ul></li>
<li><p>其它</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fcanal">数据库binlog的增量订阅&amp;消费组件</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fotter">数据库同步系统</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FTCC-Transaction.md">TCC-Transaction</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FNetty.md">Netty</a></li>
</ul></li>
</ul>

<h3 id="toc_6"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"></a>系统架构</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Farchitecture-experience.md">架构经验</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Farchitecture-good-case.md">经典案例</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Ftechnology-selection.md">通用技术方案选型</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2F%25E7%25BC%2596%25E7%25A0%2581%25E5%2589%258D3000%25E9%2597%25AE.md">编码前3000问</a></li>
</ul>

<h3 id="toc_7"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"></a>项目管理</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2F%25E8%25AE%25BA%25E9%259C%2580%25E6%25B1%2582%25E8%25B0%2583%25E7%25A0%2594%25E7%259A%2584%25E9%2587%258D%25E8%25A6%2581%25E6%2580%25A7.md">论需求调研的重要性</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Fproject-management.md">项目管理</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Fcode.md">代码管理</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Ftest.md">测试相关</a></li>
</ul>

<h3 id="toc_8"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E8%BF%90%E7%BB%B4"></a>运维</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Fonline-question.md">快速排查线上问题</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Flinux-commands.md">linux常用命令</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2F%25E6%259C%25AC%25E5%259C%25B0%25E4%25BB%25A3%25E7%25A0%2581%25E8%25B0%2583%25E8%25AF%2595.md">本地代码调试</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Fdocker.md">Docker</a></li>
</ul>

<h3 id="toc_9"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF"></a>个人成长</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fstudy.md">学习网站</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fbook.md">Tom哥的读书单</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fperson.md">个人成长与职业规划</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fprogramer.md">程序员素养</a></li>
</ul>

<h3 id="toc_10"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%85%B6%E5%AE%83"></a>其它</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Ftool.md">常用软件工具</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2F%25E4%25B8%2580%25E8%2587%25B4%25E6%2580%25A7hash.md">一致性hash算法</a></li>
<li>面试
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fjava-interview.md">java面试题</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fbigdata-interview.md">大数据面试题</a></li>
</ul></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2F%25E5%259B%259E%25E8%25BD%25A6%25E4%25B8%258E%25E6%258D%25A2%25E8%25A1%258C%25E7%259A%2584%25E5%258C%25BA%25E5%2588%25AB.md">回车与换行的区别</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fqq1332479771%2Farticle%2Fdetails%2F56087333">github上fork项目后，如何同步更新后面提交</a></li>
</ul>

<p>[<strong>原文地址</strong>]：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk">github.com/aalansehaiy…</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[限流设计]]></title>
    <link href="https://books.sangkf.cn/15510821177382.html"/>
    <updated>2019-02-25T16:08:37+08:00</updated>
    <id>https://books.sangkf.cn/15510821177382.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>限流，书面意思和作用一致，就是为了限制，通过对并发访问或者请求进行限速或者一个时间窗口内的请求进行限速来保护系统。一旦达到了限制的临界点，可以用拒绝服务、排队、或者等待的方式来保护现有系统，不至于发生雪崩现象。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>限流就像做帝都的地铁一般，如果你住在西二旗或者天通苑也许会体会的更深刻一些。我更习惯在技术角度用消费者的角度来阐述，需要限流的一般原因是消费者能力有限，目的为了避免超过消费者能力而出现系统故障。当然也有其他类似的情况也可以用限流来解决。</p>

<p>限流的表现形式上大部分可以分为两大类：</p>

<ul>
<li>限制消费者数量。也可以说消费的最大能力值。比如：数据库的连接池是侧重的是总的连接数，本质上也是限制了消费者的最大消费能力。</li>
<li>可以被消费的请求数量。这里的数量可以是瞬时并发数，也可以是一段时间内的总并发数。</li>
</ul>

<p>除此之外，限流还有别的表现形式，例如按照网络流量来限流，按照cpu使用率来限流等。按照限流的范围又可以分为分布式限流，应用限流，接口限流等。无论怎么变化，限流都可以用以下图来表示：</p>

<p><img src="media/15510821177382/15510824198802.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_0">常用技术实现</h2>

<ul>
<li>令牌桶算法<br/>
令牌桶是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌，填满了就丢弃令牌，请求是否被处理要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求。令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌。令牌桶中装的是令牌。
<img src="media/15510821177382/15510825111049.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></li>
<li><p>漏桶算法<br/>
漏桶一个固定容量的漏桶，按照固定常量速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝。漏桶可以看做是一个具有固定容量、固定流出速率的队列，漏桶限制的是请求的流出速率。漏桶中装的是请求。</p></li>
<li><p>计数器<br/>
 有时我们还会使用计数器来进行限流，主要用来限制一定时间内的总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流，是一种简单粗暴的总数量限流，而不是平均速率限流。</p></li>
</ul>

<h2 id="toc_1">不用算法的解决方案</h2>

<p>我们可以用一个按照时间段限制请求总数的方式来限流。 总体思路是这样：</p>

<ul>
<li>用一个环形来代表通过的请求容器。</li>
<li>用一个指针指向当前请求所到的位置索引，来判断当前请求时间和当前位置上次请求的时间差，依此来判断是否被限制。</li>
<li>如果请求通过，则当前指针向前移动一个位置，不通过则不移动位置</li>
<li>重复以上步骤 直到永远.......</li>
</ul>

<p><img src="media/15510821177382/15510827864849.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_2">核心代码</h2>

<blockquote>
<p>以下代码的核心思路是这样的：指针当前位置的时间元素和当前时间的差来决定是否允许此次请求，这样通过的请求在时间上表现的比较平滑。</p>
</blockquote>

<pre><code class="language-java">//限流组件,采用数组做为一个环
    class LimitService
    {
        //当前指针的位置
        int currentIndex = 0;
        //限制的时间的秒数，即：x秒允许多少请求
        int limitTimeSencond = 1;
        //请求环的容器数组
        DateTime?[] requestRing = null;
        //容器改变或者移动指针时候的锁
        object objLock = new object();

        public LimitService(int countPerSecond,int  _limitTimeSencond)
        {
            requestRing = new DateTime?[countPerSecond];
            limitTimeSencond= _limitTimeSencond;
        }

        //程序是否可以继续
        public bool IsContinue()
        {
            lock (objLock)
            {
                var currentNode = requestRing[currentIndex];
                //如果当前节点的值加上设置的秒 超过当前时间，说明超过限制
                if (currentNode != null&amp;&amp; currentNode.Value.AddSeconds(limitTimeSencond) &gt;DateTime.Now)
                {
                    return false;
                }
                //当前节点设置为当前时间
                requestRing[currentIndex] = DateTime.Now;
                //指针移动一个位置
                MoveNextIndex(ref currentIndex);
            }            
            return true;
        }
        //改变每秒可以通过的请求数
        public bool ChangeCountPerSecond(int countPerSecond)
        {
            lock (objLock)
            {
                requestRing = new DateTime?[countPerSecond];
                currentIndex = 0;
            }
            return true;
        }

        //指针往前移动一个位置
        private void MoveNextIndex(ref int currentIndex)
        {
            if (currentIndex != requestRing.Length - 1)
            {
                currentIndex = currentIndex + 1;
            }
            else
            {
                currentIndex = 0;
            }
        }
    }
</code></pre>

<p>测试程序如下：</p>

<pre><code class="language-java">static  LimitService l = new LimitService(1000, 1);
        static void Main(string[] args)
        {
            int threadCount = 50;
            while (threadCount &gt;= 0)
            {
                Thread t = new Thread(s =&gt;
                {
                    Limit();
                });
                t.Start();
                threadCount--;
            }           

            Console.Read();
        }

        static void Limit()
        {
            int i = 0;
            int okCount = 0;
            int noCount = 0;
            Stopwatch w = new Stopwatch();
            w.Start();
            while (i &lt; 1000000)
            {
                var ret = l.IsContinue();
                if (ret)
                {
                    okCount++;
                }
                else
                {
                    noCount++;
                }
                i++;
            }
            w.Stop();
            Console.WriteLine($&quot;共用{w.ElapsedMilliseconds},允许：{okCount},  拦截：{noCount}&quot;);
        }
</code></pre>

<p>测试结果如下：</p>

<p><img src="media/15510821177382/15510829240788.jpg" alt=""/><br/>
<img src="media/15510821177382/15510829535558.jpg" alt=""/><br/>
最大用时15秒,共处理请求1000000*50=50000000 次</p>

<p>并未发生GC操作，内存使用率非常低，每秒处理 300万次+请求 。以上程序修改为10个线程，大约用时4秒之内<br/>
<img src="media/15510821177382/15510829711440.jpg" alt=""/></p>

<p>如果是强劲的服务器或者线程数较少情况下处理速度将会更快</p>

<p>[<strong>转载</strong>]<a href="https://www.cnblogs.com/zhanlang/p/10424757.html">https://www.cnblogs.com/zhanlang/p/10424757.html</a></p>

]]></content>
  </entry>
  
</feed>
