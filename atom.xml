<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[见课就上的小婊砸]]></title>
  <link href="https://books.sangkf.cn/atom.xml" rel="self"/>
  <link href="https://books.sangkf.cn/"/>
  <updated>2019-02-26T10:28:23+08:00</updated>
  <id>https://books.sangkf.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Java基础知识整理]]></title>
    <link href="https://books.sangkf.cn/15511460518747.html"/>
    <updated>2019-02-26T09:54:11+08:00</updated>
    <id>https://books.sangkf.cn/15511460518747.html</id>
    <content type="html"><![CDATA[
<ul>
<li>不积跬步无以至千里，不积小流无以成江海</li>
<li>千里之行，始于足下</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_0">数据类型</h2>

<ul>
<li><p><strong>基本类型</strong></p>
<ul>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
<li>boolean/~</li>
</ul>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 并不支持 boolean 数组，而是使用 byte 数组来表示 int 数组来表示。</p></li>
<li><p><strong>包装类型</strong></p>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<pre><code class="language-java">Integer x = 2;     // 装箱
int y = x;         // 拆箱
</code></pre></li>
<li><p><strong>缓存池</strong></p>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<pre><code class="language-java">Integer x = new Integer(123);
Integer y = new Integer(123);<br/>
System.out.println(x == y);    // false<br/>
Integer z = Integer.valueOf(123);<br/>
Integer k = Integer.valueOf(123);<br/>
System.out.println(z == k);   // true
</code></pre>
<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<pre><code class="language-java">public static Integer valueOf(int i) {
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br/>
        return IntegerCache.cache[i + (-IntegerCache.low)];<br/>
    return new Integer(i);<br/>
}
</code></pre>
<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<pre><code class="language-java">static final int low = -128;
static final int high;<br/>
static final Integer cache[];<br/>
static {<br/>
    // high value may be configured by property<br/>
    int h = 127;<br/>
    String integerCacheHighPropValue =<br/>
        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);<br/>
    if (integerCacheHighPropValue != null) {<br/>
        try {<br/>
            int i = parseInt(integerCacheHighPropValue);<br/>
            i = Math.max(i, 127);<br/>
            // Maximum array size is Integer.MAX_VALUE<br/>
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);<br/>
        } catch( NumberFormatException nfe) {<br/>
            // If the property cannot be parsed into an int, ignore it.<br/>
        }<br/>
    }<br/>
    high = h;<br/>
    cache = new Integer[(high - low) + 1];<br/>
    int j = low;<br/>
    for(int k = 0; k &lt; cache.length; k++)<br/>
        cache[k] = new Integer(j++);<br/>
    // range [-128, 127] must be interned (JLS7 5.1.7)<br/>
    assert IntegerCache.high &gt;= 127;<br/>
}
</code></pre>
<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p>
<pre><code class="language-java">Integer m = 123;
Integer n = 123;<br/>
System.out.println(m == n); // true
</code></pre>
<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p></li>
</ul>

<h2 id="toc_1">String</h2>

<ul>
<li><p><strong>概览</strong></p></li>
<li><p><strong>不可变的好处</strong></p></li>
<li><p><strong>String, StringBuffer and StringBuilder</strong></p></li>
<li><p><strong>String Pool</strong></p></li>
<li><p><strong>new String(&quot;abc&quot;)</strong></p></li>
</ul>

<h2 id="toc_2">运算</h2>

<ul>
<li><strong>参数传递</strong></li>
<li><strong>float 与 double</strong></li>
<li><strong>隐式类型转换</strong></li>
<li><strong>switch</strong></li>
</ul>

<h2 id="toc_3">继承</h2>

<ul>
<li><strong>访问权限</strong></li>
<li><strong>抽象类与接口</strong></li>
<li><strong>super</strong></li>
<li><strong>重写与重载</strong></li>
</ul>

<h2 id="toc_4">Object 通用方法</h2>

<ul>
<li><strong>概览</strong></li>
<li><strong>equals()</strong></li>
<li><strong>hashCode()</strong></li>
<li><strong>toString()</strong></li>
<li><strong>clone()</strong></li>
</ul>

<h2 id="toc_5">关键字</h2>

<ul>
<li><strong>final</strong></li>
<li><strong>static</strong></li>
</ul>

<h2 id="toc_6">反射</h2>

<h2 id="toc_7">异常</h2>

<h2 id="toc_8">泛型</h2>

<h2 id="toc_9">注解</h2>

<h2 id="toc_10">特性</h2>

<h2 id="toc_11">Java 各版本的新特性</h2>

<h2 id="toc_12">Java 与 C++ 的区别</h2>

<h2 id="toc_13">JRE or JDK</h2>

<h2 id="toc_14">参考资料</h2>

<h2 id="toc_15">进阶指南</h2>

<p><a href="https://github.com/CyC2018/Backend-Interview-Guide">https://github.com/CyC2018/Backend-Interview-Guide</a></p>

<ul>
<li>
<a href="#toc_0">数据类型</a>
</li>
<li>
<a href="#toc_1">String</a>
</li>
<li>
<a href="#toc_2">运算</a>
</li>
<li>
<a href="#toc_3">继承</a>
</li>
<li>
<a href="#toc_4">Object 通用方法</a>
</li>
<li>
<a href="#toc_5">关键字</a>
</li>
<li>
<a href="#toc_6">反射</a>
</li>
<li>
<a href="#toc_7">异常</a>
</li>
<li>
<a href="#toc_8">泛型</a>
</li>
<li>
<a href="#toc_9">注解</a>
</li>
<li>
<a href="#toc_10">特性</a>
</li>
<li>
<a href="#toc_11">Java 各版本的新特性</a>
</li>
<li>
<a href="#toc_12">Java 与 C++ 的区别</a>
</li>
<li>
<a href="#toc_13">JRE or JDK</a>
</li>
<li>
<a href="#toc_14">参考资料</a>
</li>
<li>
<a href="#toc_15">进阶指南</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务架构下处理分布式事务的典型方案]]></title>
    <link href="https://books.sangkf.cn/15511042581022.html"/>
    <updated>2019-02-25T22:17:38+08:00</updated>
    <id>https://books.sangkf.cn/15511042581022.html</id>
    <content type="html"><![CDATA[
<p>根据微服务架构的鼻祖Martin Fowler的忠告，微服务架构中应当尽量避免分布式事务。然而，在某些领域，分布式事务如同宿命中的对手无法避免。在工程领域，分布式事务的讨论主要聚焦于强一致性和最终一致性的解决方案。典型方案包括：<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>两阶段提交（2PC, Two-phase Commit）方案；</li>
<li>eBay 事件队列方案；</li>
<li>TCC 补偿模式；</li>
<li>缓存数据最终一致性。</li>
</ul>

<h2 id="toc_0">一致性理论</h2>

<p>分布式事务的目的是保障分库数据一致性，而跨库事务会遇到各种不可控制的问题，如个别节点永久性宕机，像单机事务一样的ACID是无法奢望的。另外，业界著名的CAP理论也告诉我们，对分布式系统，需要将数据一致性和系统可用性、分区容忍性放在天平上一起考虑。</p>

<p>两阶段提交协议（简称2PC）是实现分布式事务较为经典的方案，但2PC 的可扩展性很差，在分布式架构下应用代价较大，eBay 架构师Dan Pritchett 提出了BASE 理论，用于解决大规模分布式系统下的数据一致性问题。BASE 理论告诉我们：可以通过放弃系统在每个时刻的强一致性来换取系统的可扩展性。</p>

<ul>
<li><p>CAP理论</p>
<ul>
<li><p>在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）3 个要素最多只能同时满足两个，不可兼得。其中，分区容忍性又是不可或缺的。</p>
<ul>
<li>一致性：分布式环境下多个节点的数据是否强一致。</li>
<li>可用性：分布式服务能一直保证可用状态。当用户发出一个请求后，服务能在有限时间内返回结果。</li>
<li>分区容忍性：特指对网络分区的容忍性。</li>
</ul></li>
</ul></li>
</ul>

<p>举例：Cassandra、Dynamo 等，默认优先选择AP，弱化C；HBase、MongoDB 等，默认优先选择CP，弱化A。</p>

<ul>
<li><p>BASE 理论</p>
<ul>
<li><p>核心思想：</p>
<ul>
<li>基本可用（Basically Available）：指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。</li>
<li>软状态（Soft State）：指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。</li>
<li>最终一致性（Eventual Consistency）：指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态。</li>
</ul></li>
<li><p>一致性模型</p>
<ul>
<li><p>数据的一致性模型可以分成以下 3 类：</p>
<ul>
<li>强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。</li>
<li>弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。</li>
<li>最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>分布式系统数据的强一致性、弱一致性和最终一致性可以通过Quorum NRW算法分析。</p>

<h2 id="toc_1">分布式事务解决方案</h2>

<h3 id="toc_2">2PC方案——强一致性</h3>

<p>2PC的核心原理是通过提交分阶段和记日志的方式，记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个状态节点重试，如Coordinator重启后，通过日志可以确定提交处于Prepare还是PrepareAll状态，若是前者，说明有节点可能没有Prepare成功，或所有节点Prepare成功但还没有下发Commit，状态恢复后给所有节点下发RollBack；若是PrepareAll状态，需要给所有节点下发Commit，数据库节点需要保证Commit幂等。</p>

<ul>
<li><p>2PC方案的问题：</p>
<ul>
<li>同步阻塞；</li>
<li>数据不一致；</li>
<li>单点问题。</li>
</ul></li>
<li><p>升级的3PC方案旨在解决这些问题，主要有两个改进：</p>
<ul>
<li>增加超时机制。</li>
<li>两阶段之间插入准备阶段。</li>
</ul></li>
</ul>

<p>但三阶段提交也存在一些缺陷，要彻底从协议层面避免数据不一致，可以采用Paxos或者Raft 算法。</p>

<h3 id="toc_3">eBay 事件队列方案——最终一致性</h3>

<p>eBay 的架构师Dan Pritchett，曾在一篇解释BASE 原理的论文《Base：An Acid Alternative》中提到一个eBay 分布式系统一致性问题的解决方案。它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。</p>

<p>描述的场景为，有用户表user 和交易表transaction，用户表存储用户信息、总销售额和总购买额，交易表存储每一笔交易的流水号、买家信息、卖家信息和交易金额。如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。</p>

<p>论文中提出的解决方法是将更新交易表记录和用户表更新消息放在一个本地事务来完成，为了避免重复消费用户表更新消息带来的问题，增加一个操作记录表updates_applied来记录已经完成的交易相关的信息。</p>

<p>这个方案的核心在于第二阶段的重试和幂等执行。失败后重试，这是一种补偿机制，它是能保证系统最终一致的关键流程。</p>

<h3 id="toc_4">TCC （Try-Confirm-Cancel）补偿模式——最终一致性</h3>

<p>某业务模型如图，由服务 A、服务B、服务C、服务D 共同组成的一个微服务架构系统。服务A 需要依次调用服务B、服务C 和服务D 共同完成一个操作。当服务A 调用服务D 失败时，若要保证整个系统数据的一致性，就要对服务B 和服务C 的invoke 操作进行回滚，执行反向的revert 操作。回滚成功后，整个微服务系统是数据一致的。</p>

<ul>
<li><p>实现关键要素：</p>
<ol>
<li>服务调用链必须被记录下来；</li>
<li>每个服务提供者都需要提供一组业务逻辑相反的操作，互为补偿，同时回滚操作要保证幂等；</li>
<li>必须按失败原因执行不同的回滚策略。</li>
</ol></li>
<li><p>实现难点：</p></li>
</ul>

<p>补偿模式的特点是实现简单，但是想形成一定程度的通用方案比较困难，特别是服务链的记录，因为大部分时候，业务参数或者业务逻辑千差万别。</p>

<p>另外，很多业务特征使得该服务无法提供一个安全的回滚操作。</p>

<h3 id="toc_5">缓存数据最终一致性</h3>

<p>在我们的业务系统中，缓存（Redis 或者Memcached）通常被用在数据库前面，作为数据读取的缓冲，使得I/O 操作不至于直接落在数据库上。以商品详情页为例，假如卖家修改了商品信息，并写回到数据库，但是这时候用户从商品详情页看到的信息还是从缓存中拿到的过时数据，这就出现了缓存系统和数据库系统中的数据不一致的现象。</p>

<ul>
<li>要解决该场景下缓存和数据库数据不一致的问题我们有以下两种解决方案：</li>
</ul>

<p>为缓存数据设置过期时间。当缓存中数据过期后，业务系统会从数据库中获取数据，并将新值放入缓存。这个过期时间就是系统可以达到最终一致的容忍时间。</p>

<p>更新数据库数据后同时清除缓存数据。数据库数据更新后，同步删除缓存中数据，使得下次对商品详情的获取直接从数据库中获取，并同步到缓存。</p>

<blockquote>
<p>选择建议</p>
</blockquote>

<p>在面临数据一致性问题的时候，首先要从业务需求的角度出发，确定我们对于3 种一致性模型的接受程度，再通过具体场景来决定解决方案。</p>

<p>从应用角度看，分布式事务的现实场景常常无法规避，在有能力给出其他解决方案前，2PC也是一个不错的选择。</p>

<p>对购物转账等电商和金融业务，中间件层的2PC最大问题在于业务不可见，一旦出现不可抗力或意想不到的一致性破坏，如数据节点永久性宕机，业务难以根据2PC的日志进行补偿。金融场景下，数据一致性是命根，业务需要对数据有百分之百的掌控力，建议使用TCC这类分布式事务模型，或基于消息队列的柔性事务框架，这两种方案都在业务层实现，业务开发者具有足够掌控力，可以结合SOA框架来架构，包括Dubbo、Spring Cloud等。</p>

<ul>
<li>
<a href="#toc_0">一致性理论</a>
</li>
<li>
<a href="#toc_1">分布式事务解决方案</a>
<ul>
<li>
<a href="#toc_2">2PC方案——强一致性</a>
</li>
<li>
<a href="#toc_3">eBay 事件队列方案——最终一致性</a>
</li>
<li>
<a href="#toc_4">TCC （Try-Confirm-Cancel）补偿模式——最终一致性</a>
</li>
<li>
<a href="#toc_5">缓存数据最终一致性</a>
</li>
</ul>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式系统常见的事务处理机制]]></title>
    <link href="https://books.sangkf.cn/15511041776834.html"/>
    <updated>2019-02-25T22:16:17+08:00</updated>
    <id>https://books.sangkf.cn/15511041776834.html</id>
    <content type="html"><![CDATA[
<p>为保障系统的可用性、可靠性以及性能，在分布式系统中，往往会设置数据冗余，即对数据进行复制。举例来说，当一个数据库的副本被破环以后，那么系统只需要转换到其他数据副本就能继续运行下去。<br/>
<span id="more"></span><!-- more --><br/>
另外一个例子，当访问单一服务器管理的数据的进程数不断增加时，系统就需要对服务器的数量进行扩充，此时，对服务器进行复制，随后让它们分担工作负荷，就可以提高性能。但同时，如何保障多个数据节点之间数据的一致以及如何处理分布式事务，将成为为一个复杂的话题。本文将介绍常用的事务处理机制。</p>

<h2 id="toc_0">CAP 定理</h2>

<p>CAP 定理（也称为 Brewer 定理），是由计算机科学家 Eric Brewer 提出的，即在分布式计算机系统不可能同时提供以下全部三个保证：</p>

<ul>
<li><p><strong>一致性</strong>（Consistency）：所有节点同一时间看到是相同的数据；</p></li>
<li><p><strong>可用性</strong>（Availability）：不管是否成功，确保每一个请求都能接收到响应；</p></li>
<li><p><strong>分区容错性</strong>（Partition tolerance）：系统任意分区后，在网络故障时，仍能操作</p></li>
</ul>

<p>显然，为了保障性能和可靠性，我们将数据复制多份，分布到多个节点上，同时也带来了一个难点，那就是如何保持各个副本数据的一致性。换句话说，我们选择了 AP ，则必须要牺牲掉 C 了。</p>

<p>但是，在实际的应用场景中，数据的一致性往往也是需要保证的。那么这是否违背了 CAP 定理呢？</p>

<h2 id="toc_1">一致性模型</h2>

<p>其实，数据的一致性也分几种情况，大致可以分为：</p>

<ul>
<li><p>Weak 弱一致性：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些存储系统，搜索引擎，实时游戏，语音聊天等，这些数据本文对完整性要求不高，数据是否一致关系也不大。</p></li>
<li><p>Eventually 最终一致性：当你写入一个新值后，并不一定能马上读出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件，消息中间件等系统，大部分分布式系统技术都采用这类模式。</p></li>
<li><p>Strong 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS都是强一致性的。</p></li>
</ul>

<p>也就是说，在设计分布式系统时，我们并不一定要求是强一致性的，根据应用场景可以选择弱一致性或者是最终一致性。</p>

<h2 id="toc_2">事务的作用</h2>

<p>事务有如下作用：</p>

<ul>
<li><p>保证执行结果的正确性</p></li>
<li><p>保证数据的一致性</p></li>
<li><p>ACID</p></li>
</ul>

<h2 id="toc_3">常见的事务处理机制</h2>

<h3 id="toc_4">Master-Slave 复制</h3>

<p>Slave 一般是 Master 的备份。在这样的系统中，一般是如下设计的：</p>

<ul>
<li><p>读写请求都由 Master 负责。</p></li>
<li><p>写请求写到 Master 上后，由 Master 同步到 Slave 上。</p></li>
</ul>

<p>这种机制的特点是：</p>

<ul>
<li><p>数据同步通常是异步的</p></li>
<li><p>有良好的吞吐量，低延迟 *　在大多数　RDBMS　中支持，比如　MySQL二进制日志</p></li>
<li><p>弱/最终一致性</p></li>
</ul>

<p>这种机制的缺点是，如果 Master 挂了，Slave 只能提供读服务，而没有写服务。</p>

<h3 id="toc_5">Master-Master 多主复制</h3>

<p>指一个系统存在两个或多个Master，每个Master都提供读写服务。这个机制是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。 Master-Master的好处是，一台Master挂了，别的Master可以正常做读写服务，他和Master-Slave一样，当数据没有被复制到别的Master上时，数据会丢失。很多数据库都支持Master-Master的Replication的机制。</p>

<p>这种机制的特点是：</p>

<ul>
<li><p>异步</p></li>
<li><p>最终的一致性</p></li>
<li><p>多个节点间需要序列化协议</p></li>
</ul>

<h3 id="toc_6">两阶段提交</h3>

<p>两阶段提交协议 （Two-phase commit protocol，2PC）的过程涉及到协调者和参与者。协调者可以看做成事务的发起者，同时也是事务的一个参与者。对于一个分布式事务来说，一个事务是涉及到多个参与者的。具体的两阶段提交的过程如下：</p>

<h4 id="toc_7">第一阶段（准备阶段）</h4>

<ul>
<li><p>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p></li>
<li><p>参与者节点执行询问发起为止的所有事务操作，并将 Undo 信息和 Redo 信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p></li>
<li><p>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个“同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个“中止”消息。</p></li>
</ul>

<h4 id="toc_8">第二阶段（提交阶段）</h4>

<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p>

<ul>
<li><p>当协调者节点从所有参与者节点获得的相应消息都为“同意”时:</p></li>
<li><p>协调者节点向所有参与者节点发出“正式提交(commit)”的请求。</p></li>
<li><p>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</p></li>
<li><p>参与者节点向协调者节点发送“完成”消息。</p></li>
<li><p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p></li>
<li><p>协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</p></li>
<li><p>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p></li>
<li><p>参与者节点向协调者节点发送”回滚完成”消息。</p></li>
<li><p>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p></li>
<li><p>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务</p></li>
</ul>

<p>不管最后结果如何，第二阶段都会结束当前事务。</p>

<p>二段式提交协议的优缺点：</p>

<p>优点：原理简单，实现方便；</p>

<p>缺点：</p>

<ul>
<li><p>同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。</p></li>
<li><p>单点故障。由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。</p></li>
<li><p>数据不一致。在阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到 commit 请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p></li>
<li><p>二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p></li>
</ul>

<p>为了解决两阶段提交协议的种种问题，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p>

<h4 id="toc_9">三阶段提交</h4>

<p>三阶段提交协议（Three-phase commit protocol，3PC），是二阶段提交（2PC）的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点：</p>

<ul>
<li><p>引入超时机制。同时在协调者和参与者中都引入超时机制。</p></li>
<li><p>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</p></li>
</ul>

<p>即 3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。</p>

<h4 id="toc_10">CanCommit 阶段</h4>

<p>CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p>

<ul>
<li><p>事务询问：协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p></li>
<li><p>响应反馈：参与者接到 CanCommit 请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No</p></li>
</ul>

<h4 id="toc_11">PreCommit 阶段</h4>

<p>协调者根据参与者的反应情况来决定是否可以记性事务的 PreCommit 操作。根据响应情况，有以下两种可能。</p>

<ul>
<li><p>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。</p></li>
<li><p>发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入Prepared 阶段。</p></li>
<li><p>事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将undo 和 redo 信息记录到事务日志中。</p></li>
<li><p>响应反馈：如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。</p></li>
<li><p>假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p></li>
<li><p>发送中断请求：协调者向所有参与者发送 abort 请求。</p></li>
<li><p>中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p></li>
</ul>

<h4 id="toc_12">doCommit 阶段</h4>

<p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>

<ul>
<li><p>执行提交</p></li>
<li><p>发送提交请求：协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。</p></li>
<li><p>事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p></li>
<li><p>响应反馈：事务提交完之后，向协调者发送 ACK 响应。</p></li>
<li><p>完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。</p></li>
<li><p>中断事务：协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。</p></li>
<li><p>发送中断请求：协调者向所有参与者发送 abort 请求</p></li>
<li><p>事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p></li>
<li><p>反馈结果：参与者完成事务回滚之后，向协调者发送 ACK 消息</p></li>
<li><p>中断事务：协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。</p></li>
</ul>

<p>在 doCommit 阶段，如果参与者无法及时接收到来自协调者的 doCommit 或者 rebort 请求时，会在等待超时之后，会继续进行事务的提交。即当进入第三阶段时，由于网络超时等原因，虽然参与者没有收 到 commit 或者 abort 响应，事务仍然会提交。</p>

<p>三阶段提交不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作，这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。</p>

<h3 id="toc_13">Paxos 算法</h3>

<p>Paxos 算法是 Leslie Lamport 于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法。Paxos 算法目前在 Google 的 Chubby、MegaStore、Spanner 等系统中得到了应用，Hadoop 中的 ZooKeeper 也使用了 Paxos 算法。</p>

<p>在 Paxos 算法中，分为4种角色：</p>

<ul>
<li><p>Proposer ：提议者</p></li>
<li><p>Acceptor：决策者</p></li>
<li><p>Client：产生议题者</p></li>
<li><p>Learner：最终决策学习者</p></li>
</ul>

<p>算法可以分为两个阶段来执行：</p>

<h4 id="toc_14">阶段1</h4>

<ul>
<li><p>Proposer 选择一个议案编号 n，向 acceptor 的多数派发送编号也为 n 的 prepare 请求。</p></li>
<li><p>Acceptor：如果接收到的 prepare 请求的编号 n 大于它已经回应的任何prepare 请求，它就回应已经批准的编号最高的议案（如果有的话），并承诺不再回应任何编号小于 n 的议案；</p></li>
</ul>

<h4 id="toc_15">阶段2</h4>

<ul>
<li><p>Proposer：如果收到了多数 acceptor 对 prepare 请求（编号为 n）的回应，它就向这些 acceptor 发送议案{n, v}的 accept 请求，其中 v 是所有回应中编号最高的议案的决议，或者是 proposer 选择的值，如果回应说还没有议案。</p></li>
<li><p>Acceptor：如果收到了议案{n, v}的 accept 请求，它就批准该议案，除非它已经回应了一个编号大于 n 的议案。</p></li>
<li><p>Proposer 可以提出多个议案，只要它遵循上面的算法。它可以在任何时刻放弃一个议案。（这不会破坏正确性，即使在议案被放弃后，议案的请求或者回应消息才到达目标）如果其它的 proposer 已经开始提出更高编号的议案，那么最好能放弃当前的议案。因此，如果 acceptor 忽略一个 prepare 或者 accept 请求（因为已经收到了更高编号的 prepare 请求），它应该告知 proposer 放弃议案。这是一个性能优化，而不影响正确性。</p></li>
</ul>

<h2 id="toc_16">参考文献</h2>

<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf">http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf</a></li>
<li><a href="https://www.oschina.net/question/2720166_2235329">https://www.oschina.net/question/2720166_2235329</a></li>
<li><a href="https://github.com/waylau/distributed-systems-technologies-and-cases-analysis">《分布式系统常用技术及案例分析》</a></li>
</ul>

<ul>
<li>
<a href="#toc_0">CAP 定理</a>
</li>
<li>
<a href="#toc_1">一致性模型</a>
</li>
<li>
<a href="#toc_2">事务的作用</a>
</li>
<li>
<a href="#toc_3">常见的事务处理机制</a>
<ul>
<li>
<a href="#toc_4">Master-Slave 复制</a>
</li>
<li>
<a href="#toc_5">Master-Master 多主复制</a>
</li>
<li>
<a href="#toc_6">两阶段提交</a>
<ul>
<li>
<a href="#toc_7">第一阶段（准备阶段）</a>
</li>
<li>
<a href="#toc_8">第二阶段（提交阶段）</a>
</li>
<li>
<a href="#toc_9">三阶段提交</a>
</li>
<li>
<a href="#toc_10">CanCommit 阶段</a>
</li>
<li>
<a href="#toc_11">PreCommit 阶段</a>
</li>
<li>
<a href="#toc_12">doCommit 阶段</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">Paxos 算法</a>
<ul>
<li>
<a href="#toc_14">阶段1</a>
</li>
<li>
<a href="#toc_15">阶段2</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_16">参考文献</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[😋 技术必备基础知识]]></title>
    <link href="https://books.sangkf.cn/15511034481464.html"/>
    <updated>2019-02-25T22:04:08+08:00</updated>
    <id>https://books.sangkf.cn/15511034481464.html</id>
    <content type="html"><![CDATA[
<p>本项目包含了技术面试必备的基础知识，浅显易懂，你不需要花很长的时间去阅读和理解成堆的技术书籍就可以快速掌握这些知识，从而节省宝贵的面试复习时间。你也可以阅读 <a href="https://github.com/CyC2018/Backend-Interview-Guide">面试进阶指南</a>，包含了学习指导和面试技巧，让你更轻松拿到满意的 Offer。<br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_0">✏️ 算法</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md">剑指 Offer 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode%20%E9%A2%98%E8%A7%A3.md">Leetcode 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%AE%97%E6%B3%95.md">算法</a></li>
</ul>

<h2 id="toc_1">💻 操作系统</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md">计算机操作系统</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Linux.md">Linux</a></li>
</ul>

<h2 id="toc_2">☁️ 网络</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md">计算机网络</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md">HTTP</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Socket.md">Socket</a></li>
</ul>

<h2 id="toc_3">🎨 面向对象</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md">设计模式</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md">面向对象思想</a></li>
</ul>

<h2 id="toc_4">💾 数据库</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">数据库系统原理</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md">SQL</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md">Leetcode-Database 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md">MySQL</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md">Redis</a></li>
</ul>

<h2 id="toc_5">☕️ Java</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md">Java 基础</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md">Java 容器</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md">Java 并发</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md">Java 虚拟机</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md">Java I/O</a></li>
</ul>

<h2 id="toc_6">💡 系统设计</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md">系统设计基础</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md">分布式</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9B%86%E7%BE%A4.md">集群</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md">攻击技术</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md">缓存</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md">消息队列</a></li>
</ul>

<h2 id="toc_7">🔧 工具</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Git.md">Git</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Docker.md">Docker</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md">构建工具</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md">正则表达式</a></li>
</ul>

<h2 id="toc_8">🍉 编码实践</h2>

<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.md">代码可读性</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.md">代码风格规范</a></li>
</ul>

<blockquote>
<p>原文地址 <a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></p>
</blockquote>

<ul>
<li>
<a href="#toc_0">✏️ 算法</a>
</li>
<li>
<a href="#toc_1">💻 操作系统</a>
</li>
<li>
<a href="#toc_2">☁️ 网络</a>
</li>
<li>
<a href="#toc_3">🎨 面向对象</a>
</li>
<li>
<a href="#toc_4">💾 数据库</a>
</li>
<li>
<a href="#toc_5">☕️ Java</a>
</li>
<li>
<a href="#toc_6">💡 系统设计</a>
</li>
<li>
<a href="#toc_7">🔧 工具</a>
</li>
<li>
<a href="#toc_8">🍉 编码实践</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式事务]]></title>
    <link href="https://books.sangkf.cn/15510945917129.html"/>
    <updated>2019-02-25T19:36:31+08:00</updated>
    <id>https://books.sangkf.cn/15510945917129.html</id>
    <content type="html"><![CDATA[
<p>分布式事务场景如何设计系统架构及解决数据一致性问题，个人理解最终方案把握以下原则就可以了，那就是：大事务=小事务（原子事务）+异步（消息通知），<br/>
<span id="more"></span><!-- more --><br/>
<strong>解决分布式事务的最好办法其实就是不考虑分布式事务，将一个大的业务进行拆分，整个大的业务流程，转化成若干个小的业务流程，然后通过设计补偿流程从而考虑最终一致性。</strong></p>

<h4 id="toc_0">What’s 事务</h4>

<p>事务（Transaction）及其ACID属性</p>

<p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性：</p>

<ul>
<li>原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li>隔离性（Isoation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li>持久性（Durabe）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>

<h4 id="toc_1">典型场景：银行转账业务</h4>

<p>例如：李雷账户中有500块钱，韩梅梅账户有200块钱，李雷要从自己的账户中转100块钱给韩梅梅，转账（事务）成功执行完成后应该是李雷账户减100变为400，韩梅梅账户加100变为300，不能出现其他情况，即在事务开始和结束时数据都必须保持一致状态（一致性），事务结束时所有的数据及结构都必须是正确的。并且同样的转账操作（同一流水，即一次转账操作）无论执行多少次结果都相同（幂等性）。</p>

<h4 id="toc_2">电商场景：流量充值业务</h4>

<p>再说我们做的一个项目：中国移动-流量充值能力中心，核心业务流程为：</p>

<pre><code class="language-text">  1. 用户进入流量充值商品购买页面，选择流量商品；
  2. 购买流量充值商品，有库存限制则判断库存，生成流量购买订单；
  3. 选择对应的支付方式（和包、银联、支付宝、微信）进行支付操作；
  4. 支付成功后，近实时流量到账即可使用流量商品；

</code></pre>

<p>此业务流程看似不是很复杂对吧，不涉及到类似电商业务的实物购买，但是我认为其中的区别并不是很大，只是缺少电商中的物流发货流程，其他流程几乎是一样的，也有库存以及优惠折扣等业务存在。</p>

<p>整个系统交互如下图：</p>

<p><img src="media/15510945917129/15510949905392.png" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<h4 id="toc_3">分布式事务</h4>

<p>上述两个场景的业务需求已经说完了，接着谈谈分布式事务，要说分布式事务那就先聊聊本地事务与分布式事务：</p>

<p>Ps：相同点：首先都是要保证数据正确（即ACID），本地事务与分布式事务还可以对应为：刚性事务与柔性事务，在我个人理解刚性事务与柔性事务的最大区别就是：一个完整的事务操作是否可以在同一物理介质（例如：内存）上同时完成；柔性事务就是一个完整事务需要跨物理介质或跨物理节点（网络通讯），那么排它锁、共享锁等等就没有用武之地了（这里并不是指大事务拆小事务【本地事务】后），无法保证原子性（Atomicity）完成事务。个人理解分布式（柔性）事务本质意义上就是-伪事务，柔性事务其实就是根据不同的业务场景使用不同的方法实现最终一致性，因为可以根据业务的特性做部分取舍，在业务过程中可以容忍一定时间内的数据不一致。</p>

<p>在知乎上面看过一篇文章，支付宝的柔性事务实现方式有四种分别针对不同的业务场景，如下图：</p>

<p><img src="media/15510945917129/2.png" alt="image" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<ol>
<li>两阶段型</li>
<li>补偿型</li>
<li>异步确保型</li>
<li>最大努力通知型</li>
</ol>

<p>回到我们流量交易中心的业务场景：</p>

<p>通过Dubbo实现了微服务化，大致拆分如下：</p>

<ol>
<li>商品服务</li>
<li>订单服务</li>
<li>库存服务</li>
<li>支付服务</li>
<li>直充服务</li>
<li>消息服务</li>
<li>等其他服务</li>
</ol>

<h4 id="toc_4">场景一：</h4>

<p>库存数量与订单数量一致性，采用补偿型+最大努力通知型，采用原因为不涉及跨机房和长事务（正常情况下库存与订单服务处理很快）：</p>

<ol>
<li>用户下单先减库存，库存减成功后；</li>
<li>调用下单服务：</li>
<li>2-1. 下单成功，两事务均提交完成；</li>
<li>2-2. 下单失败，库存回滚，两事务均失败，此处还有一个保障机制（最大努力通知型），就是如果调用库存服务异常，确定库存回滚失败了，则放入消息服务（延时消息队列）分阶段定时重试，努力重试保证库存服务正常后成功回滚。</li>
</ol>

<h4 id="toc_5">场景二：</h4>

<p>订单信息、支付信息、充值信息三者之间的一致性，采用异步确保型的原因是，整个业务链路太长且跨不同的机房系统，网络延迟较高，业务方面恰好不需要非常高的实时性，所以采用小事务+异步通知，目前正常情况下用户从下单到完成支付到流量到账平均为1-5分钟左右：</p>

<ol>
<li>下单成功即订单服务创建订单成功并发送支付请求到支付网关系统（订单状态-待支付，超过1小时未支付则流转为超时未付撤销，此处用到了RocketMQ的延时消费恰好实现定时器业务场景）。</li>
<li>返回支付页面，用户在支付交易系统完成支付业务流程，支付网关异步通知流量中心，流量中心接收到支付成功状态后修改订单状态-支付成功，并给支付网关返回成功结果（此处并发压力目前不大，暂时没有再进行异步解耦）。</li>
<li>流量中心修改完订单状态后，调用消息服务将直充业务放入消息队列，对直充业务进行解耦（原因是直充需要调用31省移动CRM系统，此链路过长，且部分省CRM系统耗时非常大，每个省的处理能力不同，经常出现20秒以上的超时，因此要考虑部分超时较高的省份拖垮系统，进行业务的削峰填谷）；</li>
<li>3-1. 当直充成功时，修改订单状态-已完成；</li>
<li>3-2. 当直充失败时（移动特性，例如：直充时正好用户销户或者停机了），修改订单状态为待退款，并调用支付网关系统的退款接口，退款成功后支付网关异步通知流量中心，流量中心修改订单状态为-退款成功；</li>
<li>3-3. 当直充超时时，调用定时任务服务进行超时重试机制（第一次重试在10分钟后执行、第二次在30分钟后、第三次…..），直到最大超时重试次数后还得不到直充结果，订单状态会卡在支付成功状态，依赖T+1对账稽核流程保证最终一致性，订单状态根据对账结果流转为：已完成或待退款–&gt;退款成功。</li>
</ol>

<h4 id="toc_6">场景三：</h4>

<p>直充到账后的消息通知（APP消息推送或短信通知），采用最大努力通知型，这个业务场景比较简单，在直充成功后，订单状态流转为已完成，此时通过消息服务进行到账通知业务的解耦，调用消息服务失败的情况下，使用定时任务努力通知。</p>

<h4 id="toc_7">场景四：</h4>

<p><strong>对账稽核：</strong></p>

<p>按照支付账期每日进行T+1对账，对账原则：以支付交易记录为准，对流量中心订单记录+支付网关交易记录+省CRM充值记录三方比对，将某些中间状态的订单（例如：支付成功、待退款）核对后将订单状态流转完结（已完成、退款成功）。</p>

<p><strong>结算稽核：</strong></p>

<p>对账成功后的数据定期进入结算流程，对支付网关周期内的支付金额与结算数据的金额进行核对，稽核成功后进行财务结算流程，将钱结算给省公司，并提供结算明细给省公司，供省公司与直充成本记录进行复核。 Ps：以下是流量中心的部分架构设计，总体原则方向：微服务化</p>

<p><strong>流量中心-架构设计</strong></p>

<p><img src="media/15510945917129/3.png" alt="image" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>架构设计思想：在系统初期设计时以及部分硬性环境约束下，我们根据业务拆分为多个子系统（微服务）：商品服务、订单服务、库存服务、支付网关、统一接口平台、对账服务、结算服务、网关对接服务等，后续还会增加：账户服务、虚拟货币服务、卡券服务等等…。按照微服务的核心设计思想，所有服务完全独立、隔离，因此所有服务从上至下：请求接入（连接管理）、请求处理（计算服务）、数据存储（存储服务）进行拆分，接入与计算尽最大可能实现无状态，数据存储进行垂直+水平拆分，垂直拆分：商品库-mysql（读多写少，主从架构+读写分离）+redis（读多写少，集群方式）、订单库-mysql（读写均衡，多主多从+水平拆分）、库存专用库-redis（分布式+主备容灾）、外部交易系统-支付网关、外部办理系统-统一接口平台。</p>

<p>Ps：此架构目前已支撑总交易额3.6亿，总订单4680万，日均交易额500万，日订单量50万，后续业务量持续增加的情况下按照微服务思想继续拆分，例如将订单服务再拆分为：下单服务、查单服务，直到根据业务需求与系统关系耦合性拆分到最细粒度为止。</p>

<ol>
<li>性能扩展：应用层计算服务（无状态应用）通过增加服务节点同比提升运算性能，配套质量（性能）监控服务dubbo monitor及整合Netflix的Hystrix熔断器对业务质量进行管理实现应用层的动态扩缩容。</li>
<li>容量扩展：数据层存储服务（有状态应用）通过对数据水平拆分实现容量的无限扩容，Nosql类方案：Codis中间件；关系型数据库：Mycat数据库分库分表中间件。目前项目中采用twitter的snowflake唯一ID生成器（根据业务场景优化后）自己实现数据的水平拆分和路由规则。</li>
<li>存储性能：Nosql：针对读多写少场景-使用淘宝的Tedis（多写随机读的特性提高性能），读写均衡使用-Codis；Mysql：读多写少场景使用一主多从架构（例如商品信息），读写均衡场景使用多主多从架构（例如订单信息）。</li>
</ol>

<p><strong>整体拆分原则如下图：</strong></p>

<p><img src="media/15510945917129/4.png" alt="image" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<ul>
<li>
<a href="#toc_0">What’s 事务</a>
</li>
<li>
<a href="#toc_1">典型场景：银行转账业务</a>
</li>
<li>
<a href="#toc_2">电商场景：流量充值业务</a>
</li>
<li>
<a href="#toc_3">分布式事务</a>
</li>
<li>
<a href="#toc_4">场景一：</a>
</li>
<li>
<a href="#toc_5">场景二：</a>
</li>
<li>
<a href="#toc_6">场景三：</a>
</li>
<li>
<a href="#toc_7">场景四：</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事务]]></title>
    <link href="https://books.sangkf.cn/15510944838066.html"/>
    <updated>2019-02-25T19:34:43+08:00</updated>
    <id>https://books.sangkf.cn/15510944838066.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">事务特性</h2>

<p>原子性、一致性、隔离性、持久性，这四个属性通常称为ACID特性。<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
<li>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
<li>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ul>

<h2 id="toc_1">分布式事务</h2>

<ul>
<li><a href="15510945917129.html">分布式事务</a></li>
<li><a href="15511041776834.html">分布式系统常见的事务处理机制</a></li>
<li><a href="15511042581022.html">微服务架构下处理分布式事务的典型方案</a></li>
<li>解决分布式系统事务一致性的几种方案对比</li>
<li>多库多事务降低数据不一致概率</li>
<li>蚂蚁技术专家：一篇文章带你学习分布式事务</li>
</ul>

<h2 id="toc_2">开源框架</h2>

<ul>
<li>tcc-transaction是TCC型事务java实现</li>
<li>TCC分布式事务的实现原理</li>
<li>分布式事务 TCC-Transaction 源码分析 —— Dubbo 支持</li>
<li>分布式事务 TCC-Transaction 源码分析 —— 项目实战</li>
<li>GTS来了！阿里微服务架构下的分布式事务解决方案</li>
<li>Atomikos</li>
<li>微服务架构下分布式事务解决方案 —— 阿里GTS</li>
<li>ByteJTA是一个兼容JTA规范的基于XA/2PC的分布式事务管理器</li>
</ul>

<ul>
<li>
<a href="#toc_0">事务特性</a>
</li>
<li>
<a href="#toc_1">分布式事务</a>
</li>
<li>
<a href="#toc_2">开源框架</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 生态圈知识汇总]]></title>
    <link href="https://books.sangkf.cn/15510844326202.html"/>
    <updated>2019-02-25T16:47:12+08:00</updated>
    <id>https://books.sangkf.cn/15510844326202.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">前言</h3>

<blockquote>
<p>有人认为编程是一门技术活，要有一定的天赋，非天资聪慧者不能及也。其实不然，笔者虽是计算机专业出身，但工作年限并不长，对于技术这碗饭有一些心得体会，大多数人成为某领域顶级专家可能会有些难度，但应对日常工作，成长为资深研发工程师、技术专家、甚至成为小团队的Team Leader，其实并不难。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p><strong>多读书、多看报，多研究常用开源框架的源码，比如：github.com，这里汇集了全球工程师的智慧！</strong></p>

<p>言归正传，下文会列举工作中常用的一些技术，以及如何锻炼提升自己的架构能力。</p>

<p>由于每块技术市场上基本都有对应的网络资料或书籍，所以本文只是少篇幅列举工作中用到的核心知识点，抛砖引玉，属于进阶型，不适用初学者。</p>

<h3 id="toc_1"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"></a>基础知识</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fjava.md">java</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspring.md">spring</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspringboot.md">spring boot</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fspringcloud.md">spring cloud</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2Fibatis.md">ibatis</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2F%25E5%25B8%25B8%25E7%2594%25A8%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F.md">设计模式</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fbasic-knowledge%2FLog4j.md">Log日志</a></li>
</ul>

<h3 id="toc_2"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E6%95%B0%E6%8D%AE%E5%BA%93"></a>数据库</h3>

<p>目前使用最多还是mysql，虽然单机性能比不上oracle，但免费开源，单机成本低且借助于分布式集群，可以有强大的输出能力。</p>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fdatabase-connection-pool.md">连接池</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Ftransaction.md">事务</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2F%25E5%2588%2586%25E5%25BA%2593%25E5%2588%2586%25E8%25A1%25A8.md">分库分表</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fid-generate.md">id生成器</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F6909240">读写分离</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fsql-optimize.md">SQL调优</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Fother.md">其它</a></li>
</ul>

<h3 id="toc_3"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#web%E5%AE%B9%E5%99%A8%E5%8D%8F%E8%AE%AE%E7%BD%91%E7%BB%9C"></a>web容器/协议/网络</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fload-balance.md">负载均衡</a></li>
<li>服务器
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2FNginx.md">Nginx</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Ftomcat.md">Tomcat</a></li>
</ul></li>
<li>协议
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fhttp%25E5%258D%258F%25E8%25AE%25AE.md">HTTP 协议</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Ftcp.md">TCP 协议</a></li>
</ul></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2FCDN.md">CDN</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fweb%2Fother.md">其它</a></li>
</ul>

<h3 id="toc_4"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E5%8C%85"></a>常用三方工具包</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FGoole-Guava.md">Google Guava</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FfastJson.md">fastJson</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F17913607">log4J</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-codec.md">commons-codec</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-lang3.md">commons-lang3</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fcommons-io.md">commons-io</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FQuartz.md">Quartz</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2FHttpClient.md">HttpClient</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F7671294">Javassist</a></li>
</ul>

<h3 id="toc_5"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E4%B8%AD%E9%97%B4%E4%BB%B6"></a>中间件</h3>

<ul>
<li><p>RPC框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fdubbo.md">dubbo</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fdubbox">dubbox</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fweibocom%2Fmotan">motan</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fapache%2Fthrift">Thrift</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Frpc-compare.md">RPC框架性能比较</a></li>
</ul></li>
<li><p>MQ消息</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fapache%2Factivemq">ActiveMQ</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FRabbitMQ.md">RabbitMQ</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fkafka.md">Kafka</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FRocketMQ.md">RocketMQ</a></li>
</ul></li>
<li><p>分布式缓存</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fopen-source-framework%2Fredis.md">redis</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster">codis</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F8035197">memcache</a></li>
</ul></li>
<li><p>本地缓存</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fguava.md">Guava</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fehcache.md">ehcache</a></li>
</ul></li>
<li><p>搜索</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Felasticsearch.md">Elasticsearch</a></li>
</ul></li>
<li><p>分布式数据框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fcobar.md">cobar</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fmycat.md">Mycat</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Ftsharding.md">tsharding</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Ftb_tddl">tddl</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fsharding-jdbc.md">sharding-jdbc</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgitee.com%2Frobertleepeak%2Fdbsplit">dbsplit</a></li>
</ul></li>
<li><p>分布式协调服务</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fzookeeper.md">zookeeper</a></li>
</ul></li>
<li><p>配置管理</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fsuper-diamond%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590.md">super-diamond</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fdisconf">disconf</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fapollo.md">apollo</a></li>
</ul></li>
<li><p>分布式文件系统</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FFastDFS.md">FastDFS</a></li>
</ul></li>
<li><p>分布式任务调度框架</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Felasticjob%2Felastic-job">Elastic-Job</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Fdangdang-distributed-work-framework-elastic-job">详解当当网的分布式作业框架elastic-job</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Ftaosir_zhang%2Farticle%2Fdetails%2F50728362">TBSchedule</a></li>
</ul></li>
<li><p>大数据</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHbase.md">Hbase</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FSpark.md">Spark</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHadoop.md">Hadoop</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FHive.md">Hive</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2Fbig-data.md">other框架</a></li>
</ul></li>
<li><p>其它</p>
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fcanal">数据库binlog的增量订阅&amp;消费组件</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fotter">数据库同步系统</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FTCC-Transaction.md">TCC-Transaction</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fmiddle-software%2FNetty.md">Netty</a></li>
</ul></li>
</ul>

<h3 id="toc_6"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"></a>系统架构</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Farchitecture-experience.md">架构经验</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Farchitecture-good-case.md">经典案例</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2Ftechnology-selection.md">通用技术方案选型</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fsystem-architecture%2F%25E7%25BC%2596%25E7%25A0%2581%25E5%2589%258D3000%25E9%2597%25AE.md">编码前3000问</a></li>
</ul>

<h3 id="toc_7"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"></a>项目管理</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2F%25E8%25AE%25BA%25E9%259C%2580%25E6%25B1%2582%25E8%25B0%2583%25E7%25A0%2594%25E7%259A%2584%25E9%2587%258D%25E8%25A6%2581%25E6%2580%25A7.md">论需求调研的重要性</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Fproject-management.md">项目管理</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Fcode.md">代码管理</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fproject-management%2Ftest.md">测试相关</a></li>
</ul>

<h3 id="toc_8"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E8%BF%90%E7%BB%B4"></a>运维</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Fonline-question.md">快速排查线上问题</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Flinux-commands.md">linux常用命令</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2F%25E6%259C%25AC%25E5%259C%25B0%25E4%25BB%25A3%25E7%25A0%2581%25E8%25B0%2583%25E8%25AF%2595.md">本地代码调试</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fops%2Fdocker.md">Docker</a></li>
</ul>

<h3 id="toc_9"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF"></a>个人成长</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fstudy.md">学习网站</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fbook.md">Tom哥的读书单</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fperson.md">个人成长与职业规划</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fprogramer.md">程序员素养</a></li>
</ul>

<h3 id="toc_10"><a href="https://juejin.im/entry/5b2b02986fb9a00e9402abb5?utm_source=gold_browser_extension#%E5%85%B6%E5%AE%83"></a>其它</h3>

<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Ftool.md">常用软件工具</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2F%25E4%25B8%2580%25E8%2587%25B4%25E6%2580%25A7hash.md">一致性hash算法</a></li>
<li>面试
<ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fjava-interview.md">java面试题</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2Fbigdata-interview.md">大数据面试题</a></li>
</ul></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fother%2F%25E5%259B%259E%25E8%25BD%25A6%25E4%25B8%258E%25E6%258D%25A2%25E8%25A1%258C%25E7%259A%2584%25E5%258C%25BA%25E5%2588%25AB.md">回车与换行的区别</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fqq1332479771%2Farticle%2Fdetails%2F56087333">github上fork项目后，如何同步更新后面提交</a></li>
</ul>

<blockquote>
<p>原文地址：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk">github.com/aalansehaiy…</a></p>
</blockquote>

<ul>
<li>
<a href="#toc_0">前言</a>
</li>
<li>
<a href="#toc_1">基础知识</a>
</li>
<li>
<a href="#toc_2">数据库</a>
</li>
<li>
<a href="#toc_3">web容器/协议/网络</a>
</li>
<li>
<a href="#toc_4">常用三方工具包</a>
</li>
<li>
<a href="#toc_5">中间件</a>
</li>
<li>
<a href="#toc_6">系统架构</a>
</li>
<li>
<a href="#toc_7">项目管理</a>
</li>
<li>
<a href="#toc_8">运维</a>
</li>
<li>
<a href="#toc_9">个人成长</a>
</li>
<li>
<a href="#toc_10">其它</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[限流设计]]></title>
    <link href="https://books.sangkf.cn/15510821177382.html"/>
    <updated>2019-02-25T16:08:37+08:00</updated>
    <id>https://books.sangkf.cn/15510821177382.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>限流，书面意思和作用一致，就是为了限制，通过对并发访问或者请求进行限速或者一个时间窗口内的请求进行限速来保护系统。一旦达到了限制的临界点，可以用拒绝服务、排队、或者等待的方式来保护现有系统，不至于发生雪崩现象。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>限流就像做帝都的地铁一般，如果你住在西二旗或者天通苑也许会体会的更深刻一些。我更习惯在技术角度用消费者的角度来阐述，需要限流的一般原因是消费者能力有限，目的为了避免超过消费者能力而出现系统故障。当然也有其他类似的情况也可以用限流来解决。</p>

<p>限流的表现形式上大部分可以分为两大类：</p>

<ul>
<li>限制消费者数量。也可以说消费的最大能力值。比如：数据库的连接池是侧重的是总的连接数，本质上也是限制了消费者的最大消费能力。</li>
<li>可以被消费的请求数量。这里的数量可以是瞬时并发数，也可以是一段时间内的总并发数。</li>
</ul>

<p>除此之外，限流还有别的表现形式，例如按照网络流量来限流，按照cpu使用率来限流等。按照限流的范围又可以分为分布式限流，应用限流，接口限流等。无论怎么变化，限流都可以用以下图来表示：</p>

<p><img src="media/15510821177382/15510824198802.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_0">常用技术实现</h2>

<ul>
<li>令牌桶算法<br/>
令牌桶是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌，填满了就丢弃令牌，请求是否被处理要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求。令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌。令牌桶中装的是令牌。
<img src="media/15510821177382/15510825111049.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></li>
<li><p>漏桶算法<br/>
漏桶一个固定容量的漏桶，按照固定常量速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝。漏桶可以看做是一个具有固定容量、固定流出速率的队列，漏桶限制的是请求的流出速率。漏桶中装的是请求。</p></li>
<li><p>计数器<br/>
 有时我们还会使用计数器来进行限流，主要用来限制一定时间内的总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流，是一种简单粗暴的总数量限流，而不是平均速率限流。</p></li>
</ul>

<h2 id="toc_1">不用算法的解决方案</h2>

<p>我们可以用一个按照时间段限制请求总数的方式来限流。 总体思路是这样：</p>

<ul>
<li>用一个环形来代表通过的请求容器。</li>
<li>用一个指针指向当前请求所到的位置索引，来判断当前请求时间和当前位置上次请求的时间差，依此来判断是否被限制。</li>
<li>如果请求通过，则当前指针向前移动一个位置，不通过则不移动位置</li>
<li>重复以上步骤 直到永远.......</li>
</ul>

<p><img src="media/15510821177382/15510827864849.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_2">核心代码</h2>

<blockquote>
<p>以下代码的核心思路是这样的：指针当前位置的时间元素和当前时间的差来决定是否允许此次请求，这样通过的请求在时间上表现的比较平滑。</p>
</blockquote>

<pre><code class="language-java">//限流组件,采用数组做为一个环
    class LimitService
    {
        //当前指针的位置
        int currentIndex = 0;
        //限制的时间的秒数，即：x秒允许多少请求
        int limitTimeSencond = 1;
        //请求环的容器数组
        DateTime?[] requestRing = null;
        //容器改变或者移动指针时候的锁
        object objLock = new object();

        public LimitService(int countPerSecond,int  _limitTimeSencond)
        {
            requestRing = new DateTime?[countPerSecond];
            limitTimeSencond= _limitTimeSencond;
        }

        //程序是否可以继续
        public bool IsContinue()
        {
            lock (objLock)
            {
                var currentNode = requestRing[currentIndex];
                //如果当前节点的值加上设置的秒 超过当前时间，说明超过限制
                if (currentNode != null&amp;&amp; currentNode.Value.AddSeconds(limitTimeSencond) &gt;DateTime.Now)
                {
                    return false;
                }
                //当前节点设置为当前时间
                requestRing[currentIndex] = DateTime.Now;
                //指针移动一个位置
                MoveNextIndex(ref currentIndex);
            }            
            return true;
        }
        //改变每秒可以通过的请求数
        public bool ChangeCountPerSecond(int countPerSecond)
        {
            lock (objLock)
            {
                requestRing = new DateTime?[countPerSecond];
                currentIndex = 0;
            }
            return true;
        }

        //指针往前移动一个位置
        private void MoveNextIndex(ref int currentIndex)
        {
            if (currentIndex != requestRing.Length - 1)
            {
                currentIndex = currentIndex + 1;
            }
            else
            {
                currentIndex = 0;
            }
        }
    }
</code></pre>

<p>测试程序如下：</p>

<pre><code class="language-java">static  LimitService l = new LimitService(1000, 1);
        static void Main(string[] args)
        {
            int threadCount = 50;
            while (threadCount &gt;= 0)
            {
                Thread t = new Thread(s =&gt;
                {
                    Limit();
                });
                t.Start();
                threadCount--;
            }           

            Console.Read();
        }

        static void Limit()
        {
            int i = 0;
            int okCount = 0;
            int noCount = 0;
            Stopwatch w = new Stopwatch();
            w.Start();
            while (i &lt; 1000000)
            {
                var ret = l.IsContinue();
                if (ret)
                {
                    okCount++;
                }
                else
                {
                    noCount++;
                }
                i++;
            }
            w.Stop();
            Console.WriteLine($&quot;共用{w.ElapsedMilliseconds},允许：{okCount},  拦截：{noCount}&quot;);
        }
</code></pre>

<p>测试结果如下：</p>

<p><img src="media/15510821177382/15510829240788.jpg" alt=""/><br/>
<img src="media/15510821177382/15510829535558.jpg" alt=""/><br/>
最大用时15秒,共处理请求1000000*50=50000000 次</p>

<p>并未发生GC操作，内存使用率非常低，每秒处理 300万次+请求 。以上程序修改为10个线程，大约用时4秒之内<br/>
<img src="media/15510821177382/15510829711440.jpg" alt=""/></p>

<p>如果是强劲的服务器或者线程数较少情况下处理速度将会更快</p>

<ul>
<li>
<a href="#toc_0">常用技术实现</a>
</li>
<li>
<a href="#toc_1">不用算法的解决方案</a>
</li>
<li>
<a href="#toc_2">核心代码</a>
</li>
</ul>


<blockquote>
<p>[转载]<a href="https://www.cnblogs.com/zhanlang/p/10424757.html">https://www.cnblogs.com/zhanlang/p/10424757.html</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JDK动态代理]]></title>
    <link href="https://books.sangkf.cn/15510682951931.html"/>
    <updated>2019-02-25T12:18:15+08:00</updated>
    <id>https://books.sangkf.cn/15510682951931.html</id>
    <content type="html"><![CDATA[
<p>代理类的目的是为其他对象提供一个代理以控制对某个对象的访问。<br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_0">代理的含义</h2>

<ul>
<li>代理类的目的是为其他对象提供一个代理以控制对某个对象的访问。</li>
<li>代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</li>
<li>为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。</li>
<li>通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好的隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</li>
</ul>

<h2 id="toc_1">动态代理相关类介绍</h2>

<ol>
<li><p>InvocationHandler</p>
<pre><code class="language-text">每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联了一个Handler,当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的Invoke方法来进行调用。
</code></pre>
<p>InvocationHandler这个接口的唯一一个方法invoke方法:</p>
<pre><code class="language-java">Object invoke(Object proxy, Method method, Object[] args) throws Throwable
</code></pre>
<p>三个参数:</p>
<ul>
<li>proxy： 指代JDK动态生成的最终代理对象</li>
<li>method：指代的是我们所要调用真是对象的某个方法的Method对象</li>
<li>args: 指代的是调用真是对象的某个方法时接收的参数</li>
</ul></li>
<li><p>Proxy</p>
<p>​    Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法</p>
<pre><code class="language-java">public static Object newProxyInstance(ClassLoader loader,
                                         Class&lt;?&gt;[] interfaces,<br/>
                                         InvocationHandler h)<br/>
       throws IllegalArgumentException
</code></pre>
<p>这个方法的作用就是得到一个动态的代理对象，其接收三个参数，我们来看看这三个参数所代表的含义：</p>
<ul>
<li>loader:　一个ClassLoader对象，定义了由哪个ClassLoader来对生成的代理对象进行加载</li>
<li>interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</li>
<li>一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</li>
</ul>
<p>其实我们所说的DynamicProxy（动态代理类）是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些 interface。如此一来，我们可以把该class的实例当作这些interface中的任何一个来用（可以强转为相应的接口类型）。当然，这个DynamicProxy其实就是一个Proxy，它不会做实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</p></li>
</ol>

<blockquote>
<p>[转载]<a href="https://blog.csdn.net/xiaokang123456kao/article/details/77679848">https://blog.csdn.net/xiaokang123456kao/article/details/77679848</a></p>
</blockquote>

<ul>
<li>
<a href="#toc_0">代理的含义</a>
</li>
<li>
<a href="#toc_1">动态代理相关类介绍</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql大表优化方案]]></title>
    <link href="https://books.sangkf.cn/15510645880732.html"/>
    <updated>2019-02-25T11:16:28+08:00</updated>
    <id>https://books.sangkf.cn/15510645880732.html</id>
    <content type="html"><![CDATA[
<p><a href="https://yq.aliyun.com/articles/679881?spm=a2c4e.11155472.0.0.ae1e42459WcIqo">原文地址</a><br/>
<a href="https://yq.aliyun.com/articles/679881?spm=a2c4e.11155472.0.0.ae1e42459WcIqo">https://yq.aliyun.com/articles/679881?spm=a2c4e.11155472.0.0.ae1e42459WcIqo</a></p>

<h2 id="toc_0">单表优化方案</h2>

<blockquote>
<p>除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量。<br/>
<span id="more"></span><!-- more --></p>

<ol>
<li><strong>字段优化总结</strong></li>
</ol>
</blockquote>

<ul>
<li>尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED</li>
<li>VARCHAR的长度只分配真正需要的空间</li>
<li>使用枚举或整数代替字符串类型</li>
<li>尽量使用TIMESTAMP而非DATETIME</li>
<li>单表不要有太多字段，建议在20以内</li>
<li>避免使用NULL字段，很难查询优化且占用额外索引空间</li>
<li><p>用整型来存IP</p></li>
</ul>

<ol>
<li><p><strong>索引优化总结</strong></p>
<ul>
<li>索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描</li>
<li>应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>值分布很稀少的字段不适合建索引，例如&quot;性别&quot;这种只有两三个值的字段</li>
<li>字符字段只建前缀索引</li>
<li>字符字段最好不要做主键</li>
<li>不用外键，由程序保证约束</li>
<li>尽量不用UNIQUE，由程序保证约束</li>
<li>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引</li>
</ul></li>
<li><p><strong>查询SQL优化总结</strong></p>
<ul>
<li>可通过开启慢查询日志来找出较慢的SQL</li>
<li>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</li>
<li>sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库</li>
<li>不用SELECT *</li>
<li>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内</li>
<li>不用函数和触发器，在应用程序实现</li>
<li>避免%xxx式查询</li>
<li>少用JOIN</li>
<li>使用同类型进行比较，比如用&#39;123&#39;和&#39;123&#39;比，123和123比</li>
<li>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描</li>
<li>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5</li>
<li>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</li>
</ul></li>
<li><p><strong>引擎的选择</strong></p>
<p>目前广泛使用的是MyISAM和InnoDB两种引擎。</p>
<ul>
<li><p><strong>MyISAM</strong></p>
<p><strong>MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：</strong></p>
<ul>
<li>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</li>
<li>不支持事务</li>
<li>不支持外键</li>
<li>不支持崩溃后的安全恢复</li>
<li>在表有读取查询的同时，支持往表中插入新纪录</li>
<li>支持BLOB和TEXT的前500个字符索引，支持全文索引</li>
<li>支持延迟更新索引，极大提升写入性能</li>
<li>对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用</li>
</ul></li>
<li><p><strong>InnoDB</strong></p>
<p><strong>InnoDB在MySQL 5.5后成为默认索引，它的特点是：</strong></p>
<ul>
<li>支持行锁，采用MVCC来支持高并发</li>
<li>支持事务</li>
<li>支持外键</li>
<li>支持崩溃后的安全恢复</li>
<li>不支持全文索引</li>
</ul></li>
</ul>
<p>总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表</p></li>
<li><p><strong>系统调优参数</strong></p>
<p>1）back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500；</p>
<p>2）wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时；</p>
<p>3）max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限；</p>
<p>4）thread_concurrency：并发线程数，设为CPU核数的两倍；</p>
<p>5）skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问；</p>
<p>6）key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询show status like &#39;key_read%&#39;，保证key_reads / key_read_requests在0.1%以下最好；</p>
<p>7）innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询show status like &#39;Innodb_buffer_pool_read%&#39;，保证 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests越高越好；</p>
<p>8）innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小；</p>
<p>9）innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB；</p>
<p>10）query_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大；</p>
<p>11）可以通过命令show status like &#39;Qcache_%&#39;查看目前系统Query catch使用大小；</p>
<p>12）read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能；</p>
<p>13）sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小；</p>
<p>14）read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大；</p>
<p>15）record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值；</p>
<p>16）thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的；</p>
<p>17）table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM。</p></li>
<li><p><strong>升级硬件</strong></p>
<p>Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能。</p></li>
</ol>

<h2 id="toc_1">读写分离</h2>

<p>也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离</p>

<h2 id="toc_2">缓存</h2>

<p><strong>缓存可以发生在这些层次：</strong></p>

<p>1）MySQL内部：在系统调优参数介绍了相关设置；</p>

<p>2）数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象Persistence Object；</p>

<p>3）应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象Data Transfer Object；</p>

<p>4）Web层：针对web页面做缓存；</p>

<p>5）浏览器客户端：用户端的缓存。</p>

<p>可以根据实际情况在一个层次或多个层次结合加入缓存。</p>

<p><strong>这里重点介绍下服务层的缓存实现，目前主要有两种方式：</strong></p>

<p><strong>1）直写式（Write Through）：</strong>在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般；</p>

<p><strong>2）回写式（Write Back）：</strong>当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。</p>

<h2 id="toc_3">表分区</h2>

<p>MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码。</p>

<p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218160702113.png" alt="image-20190218160702113"/></p>

<p>用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上：</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218160739457.png" alt="image-20190218160739457"/></p>

<p><strong>分区的好处是：</strong></p>

<p>1）可以让单表存储更多的数据；</p>

<p>2）分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作；</p>

<p>3）部分查询能够从查询条件确定只落在少数分区上，速度会很快；</p>

<p>4）分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备；</p>

<p>5）可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争；</p>

<p>6）可以备份和恢复单个分区。</p>

<p><strong>分区的限制和缺点：</strong></p>

<p>1）一个表最多只能有1024个分区；</p>

<p>2）如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来；</p>

<p>3）分区表无法使用外键约束；</p>

<p>4）NULL值会使分区过滤无效；</p>

<p>5）所有分区必须使用相同的存储引擎。</p>

<p><strong>分区的类型：</strong></p>

<p>1）RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区；</p>

<p>2）LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择；</p>

<p>3）HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式；</p>

<p>4）KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</p>

<p><strong>分区最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218160812843.png" alt="image-20190218160812843"/></p>

<p>查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。</p>

<p>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存。</p>

<p>另外MySQL有一种早期的简单的分区实现 - 合并表（merge table），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代。</p>

<h2 id="toc_4">垂直拆分</h2>

<p>垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。</p>

<p><strong>比如原始的用户表是：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218162154213.png" alt="image-20190218162154213"/></p>

<p><strong>垂直拆分后是：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218162129833.png" alt="image-20190218162129833"/></p>

<p><strong>垂直拆分的优点是：</strong></p>

<p>1）可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)；</p>

<p>2）可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起；</p>

<p>3）数据维护简单。</p>

<p><strong>缺点是：</strong></p>

<p>1）主键出现冗余，需要管理冗余列；</p>

<p>2）会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力；</p>

<p>3）依然存在单表数据量过大的问题（需要水平拆分）；</p>

<p>4）事务处理复杂。</p>

<h2 id="toc_5">水平拆分</h2>

<h4 id="toc_6">概述</h4>

<p>水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表。</p>

<p>库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决。</p>

<p><strong>前面垂直拆分的用户表如果进行水平拆分，结果是：</strong></p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218162027582.png" alt="image-20190218162027582"/></p>

<p>实际情况中往往会是垂直拆分和水平拆分的结合，即将Users_A_M和Users_N_Z再拆成Users和UserExtras，这样一共四张表。</p>

<p><strong>水平拆分的优点是:</strong></p>

<p>1）不存在单库大数据和高并发的性能瓶颈；</p>

<p>2）应用端改造较少；</p>

<p>3）提高了系统的稳定性和负载能力。</p>

<p><strong>缺点是：</strong></p>

<p>1）分片事务一致性难以解决；</p>

<p>2）跨节点Join性能差，逻辑复杂；</p>

<p>3）数据多次扩展难度跟维护量极大。</p>

<h4 id="toc_7">分片原则</h4>

<p>1）能不分就不分，参考“单表优化”；</p>

<p>2）分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量；</p>

<p>3）分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容；</p>

<p>4）尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题；</p>

<p>5）查询条件尽量优化，尽量避免Select * 的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引；</p>

<p>6）通过数据冗余和表分区赖降低跨库Join的可能。</p>

<p>这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p>

<p>总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。</p>

<h4 id="toc_8">解决方案</h4>

<p>由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。</p>

<p>*<strong>【客户端架构】：*</strong></p>

<p>通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现。</p>

<p>这是一个客户端架构的例子：</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218161958669.png" alt="image-20190218161958669"/></p>

<p>可以看到分片的实现是和应用服务器在一起的，通过修改Spring JDBC层来实现</p>

<p>客户端架构的优点是：</p>

<p>1）应用直连数据库，降低外围系统依赖所带来的宕机风险；</p>

<p>2）集成成本低，无需额外运维的组件。</p>

<p>缺点是：</p>

<p>1）限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心；</p>

<p>2）将分片逻辑的压力放在应用服务器上，造成额外风险。</p>

<p>*<strong>【代理架构】：*</strong></p>

<p>通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件。</p>

<p>这是一个代理架构的例子：</p>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218161928361.png" alt="image-20190218161928361"/></p>

<p>代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理。</p>

<p>代理架构的优点是：</p>

<p>能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强；</p>

<p>对于应用服务器透明且没有增加任何额外负载。</p>

<p>缺点是：</p>

<p>需部署和运维独立的代理中间件，成本高；<br/>
应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险。</p>

<h4 id="toc_9">各方案比较</h4>

<p><img src="/Users/sangkuofeng/Library/Application%20Support/typora-user-images/image-20190218161825489.png" alt="image-20190218161825489"/></p>

<p><strong>如此多的方案，如何进行选择？可以按以下思路来考虑：</strong></p>

<p>1）确定是使用代理架构还是客户端架构。中小型规模或是比较简单的场景倾向于选择客户端架构，复杂场景或大规模系统倾向选择代理架构；<br/>
2）具体功能是否满足，比如需要跨节点ORDER BY，那么支持该功能的优先考虑；<br/>
3）不考虑一年内没有更新的产品，说明开发停滞，甚至无人维护和技术支持；<br/>
4）最好按大公司-&gt;社区-&gt;小公司-&gt;个人这样的出品方顺序来选择；<br/>
5）选择口碑较好的，比如github星数、使用者数量质量和使用者反馈；<br/>
6）开源的优先，往往项目有特殊需求可能需要改动源代码。</p>

<p><strong>按照上述思路，推荐以下选择：</strong></p>

<p>1）客户端架构：ShardingJDBC；<br/>
2）代理架构：MyCat或者Atlas。</p>

<h2 id="toc_10">兼容MySQL且可水平扩展的数据库</h2>

<p><strong>目前也有一些开源数据库兼容MySQL协议，如：</strong></p>

<p>1）<a href="https://github.com/pingcap/tidb">TiDB</a>；<br/>
2）<a href="http://www.cubrid.org/">Cubrid</a>。<br/>
但其工业品质和MySQL尚有差距，且需要较大的运维投入。</p>

<p><strong>如果想将原始的MySQL迁移到可水平扩展的新数据库中，可以考虑一些云数据库：</strong></p>

<p>1）阿里云<a href="https://cn.aliyun.com/product/petadata/?spm=5176.7960203.237031.38.cAzx5r">PetaData</a>；<br/>
2）阿里云<a href="https://cn.aliyun.com/product/oceanbase?spm=5176.7960203.237031.40.cAzx5r">OceanBase</a>；<br/>
3）腾讯云<a href="https://cloud.tencent.com/product/dcdb_for_tdsql">DCDB</a>。</p>

<p>10、NoSQL<br/>
在MySQL上做Sharding是一种戴着镣铐的跳舞，事实上很多大表本身对MySQL这种RDBMS的需求并不大，并不要求ACID，可以考虑将这些表迁移到NoSQL，彻底解决水平扩展问题。</p>

<p><strong>例如：</strong></p>

<p>1）日志类、监控类、统计类数据；<br/>
2）非结构化或弱结构化数据；<br/>
3）对事务要求不强，且无太多关联操作的数据。</p>

<ul>
<li>
<a href="#toc_0">单表优化方案</a>
</li>
<li>
<a href="#toc_1">读写分离</a>
</li>
<li>
<a href="#toc_2">缓存</a>
</li>
<li>
<a href="#toc_3">表分区</a>
</li>
<li>
<a href="#toc_4">垂直拆分</a>
</li>
<li>
<a href="#toc_5">水平拆分</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_6">概述</a>
</li>
<li>
<a href="#toc_7">分片原则</a>
</li>
<li>
<a href="#toc_8">解决方案</a>
</li>
<li>
<a href="#toc_9">各方案比较</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_10">兼容MySQL且可水平扩展的数据库</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java知识点]]></title>
    <link href="https://books.sangkf.cn/15510645390936.html"/>
    <updated>2019-02-25T11:15:39+08:00</updated>
    <id>https://books.sangkf.cn/15510645390936.html</id>
    <content type="html"><![CDATA[
<p>列举一些Java常用的知识点<br/>
<span id="more"></span><!-- more --></p>

<p><strong>基础篇</strong><br/>
<strong>01面向对象</strong><br/>
<strong>→ 什么是面向对象</strong><br/>
面向对象、面向过程</p>

<p>面向对象的三大基本特征和五大基本原则<br/>
<strong>→ 平台无关性</strong><br/>
Java 如何实现的平台无关</p>

<p>JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）</p>

<p><strong>→ 值传递</strong><br/>
值传递、引用传递</p>

<p>为什么说 Java 中只有值传递</p>

<p><strong>→ 封装、继承、多态</strong><br/>
什么是多态、方法重写与重载</p>

<p>Java 的继承与实现</p>

<p>构造函数与默认构造函数</p>

<p>类变量、成员变量和局部变量</p>

<p>成员变量和方法作用域</p>

<p><strong>02 Java 基础知识</strong></p>

<p><strong>→ 基本数据类型</strong><br/>
7 种基本数据类型：整型、浮点型、布尔型、字符型</p>

<p>整型中 byte、short、int、long 的取值范围</p>

<p>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？</p>

<p><strong>→ 自动拆装箱</strong><br/>
什么是包装类型、什么是基本类型、什么是自动拆装箱</p>

<p>Integer 的缓存机制</p>

<p><strong>→ String</strong><br/>
字符串的不可变性</p>

<p>JDK 6 和 JDK 7 中 substring 的原理及区别、</p>

<p>replaceFirst、replaceAll、replace 区别、</p>

<p>String 对“+”的重载、字符串拼接的几种方式和区别</p>

<p>String.valueOf 和 Integer.toString 的区别、</p>

<p>switch 对 String 的支持</p>

<p>字符串池、常量池（运行时常量池、Class 常量池）、intern</p>

<p><strong>→ 熟悉 Java 中各种关键字</strong><br/>
transient、instanceof、final、static、volatile、synchronized、const 原理及用法</p>

<p><strong>→ 集合类</strong><br/>
常用集合类的使用、ArrayList 和 LinkedList 和 Vector 的区别 、SynchronizedList 和 Vector 的区别、HashMap、HashTable、ConcurrentHashMap 区别、</p>

<p>Set 和 List 区别？Set 如何保证元素不重复？</p>

<p>Java 8 中 stream 相关用法、apache 集合处理工具类的使用、不同版本的 JDK 中 HashMap 的实现的区别以及原因</p>

<p>Collection 和 Collections 区别</p>

<p>Arrays.asList 获得的 List 使用时需要注意什么</p>

<p>Enumeration 和 Iterator 区别</p>

<p>fail-fast 和 fail-safe</p>

<p>CopyOnWriteArrayList、ConcurrentSkipListMap</p>

<p><strong>→ 枚举</strong><br/>
枚举的用法、枚举的实现、枚举与单例、Enum 类</p>

<p>Java 枚举如何比较</p>

<p>switch 对枚举的支持</p>

<p>枚举的序列化如何实现</p>

<p>枚举的线程安全性问题</p>

<p><strong>→ IO</strong><br/>
字符流、字节流、输入流、输出流、</p>

<p>同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型</p>

<p>BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty</p>

<p><strong>→ 反射</strong><br/>
反射与工厂模式、反射有什么用</p>

<p>Class 类、java.lang.reflect.*</p>

<p><strong>→ 动态代理</strong><br/>
静态代理、动态代理</p>

<p>动态代理和反射的关系</p>

<p>动态代理的几种实现方式</p>

<p>AOP</p>

<p><strong>→ 序列化</strong><br/>
什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全</p>

<p><strong>→ 注解</strong><br/>
元注解、自定义注解、Java 中常用注解使用、注解与反射的结合</p>

<p>Spring 常用注解</p>

<p><strong>→ JMS</strong><br/>
什么是 Java 消息服务、JMS 消息传送模型</p>

<p><strong>→ JMX</strong><br/>
java.lang.management.<em>、 javax.management.</em></p>

<p><strong>→ 泛型</strong><br/>
泛型与继承、类型擦除、泛型中 KTVE? object 等的含义、泛型各种用法</p>

<p>限定通配符和非限定通配符、上下界限定符 extends 和 super</p>

<p>List</p>

<p>List&lt;?&gt; 和 List</p>

<p><strong>→ 单元测试</strong><br/>
junit、mock、mockito、内存数据库（h2）</p>

<p><strong>→ 正则表达式</strong><br/>
java.lang.util.regex.*</p>

<p><strong>→ 常用的 Java 工具库</strong><br/>
commons.lang、commons.*...、 guava-libraries、 netty</p>

<p><strong>→ API &amp; SPI</strong><br/>
API、API 和 SPI 的关系和区别</p>

<p>如何定义 SPI、SPI 的实现原理</p>

<p><strong>→ 异常</strong><br/>
异常类型、正确处理异常、自定义异常</p>

<p>Error 和 Exception</p>

<p>异常链、try-with-resources</p>

<p>finally 和 return 的执行顺序</p>

<p><strong>→ 时间处理</strong><br/>
时区、冬令时和夏令时、时间戳、Java 中时间 API</p>

<p>格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系</p>

<p>SimpleDateFormat 的线程安全性问题</p>

<p>Java 8 中的时间处理</p>

<p>如何在东八区的计算机上获取美国时间</p>

<p><strong>→ 编码方式</strong><br/>
Unicode、有了 Unicode 为啥还需要 UTF-8</p>

<p>GBK、GB2312、GB18030 之间的区别</p>

<p>UTF8、UTF16、UTF32 区别</p>

<p>URL 编解码、Big Endian 和 Little Endian</p>

<p>如何解决乱码问题</p>

<p><strong>→ 语法糖</strong><br/>
Java 中语法糖原理、解语法糖</p>

<p>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式</p>

<p><strong>03阅读源代码</strong></p>

<p>String、Integer、Long、Enum、</p>

<p>BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、</p>

<p>ArrayList &amp; LinkedList、</p>

<p>HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet</p>

<p><strong>04 Java 并发编程</strong></p>

<p><strong>→ 并发与并行</strong><br/>
什么是并发、什么是并行</p>

<p>并发与并行的区别</p>

<p><strong>→ 什么是线程，与进程的区别</strong><br/>
线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程</p>

<p>线程与进程的区别</p>

<p><strong>→ 线程池</strong><br/>
自己设计线程池、submit() 和 execute()、线程池原理</p>

<p>为什么不允许使用 Executors 创建线程池</p>

<p><strong>→ 线程安全</strong><br/>
死锁、死锁如何排查、线程安全和内存模型的关系</p>

<p><strong>→ 锁</strong><br/>
CAS、乐观锁与****悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、</p>

<p>锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁</p>

<p><strong>→ 死锁</strong><br/>
什么是死锁</p>

<p>死锁如何解决</p>

<p><strong>→ synchronized</strong><br/>
synchronized 是如何实现的？</p>

<p>synchronized 和 lock 之间关系、不使用 synchronized 如何实现一个线程安全的单例</p>

<p>synchronized 和原子性、可见性和有序性之间的关系</p>

<p><strong>→ volatile</strong><br/>
happens-before、内存屏障、编译器指令重排和 CPU 指令重</p>

<p>volatile 的实现原理</p>

<p>volatile 和原子性、可见性和有序性之间的关系</p>

<p>有了 symchronized 为什么还需要 volatile</p>

<p><strong>→ sleep 和 wait</strong><br/>
<strong>→ wait 和 notify</strong><br/>
<strong>→ notify 和 notifyAll</strong><br/>
<strong>→ ThreadLocal</strong><br/>
<strong>→ 写一个死锁的程序</strong><br/>
<strong>→ 写代码来解决生产者消费者问题</strong><br/>
<strong>→ 并方包</strong><br/>
Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、ConcurrentHashMap、Executors</p>

<p><strong>2底层篇</strong></p>

<p><strong>01JVM</strong></p>

<p><strong>→ JVM 内存结构</strong></p>

<p>class 文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、</p>

<p>堆和栈区别</p>

<p>Java 中的对象一定在堆上分配吗？</p>

<p><strong>→ Java 内存模型</strong><br/>
计算机内存模型、缓存一致性、MESI 协议</p>

<p>可见性、原子性、顺序性、happens-before、</p>

<p>内存屏障、synchronized、volatile、final、锁</p>

<p><strong>→ 垃圾回收</strong><br/>
GC 算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收</p>

<p>GC 参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon）</p>

<p><strong>→ JVM 参数及调优</strong><br/>
-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、</p>

<p>-XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold</p>

<p><strong>→ Java 对象模型</strong><br/>
oop-klass、对象头</p>

<p><strong>→ HotSpot</strong><br/>
即时编译器、编译优化</p>

<p><strong>→ 虚拟机性能监控与故障处理工具</strong><br/>
jps, jstack, jmap, jstat, jconsole, jinfo, jhat, javap, btrace, TProfiler</p>

<p>Arthas</p>

<p><strong>02 类加载机制</strong></p>

<p>classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）</p>

<p><strong>03 编译与反编译</strong></p>

<p>什么是编译（前端编译、后端编译）、什么是反编译</p>

<p>JIT、JIT 优化（逃逸分析、栈上分配、标量替换、锁优化）</p>

<p>编译工具：javac</p>

<p>反编译工具：javap 、jad 、CRF</p>

<p><strong>3进阶篇</strong></p>

<p><strong>01 Java 底层知识</strong></p>

<p><strong>→ 字节码、class 文件格式</strong><br/>
<strong>→ CPU 缓存，L1，L2，L3 和伪共享</strong><br/>
<strong>→ 尾递归</strong><br/>
<strong>→ 位运算</strong><br/>
用位运算实现加、减、乘、除、取余</p>

<p><strong>02 设计模式</strong><br/>
设计模式的六大原则：</p>

<p>开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle）</p>

<p>接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle）</p>

<p><strong>→ 了解 23 种设计模式</strong></p>

<p>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</p>

<p>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p>

<p>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</p>

<p><strong>→ 会使用常用设计模式</strong><br/>
单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁</p>

<p>工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会</p>

<p><strong>→ 不用 synchronized 和 lock，实现线程安全的单例模式</strong><br/>
<strong>→ 实现 AOP</strong><br/>
<strong>→ 实现 IOC</strong><br/>
<strong>→ nio 和 reactor 设计模式</strong></p>

<p><strong>03 网络编程知识</strong></p>

<p><strong>→ tcp、udp、http、https 等常用协议</strong></p>

<p>三次握手与四次关闭、流量控制和拥塞控制、OSI 七层模型、tcp 粘包与拆包</p>

<p><strong>→ http/1.0 http/1.1 http/2 之前的区别</strong><br/>
http 中 get 和 post 区别</p>

<p>常见的 web 请求返回的状态码</p>

<p>404、302、301、500分别代表什么</p>

<p><strong>→ http/3</strong><br/>
<strong>→ Java RMI，Socket，HttpClient</strong><br/>
<strong>→ cookie 与 session</strong><br/>
cookie 被禁用，如何实现 session</p>

<p><strong>→ 用 Java 写一个简单的静态文件的 HTTP 服务器</strong><br/>
<strong>→ 了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器</strong><br/>
<strong>→ 用 Java 实现 FTP、SMTP 协议</strong><br/>
<strong>→ 进程间通讯的方式</strong><br/>
<strong>→ 什么是 CDN？如果实现？</strong><br/>
<strong>→ DNS</strong><br/>
什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等<br/>
域名解析、根域名服务器</p>

<p>DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS</p>

<p><strong>→ 反向代理</strong><br/>
正向代理、反向代理</p>

<p>反向代理服务器</p>

<p><strong>04 框架知识</strong></p>

<p><strong>→ Servlet</strong></p>

<p>生命周期</p>

<p>线程安全问题</p>

<p>filter 和 listener</p>

<p>web.xml 中常用配置及作用</p>

<p><strong>→ Hibernate</strong><br/>
什么是 OR Mapping</p>

<p>Hibernate 的懒加载<br/>
Hibernate 的缓存机制</p>

<p>Hibernate / Ibatis / MyBatis 之间的区别</p>

<p><strong>→ Spring</strong> <br/>
Bean 的初始化<br/>
AOP 原理<br/>
实现 Spring 的IOC<br/>
Spring 四种依赖注入方式<br/>
<strong>→ Spring MVC</strong><br/>
什么是 MVC</p>

<p>Spring mvc 与 Struts mvc 的区别</p>

<p><strong>→ Spring Boot</strong><br/>
Spring Boot 2.0、起步依赖、自动配置、</p>

<p>Spring Boot 的 starter 原理，自己实现一个 starter</p>

<p><strong>→ Spring Security</strong><br/>
<strong>→ Spring Cloud</strong><br/>
服务发现与注册：Eureka、Zookeeper、Consul</p>

<p>负载均衡：Feign、Spring Cloud Loadbalance</p>

<p>服务配置：Spring Cloud Config</p>

<p>服务限流与熔断：Hystrix</p>

<p>服务链路追踪：Dapper</p>

<p>服务网关、安全、消息</p>

<p><strong>05 应用服务器知识</strong></p>

<p><strong>→ JBoss</strong><br/>
<strong>→ tomcat</strong><br/>
<strong>→ jetty</strong><br/>
<strong>→ Weblogic</strong></p>

<p><strong>06 工具</strong></p>

<p><strong>→ git &amp; svn</strong><br/>
<strong>→ maven &amp; gradle</strong><br/>
<strong>→ Intellij IDEA</strong><br/>
常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat</p>

<p>Lombok plugin、.ignore、Mybatis plugin</p>

<p><strong>4高级篇</strong></p>

<p><strong>01 新技术</strong></p>

<p><strong>→ Java 8</strong></p>

<p>lambda 表达式、Stream API、时间 API</p>

<p><strong>→ Java 9</strong><br/>
Jigsaw、Jshell、Reactive Streams</p>

<p><strong>→ Java 10</strong><br/>
局部变量类型推断、G1 的并行 Full GC、ThreadLocal 握手机制</p>

<p><strong>→ Java 11</strong><br/>
ZGC、Epsilon、增强 var</p>

<p><strong>→ Spring 5</strong><br/>
响应式编程</p>

<p><strong>→ Spring Boot 2.0</strong><br/>
<strong>→ HTTP/2</strong><br/>
<strong>→ HTTP/3</strong></p>

<p><strong>02 性能优化</strong></p>

<p>使用单例、使用 Future 模式、使用线程池</p>

<p>选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存</p>

<p><strong>03 线上问题分析</strong></p>

<p><strong>→ dump 获取</strong></p>

<p>线程 Dump、内存 Dump、gc 情况</p>

<p><strong>→ dump 分析</strong><br/>
分析死锁、分析内存泄露</p>

<p><strong>→ dump 分析及获取工具</strong><br/>
jstack、jstat、jmap、jhat、Arthas</p>

<p><strong>→ 自己编写各种 outofmemory，stackoverflow 程序</strong><br/>
HeapOutOfMemory、 Young OutOfMemory、</p>

<p>MethodArea OutOfMemory、ConstantPool OutOfMemory、</p>

<p>DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow</p>

<p><strong>→ Arthas</strong><br/>
jvm 相关、class/classloader 相关、monitor/watch/trace 相关、</p>

<p>options、管道、后台异步任务</p>

<p>文档：<a href="https://alibaba.github.io/arthas/advanced-use.html">https://alibaba.github.io/arthas/advanced-use.html</a></p>

<p><strong>→ 常见问题解决思路</strong><br/>
内存溢出、线程死锁、类加载冲突</p>

<p><strong>→ 使用工具尝试解决以下问题，并写下总结</strong><br/>
当一个 Java 程序响应很慢时如何查找问题</p>

<p>当一个 Java 程序频繁 FullGC 时如何解决问题</p>

<p>如何查看垃圾回收日志</p>

<p>当一个 Java 应用发生 OutOfMemory 时该如何解决</p>

<p>如何判断是否出现死锁</p>

<p>如何判断是否存在内存泄露</p>

<p>使用 Arthas 快速排查 Spring Boot 应用404/401问题</p>

<p>使用 Arthas 排查线上应用日志打满问题</p>

<p>利用 Arthas 排查 Spring Boot 应用 NoSuchMethodError</p>

<p><strong>04编译原理知识</strong></p>

<p><strong>→ 编译与反编译</strong><br/>
<strong>→ Java 代码的编译与反编译</strong><br/>
<strong>→ Java 的反编译工具</strong><br/>
javap 、jad 、CRF</p>

<p><strong>→ 即时编译器</strong><br/>
<strong>→ 编译过程</strong><br/>
词法分析，语法分析（LL 算法，递归下降算法，LR 算法）<br/>
语义分析，运行时环境，中间代码，代码生成，代码优化</p>

<p><strong>05 操作系统知识</strong></p>

<p><strong>→ Linux 的常用命令</strong><br/>
<strong>→ 进程间通信</strong><br/>
<strong>→ 进程同步</strong><br/>
生产者消费者问题、哲学家就餐问题、读者写者问题</p>

<p><strong>→ 缓冲区溢出</strong><br/>
<strong>→ 分段和分页</strong><br/>
<strong>→ 虚拟内存与主存</strong><br/>
<strong>→ 虚拟内存管理</strong><br/>
<strong>→ 换页算法</strong></p>

<p><strong>06 数据库知识</strong></p>

<p><strong>→ MySQL 执行引擎</strong><br/>
<strong>→ MySQL 执行计划</strong><br/>
如何查看执行计划，如何根据执行计划进行 SQL 优化</p>

<p><strong>→ 索引</strong><br/>
Hash 索引、B 树索引（B+树、和B树、R树）</p>

<p>普通索引、唯一索引</p>

<p>覆盖索引、最左前缀原则、索引下推</p>

<p><strong>→ SQL 优化</strong><br/>
<strong>→ 数据库事务和隔离级别</strong><br/>
事务的隔离级别、事务能不能实现锁的功能</p>

<p><strong>→ 数据库锁</strong><br/>
行锁、表锁、使用数据库锁实现乐观锁、</p>

<p><strong>→ 连接</strong><br/>
内连接，左连接，右连接</p>

<p><strong>→ 数据库主备搭建</strong><br/>
<strong>→ binlog</strong><br/>
<strong>→ redolog</strong><br/>
<strong>→ 内存数据库</strong><br/>
h2</p>

<p><strong>→ 分库分表</strong><br/>
<strong>→ 读写分离</strong><br/>
<strong>→ 常用的 NoSql 数据库</strong><br/>
redis、memcached</p>

<p><strong>→ 分别使用数据库锁、NoSql 实现分布式锁</strong><br/>
<strong>→ 性能调优</strong><br/>
<strong>→ 数据库连接池</strong></p>

<p><strong>07 数据结构与算法知识</strong></p>

<p><strong>→ 简单的数据结构</strong></p>

<p>栈、队列、链表、数组、哈希表、</p>

<p>栈和队列的相同和不同之处</p>

<p>栈通常采用的两种存储结构</p>

<p><strong>→ 树</strong><br/>
二叉树、字典树、平衡树、排序树、</p>

<p>B 树、B+ 树、R 树、多路树、红黑树</p>

<p><strong>→ 堆</strong><br/>
大根堆、小根堆</p>

<p><strong>→ 图</strong><br/>
有向图、无向图、拓扑</p>

<p><strong>→ 排序算法</strong><br/>
稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序</p>

<p>不稳定的排序：选择排序、希尔排序、Clover 排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序</p>

<p>各种排序算法和时间复杂度</p>

<p><strong>→ 两个栈实现队列，和两个队列实现栈</strong><br/>
<strong>→ 深度优先和广度优先搜索</strong><br/>
<strong>→ 全排列、贪心算法、KMP 算法、hash 算法</strong><br/>
<strong>→ 海量数据处理</strong><br/>
分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce 等。</p>

<p><strong>08大数据知识</strong></p>

<p><strong>→ Zookeeper</strong></p>

<p>基本概念、常见用法</p>

<p><strong>→ Solr，Lucene，ElasticSearch</strong><br/>
在 linux 上部署 solr，solrcloud，新增、删除、查询索引</p>

<p><strong>→ Storm，流式计算，了解 Spark，S4</strong><br/>
在 linux 上部署 storm，用 zookeeper 做协调，运行 storm hello world，local 和 remote 模式运行调试 storm topology。</p>

<p><strong>→ Hadoop，离线计算</strong><br/>
HDFS、MapReduce</p>

<p><strong>→ 分布式日志收集 flume，kafka，logstash</strong><br/>
<strong>→ 数据挖掘，mahout</strong></p>

<p><strong>09 网络安全知识</strong></p>

<p><strong>→ XSS</strong></p>

<p>XSS 的防御</p>

<p><strong>→ CSRF</strong><br/>
<strong>→ 注入攻击</strong><br/>
SQL 注入、XML 注入、CRLF 注入</p>

<p><strong>→ 文件上传漏洞</strong><br/>
<strong>→ 加密与解密</strong><br/>
对称加密、非对称加密、哈希算法、加盐哈希算法</p>

<p>MD5，SHA1、DES、AES、RSA、DSA</p>

<p>彩虹表</p>

<p><strong>→ DDOS攻击</strong><br/>
DOS 攻击、DDOS 攻击</p>

<p>memcached 为什么可以导致 DDos 攻击、什么是反射型 DDoS</p>

<p>如何通过 Hash 碰撞进行 DOS 攻击</p>

<p><strong>→ SSL、TLS，HTTPS</strong><br/>
<strong>→ 用 openssl 签一个证书部署到 apache 或 nginx</strong></p>

<p><strong>5架构篇</strong></p>

<p><strong>01分布式</strong></p>

<p>数据一致性、服务治理、服务降级</p>

<p><strong>→ 分布式事务</strong></p>

<p>2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC</p>

<p><strong>→ Dubbo</strong><br/>
服务注册、服务发现，服务治理</p>
<http://dubbo.apache.org/zh-cn/>
<p><strong>→ 分布式数据库</strong><br/>
怎样打造一个分布式数据库、什么时候需要分布式数据库、</p>

<p>mycat、otter、HBase</p>

<p><strong>→ 分布式文件系统</strong><br/>
mfs、fastdfs</p>

<p><strong>→ 分布式缓存</strong><br/>
缓存一致性、缓存命中率、缓存冗余</p>

<p><strong>→ 限流降级</strong><br/>
Hystrix、Sentinal</p>

<p><strong>→ 算法</strong><br/>
共识算法、Raft 协议、Paxos 算法与 Raft 算法、</p>

<p>拜占庭问题与算法、2PC、3PC</p>

<p><strong>02 微服务</strong></p>

<p>SOA、康威定律</p>

<p><strong>→ ServiceMesh</strong><br/>
sidecar</p>

<p><strong>→ Docker &amp; Kubernets</strong><br/>
<strong>→ Spring Boot</strong><br/>
<strong>→ Spring Cloud</strong></p>

<p><strong>03 高并发</strong></p>

<p><strong>→ 分库分表</strong><br/>
<strong>→ CDN 技术</strong><br/>
<strong>→ 消息队列</strong><br/>
ActiveMQ</p>

<p><strong>04 监控</strong></p>

<p><strong>→ 监控什么</strong></p>

<p>CPU、内存、磁盘 I/O、网络 I/O 等</p>

<p><strong>→ 监控手段</strong><br/>
进程监控、语义监控、机器资源监控、数据波动</p>

<p><strong>→ 监控数据采集</strong><br/>
日志、埋点</p>

<p><strong>→ Dapper</strong></p>

<p><strong>05 负载均衡</strong></p>

<p>tomcat 负载均衡、Nginx 负载均衡</p>

<p>四层负载均衡、七层负载均衡</p>

<p><strong>06 DNS</strong></p>

<p>DNS 原理、DNS 的设计</p>

<p><strong>07 CDN</strong></p>

<p>数据一致性</p>

<p><strong>6扩展篇</strong></p>

<p><strong>01 云计算</strong></p>

<p>IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess</p>

<p><strong>02 搜索引擎</strong></p>

<p>Solr、Lucene、Nutch、Elasticsearch</p>

<p><strong>03权限管理</strong></p>

<p>Shiro</p>

<p><strong>04 区块链</strong></p>

<p>哈希算法、Merkle 树、公钥密码算法、共识算法、</p>

<p>Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名</p>

<p><strong>→ 比特币</strong><br/>
挖矿、共识机制、闪电网络、侧链、热点问题、分叉</p>

<p><strong>→ 以太坊</strong><br/>
<strong>→ 超级账本</strong></p>

<p><strong>05人工智能</strong></p>

<p>数学基础、机器学习、人工神经网络、深度学习、应用场景。</p>

<p><strong>→ 常用框架</strong><br/>
TensorFlow、DeepLearning4J</p>

<p><strong>06 loT</strong></p>

<p><strong>07 量子计算</strong></p>

<p><strong>08 AR &amp; VR</strong></p>

<p><strong>09其他语言</strong></p>

<p>Groovy、Python、Go、NodeJs、Swift、Rust</p>

<p><strong>7推荐书籍</strong></p>

<p>《深入理解 Java 虚拟机》 <br/>
《Effective Java》 <br/>
《深入分析 Java Web 技术内幕》 <br/>
《大型网站技术架构》 <br/>
《代码整洁之道》 <br/>
《架构整洁之道》 <br/>
《Head First 设计模式》 <br/>
《maven 实战》 <br/>
《区块链原理、设计与应用》 <br/>
《Java 并发编程实战》 <br/>
《鸟哥的 Linux 私房菜》 <br/>
《从Paxos 到 Zookeeper》 <br/>
《架构即未来》</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAVA8新特性]]></title>
    <link href="https://books.sangkf.cn/15510645099182.html"/>
    <updated>2019-02-25T11:15:09+08:00</updated>
    <id>https://books.sangkf.cn/15510645099182.html</id>
    <content type="html"><![CDATA[
<p>原文地址 <a href="https://www.cnblogs.com/huyunfan/p/7456535.html">https://www.cnblogs.com/huyunfan/p/7456535.html</a></p>

<ul>
<li><p><strong>default拓展方法</strong><br/>
<span id="more"></span><!-- more --><br/>
default关键字为接口声明添加非抽象方法的实现,也称为拓展方法</p>
<pre><code class="language-java">public interface Formula {
  void doSomething();<br/>
  default void before() {<br/>
      System.out.println(&quot;我是拓展方法&quot;);<br/>
  }<br/>
}<br/>
public class FormulaService implements Formula {<br/>
  @Override<br/>
  public void doSomething() {<br/>
      before();<br/>
      System.out.println(&quot;我是override方法&quot;);<br/>
  }<br/>
}
</code></pre></li>
<li><p><strong>Lambda表达式</strong></p>
<p>java8引入函数式编程，Lambda则是函数式编程的基础。</p>
<pre><code class="language-java">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
// java8之前<br/>
Collections.sort(list, new Comparator&lt;String&gt;(){<br/>
  @Override<br/>
  public int compare(String o1, String o2) {<br/>
      return o1.compareTo(o2);<br/>
  }<br/>
});<br/>
// lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt; {<br/>
          return o2.compareTo(o1);<br/>
});<br/>
// 简洁lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt;  o2.compareTo(o1));<br/>
// 更简洁lambda<br/>
Collections.sort(list, (o1, o2) -&gt;  o2.compareTo(o1));<br/>
// 也可以这样写<br/>
Collections.sort(list, Comparator.comparing(String::toString));
</code></pre></li>
<li><p><strong>函数式接口</strong></p>
<p>一个函数式接口有且只能有一个抽象方法申明，其中该注意的是 @FunctionalInterface 注解，此时如果在接口中定义了第二个抽象方法，编译器将会抛出异常。当然如果不加该注解也不是不行，如果接口中有多个抽象方法，而你又使用了lambda表达式，则在调用处会抛出异常。</p>
<pre><code class="language-java">@FunctionalInterface
public interface Formula&lt;F,T&gt;{<br/>
  T convert(F var1);<br/>
}<br/>
Formula&lt;String,Integer&gt; function = (var1 -&gt; Integer.valueOf(var1));<br/>
Integer var2 = function.convert(&quot;1000&quot;); 
</code></pre></li>
<li><p><strong>方法和构造函数引用</strong></p>
<p>方法引用的标准语法是 <code>类名:方法名</code></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用静态方法</td>
<td>targetClass :: staticMethodName</td>
</tr>
<tr>
<td>引用某个对象的实例方法</td>
<td>targetClass :: instanceMethodName</td>
</tr>
<tr>
<td>引用某个类型的任意对象的实例方法</td>
<td>targetType :: methodName</td>
</tr>
<tr>
<td>引用构造方法</td>
<td>className :: new</td>
</tr>
</tbody>
</table></li>
</ul>

<ol>
<li><p><strong>引用静态方法</strong></p>
<pre><code class="language-java">Formula&lt;String,Integer&gt; function = (Integer::valueOf);
Integer var2 = function.convert(&quot;1000&quot;);
</code></pre></li>
<li><p><strong>引用某个类型的任意对象的实例方法</strong></p>
<pre><code class="language-java">public static void main(String[] args) {
  String[] array = {&quot;贱明&quot;, &quot;学友&quot;};<br/>
  Arrays.sort(array, String::compareTo);<br/>
}
</code></pre></li>
<li><p><strong>引用构造方法</strong></p>
<pre><code class="language-java">// 定义工厂
interface PersonFactory&lt;P extends Person&gt;{<br/>
   P create(String name);<br/>
}<br/>
// Person类的构造方法<br/>
public Person(String name) {<br/>
   this.name = name;<br/>
}<br/>
// 创建<br/>
PersonFactory&lt;Person&gt; factory = Person::new;<br/>
factory.create(&quot;贱明&quot;);
</code></pre></li>
</ol>

<ul>
<li><p><strong>Lambda的范围</strong></p>
<p>lambda可以访问局部对应的外部区域的局部final变量，以及成员变量和静态变量。</p>
<ol>
<li><p><strong>访问成员变量</strong></p>
<pre><code class="language-java">public void doSomething(){
 final String p1 = &quot;贱明&quot;;<br/>
 final String p2 = &quot;学友&quot;;<br/>
 Formula function = (person1, person2) -&gt; p1.compareTo(p2);<br/>
}
</code></pre>
<p>与java8以下版本不同的是，p1 p2你可以不修饰成final 也不会报错，但是如果你想修改他们，编译器则会告诉你这是不被允许的。</p></li>
<li><p><strong>访问成员变量和静态变量</strong></p>
<pre><code class="language-java">public void doSomething(){;
Formula function = (person1, person2) -&gt;{<br/>
    dehua = &quot;贱明&quot;;<br/>
    xueyou=&quot;学友&quot;;<br/>
    return dehua.compareTo(xueyou);<br/>
};<br/>
}
</code></pre></li>
</ol></li>
<li><p><strong>内置函数式接口</strong></p>
<p>​     java8 api中提供了很多内置函数式接口，而且有些接口其实在Google Guava中已经实现了，很大程  度的降低了程序员的工作负担。</p>
<ol>
<li><p><strong>Predicates</strong><br/>
Predicate是一个布尔类型的函数，该函数只有一个输入参数，他包含了多种默认实现。</p>
<pre><code class="language-java">public static void main(String[] args) {
Predicate&lt;String&gt; predicate = (s) -&gt; s.contains(&quot;贱明&quot;);<br/>
String var1 = &quot;牛贱明&quot;;<br/>
predicate.test(var1);              // true<br/>
predicate.negate().test(var1);     // false<br/>
Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;<br/>
Predicate&lt;Boolean&gt; isNull = Objects::isNull;<br/>
Predicate&lt;String&gt; isEmpty = String::isEmpty;<br/>
Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();<br/>
isNotEmpty.and(isEmpty).test(var1);<br/>
}
</code></pre></li>
<li><p><strong>Functions</strong></p>
<p>Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起</p>
<pre><code class="language-java">public static void main(String[] args) {
Function&lt;String, Integer&gt; toInteger = Integer::valueOf;<br/>
Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);<br/>
System.out.println(toInteger.apply(&quot;123&quot;));<br/>
System.out.println(backToString.apply(&quot;123&quot;));<br/>
}
</code></pre></li>
<li><p><strong>Suppliers</strong></p>
<p>Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。</p>
<pre><code class="language-java">Supplier&lt;Person&gt; personSupplier = Person::new;
Person p = personSupplier.get();   // new Person
</code></pre></li>
<li><p><strong>Consumers</strong></p>
<p>Consumer代表了在一个输入参数上需要进行的操作。</p>
<pre><code class="language-java">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.getName());
greeter.accept(new Person(&quot;贱明&quot;));
</code></pre></li>
<li><p><strong>Comparators</strong></p>
<p>Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。</p>
<pre><code class="language-java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.getName().compareTo(p2.getName());
Person p1 = new Person(&quot;贱明&quot;);<br/>
Person p2 = new Person(&quot;学友&quot;);<br/>
System.out.println(comparator.compare(p1, p2));             // &gt; 1105<br/>
System.out.println(comparator.reversed().compare(p1, p2));  // &lt; -1105
</code></pre></li>
<li><p><strong>Optionals</strong></p>
<p>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerException产生。<br/>
Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional。</p>
<pre><code class="language-java">Optional&lt;String&gt; optional = Optional.of(&quot;贱明&quot;);
System.out.println(optional.isPresent()); // true      <br/>
System.out.println(optional.get()); // 贱明   <br/>
System.out.println(optional.orElse(&quot;学友&quot;)); // 贱明    <br/>
optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); 
</code></pre></li>
</ol></li>
</ul>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringCloud服务治理，服务注册，服务发现]]></title>
    <link href="https://books.sangkf.cn/15510642705827.html"/>
    <updated>2019-02-25T11:11:10+08:00</updated>
    <id>https://books.sangkf.cn/15510642705827.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">服务治理</h2>

<p>服务治理是微服务架构中最为核心和基础的模块，他主要用来实现各个微服务市里的自动化注册和发现。<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li><p>为什么需要服务治理？微服务没有他会怎样？</p>
<p>​ 在最开始构建微服务系统的时候可能服务并不多，我们可以通过一些静态配置来完成服务的调用。比如，有两个服务A和服务B，其中服务A需要调用服务B来完成一个业务的操作时，为了实现服务B的高可用，不论采用服务端负载均衡还是客户端负载均衡，都需要手工维护服务B的具体实例清单。但是随着业务的发展，系统的功能越来越复杂，相应的微服务应用也不断增加，我们的静态配置会变得越来越难以维护。并且面对不断发展的业务，我们的集群规模，服务的位置，服务的命名等都可能发生变化，如果还是通过手工维护的方式，那么极易发生错误或者命名冲突等问题。同时，对于这类静态内容的维护也必将消耗大量的人力。</p>
<p><u><strong>服务治理框架的实现都是围绕着服务注册与服务发现机制来完成微服务应用实例的自动化管理</strong></u></p></li>
</ul>

<h2 id="toc_1">服务注册</h2>

<p>​   在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，将主机与端口号，版本号，通信协议等一些附加信息告知注册中心，注册中心按照服务名分类组织服务清单。</p>

<p>当这些进程启动，并向注册中心注册自己的服务后，注册中心就会维护类似下面的一个服务清单。另外，服务注册中心还需要以心跳的方式去监测清单中的服务是否可用，如果不可用则需要从服务清单中提出，达到排除故障服务的效果。</p>

<table>
<thead>
<tr>
<th>服务名</th>
<th>位置</th>
</tr>
</thead>

<tbody>
<tr>
<td>服务A</td>
<td>192.168.0.100:8000，192.168.0.101:8000</td>
</tr>
<tr>
<td>服务B</td>
<td>192.168.0.100:9000，192.168.0.101:9000，192.168.0.102:9000</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">服务发现</h2>

<p>​   由于在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务名发起请求调用实现。所以，服务调用方在调用服务提供方接口的时候，并不知道具体的服务实例位置。因此，调用方需要向服务注册中心咨询服务，并获取所有的服务的实例清单，以实现对具体服务实例的访问。</p>

<p>比如，现有服务C希望调用服务A，服务C就向注册中心发起咨询服务的请求，服务注册中心就会将服务A的位置清单返回给服务C。如按上例服务A的的情况，C便获得了服务A的两个可用位置192.168.0.100:8000和192.168.0.101:8000。当服务C要发起调用的时候，便从该清单中以某种轮询策略取出一个位置来进行服务调用，这就是后续我们将会介绍的客户端负载均衡。</p>

<ul>
<li>
<a href="#toc_0">服务治理</a>
</li>
<li>
<a href="#toc_1">服务注册</a>
</li>
<li>
<a href="#toc_2">服务发现</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MarkDown常见图表，流程图书写✍️]]></title>
    <link href="https://books.sangkf.cn/15509800202549.html"/>
    <updated>2019-02-24T11:47:00+08:00</updated>
    <id>https://books.sangkf.cn/15509800202549.html</id>
    <content type="html"><![CDATA[
<p>利用MarkDown书写一些常用的流程图，Echarts图表，数学公式，点图等</p>

<span id="more"></span><!-- more -->

<h3 id="toc_0">mermaid</h3>

<pre><code class="language-mermaid">sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br/&gt;prevail...
    John--&gt;Alice: Great!
    John-&gt;Bob: How about you?
    Bob--&gt;John: Jolly good!
</code></pre>

<p><img src="media/15509800202549/15510632566254.jpg" alt="" style="width:500px;"/></p>

<h3 id="toc_1">dot</h3>

<pre><code class="language-dot"># http://www.graphviz.org/content/cluster
digraph G {

    subgraph cluster_0 {
        style=filled;
        color=lightgrey;
        node [style=filled,color=white];
        a0 -&gt; a1 -&gt; a2 -&gt; a3;
        label = &quot;process #1&quot;;
    }

    subgraph cluster_1 {
        node [style=filled];
        b0 -&gt; b1 -&gt; b2 -&gt; b3;
        label = &quot;process #2&quot;;
        color=blue
    }
    start -&gt; a0;
    start -&gt; b0;
    a1 -&gt; b3;
    b2 -&gt; a3;
    a3 -&gt; a0;
    a3 -&gt; end;
    b3 -&gt; end;

    start [shape=Mdiamond];
    end [shape=Msquare];
}
</code></pre>

<p><img src="media/15509800202549/15510633206455.jpg" alt="" style="width:293px;"/></p>

<h3 id="toc_2">echarts</h3>

<pre><code class="language-echarts">option = {
    xAxis: {
        type: &#39;category&#39;,
        data: [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;]
    },
    yAxis: {
        type: &#39;value&#39;
    },
    series: [{
        data: [820, 932, 901, 934, 1290, 1330, 1320],
        type: &#39;line&#39;
    }]
};
</code></pre>

<p><img src="media/15509800202549/15510633473570.jpg" alt="" style="width:500px;"/></p>

<h3 id="toc_3">顺序图和流程图</h3>

<pre><code class="language-sequence">张三-&gt;李四: 嘿，小四儿, 写博客了没?
Note right of 李四: 李四愣了一下，说：
李四--&gt;张三: 忙得吐血，哪有时间写。
</code></pre>

<pre><code class="language-flow">st=&gt;start: 开始
e=&gt;end: 结束
op=&gt;operation: 我的操作
cond=&gt;condition: 确认？

st-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op
</code></pre>

<p><img src="media/15509800202549/15510633802834.jpg" alt="" style="width:436px;"/></p>

<h3 id="toc_4">LaTeX （MathJax 渲染）</h3>

<pre><code class="language-text">块级公式：
$$  x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$

\\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } } \\]

行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$
</code></pre>

<p><img src="media/15509800202549/15510634028669.jpg" alt="" style="width:500px;"/></p>

<ul>
<li>
<a href="#toc_0">mermaid</a>
</li>
<li>
<a href="#toc_1">dot</a>
</li>
<li>
<a href="#toc_2">echarts</a>
</li>
<li>
<a href="#toc_3">顺序图和流程图</a>
</li>
<li>
<a href="#toc_4">LaTeX （MathJax 渲染）</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 8新特性：新的时间和日期API]]></title>
    <link href="https://books.sangkf.cn/15509784083382.html"/>
    <updated>2019-02-24T11:20:08+08:00</updated>
    <id>https://books.sangkf.cn/15509784083382.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Java 8另一个新增的重要特性就是引入了新的时间和日期API，它们被包含在<code>java.time</code>包中。借助新的时间和日期API可以以更简洁的方法处理时间和日期。<br/>
<span id="more"></span><!-- more --></p>
</blockquote>

<p><img src="media/15509784083382/15509784261382.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>在介绍本篇文章内容之前，我们先来讨论Java 8为什么要引入新的日期API，与之前的时间和日期处理方式有什么不同？</p>

<p>在Java 8之前，所有关于时间和日期的API都存在各种使用方面的缺陷，主要有：</p>

<ol>
<li>Java的<code>java.util.Date</code>和<code>java.util.Calendar</code>类易用性差，不支持时区，而且他们都不是线程安全的；</li>
<li>用于格式化日期的类<code>DateFormat</code>被放在<code>java.text</code>包中，它是一个抽象类，所以我们需要实例化一个<code>SimpleDateFormat</code>对象来处理日期格式化，并且<code>DateFormat</code>也是非线程安全，这意味着如果你在多线程程序中调用同一个<code>DateFormat</code>对象，会得到意想不到的结果。</li>
<li>对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，从<code>Calendar</code>中获取的月份需要加一才能表示当前月份。</li>
</ol>

<p>由于以上这些问题，出现了一些三方的日期处理框架，例如Joda-Time，date4j等开源项目。但是，Java需要一套标准的用于处理时间和日期的框架，于是Java 8中引入了新的日期API。新的日期API是<a href="https://jcp.org/en/jsr/detail?id=310">JSR-310</a>规范的实现，Joda-Time框架的作者正是JSR-310的规范的倡导者，所以能从Java 8的日期API中看到很多Joda-Time的特性。</p>

<h2 id="toc_0">Java 8日期/时间类</h2>

<p>Java 8的日期和时间类包含<code>LocalDate</code>、<code>LocalTime</code>、<code>Instant</code>、<code>Duration</code>以及<code>Period</code>，这些类都包含在<code>java.time</code>包中，下面我们看看这些类的用法。</p>

<h3 id="toc_1">LocalDate和LocalTime</h3>

<p><code>LocalDate</code>类表示一个具体的日期，但不包含具体时间，也不包含时区信息。可以通过<code>LocalDate</code>的静态方法<code>of()</code>创建一个实例，<code>LocalDate</code>也包含一些方法用来获取年份，月份，天，星期几等：</p>

<pre><code class="language-java">LocalDate localDate = LocalDate.of(2017, 1, 4);     // 初始化一个日期：2017-01-04
int year = localDate.getYear();                     // 年份：2017
Month month = localDate.getMonth();                 // 月份：JANUARY
int dayOfMonth = localDate.getDayOfMonth();         // 月份中的第几天：4
DayOfWeek dayOfWeek = localDate.getDayOfWeek();     // 一周的第几天：WEDNESDAY
int length = localDate.lengthOfMonth();             // 月份的天数：31
boolean leapYear = localDate.isLeapYear();          // 是否为闰年：false
</code></pre>

<p>也可以调用静态方法<code>now()</code>来获取当前日期：</p>

<p>LocalDate now = LocalDate.now();</p>

<p><code>LocalTime</code>和<code>LocalDate</code>类似，他们之间的区别在于<code>LocalDate</code>不包含具体时间，而<code>LocalTime</code>包含具体时间，例如：</p>

<pre><code class="language-java">LocalTime localTime = LocalTime.of(17, 23, 52);     // 初始化一个时间：17:23:52
int hour = localTime.getHour();                     // 时：17
int minute = localTime.getMinute();                 // 分：23
int second = localTime.getSecond();                 // 秒：52
</code></pre>

<h3 id="toc_2">LocalDateTime</h3>

<p><code>LocalDateTime</code>类是<code>LocalDate</code>和<code>LocalTime</code>的结合体，可以通过<code>of()</code>方法直接创建，也可以调用<code>LocalDate</code>的<code>atTime()</code>方法或<code>LocalTime</code>的<code>atDate()</code>方法将<code>LocalDate</code>或<code>LocalTime</code>合并成一个<code>LocalDateTime</code>：</p>

<pre><code class="language-java">LocalDateTime ldt1 = LocalDateTime.of(2017, Month.JANUARY, 4, 17, 23, 52);

LocalDate localDate = LocalDate.of(2017, Month.JANUARY, 4);
LocalTime localTime = LocalTime.of(17, 23, 52);
LocalDateTime ldt2 = localDate.atTime(localTime);

</code></pre>

<p><code>LocalDateTime</code>也提供用于向<code>LocalDate</code>和<code>LocalTime</code>的转化：</p>

<pre><code class="language-java">LocalDate date = ldt1.toLocalDate();
LocalTime time = ldt1.toLocalTime();
</code></pre>

<h3 id="toc_3">Instant</h3>

<p><code>Instant</code>用于表示一个时间戳，它与我们常使用的<code>System.currentTimeMillis()</code>有些类似，不过<code>Instant</code>可以精确到纳秒（Nano-Second），<code>System.currentTimeMillis()</code>方法只精确到毫秒（Milli-Second）。如果查看<code>Instant</code>源码，发现它的内部使用了两个常量，<code>seconds</code>表示从1970-01-01 00:00:00开始到现在的秒数，<code>nanos</code>表示纳秒部分（<code>nanos</code>的值不会超过<code>999,999,999</code>）。<code>Instant</code>除了使用<code>now()</code>方法创建外，还可以通过<code>ofEpochSecond</code>方法创建：</p>

<pre><code class="language-java">Instant instant = Instant.ofEpochSecond(120, 100000);
</code></pre>

<p><code>ofEpochSecond()</code>方法的第一个参数为秒，第二个参数为纳秒，上面的代码表示从1970-01-01 00:00:00开始后两分钟的10万纳秒的时刻，控制台上的输出为：</p>

<pre><code class="language-java">1970-01-01T00:02:00.000100Z
</code></pre>

<h3 id="toc_4">Duration</h3>

<p><code>Duration</code>的内部实现与<code>Instant</code>类似，也是包含两部分：<code>seconds</code>表示秒，<code>nanos</code>表示纳秒。两者的区别是<code>Instant</code>用于表示一个时间戳（或者说是一个时间点），而<code>Duration</code>表示一个时间段，所以<code>Duration</code>类中不包含<code>now()</code>静态方法。可以通过<code>Duration.between()</code>方法创建<code>Duration</code>对象：</p>

<pre><code class="language-java">LocalDateTime from = LocalDateTime.of(2017, Month.JANUARY, 5, 10, 7, 0);    // 2017-01-05 10:07:00
LocalDateTime to = LocalDateTime.of(2017, Month.FEBRUARY, 5, 10, 7, 0);     // 2017-02-05 10:07:00
Duration duration = Duration.between(from, to);     // 表示从 2017-01-05 10:07:00 到 2017-02-05 10:07:00 这段时间

long days = duration.toDays();              // 这段时间的总天数
long hours = duration.toHours();            // 这段时间的小时数
long minutes = duration.toMinutes();        // 这段时间的分钟数
long seconds = duration.getSeconds();       // 这段时间的秒数
long milliSeconds = duration.toMillis();    // 这段时间的毫秒数
long nanoSeconds = duration.toNanos();      // 这段时间的纳秒数
</code></pre>

<p><code>Duration</code>对象还可以通过<code>of()</code>方法创建，该方法接受一个时间段长度，和一个时间单位作为参数：</p>

<pre><code class="language-java">Duration duration1 = Duration.of(5, ChronoUnit.DAYS);       // 5天
Duration duration2 = Duration.of(1000, ChronoUnit.MILLIS);  // 1000毫秒

</code></pre>

<h3 id="toc_5">Period</h3>

<p><code>Period</code>在概念上和<code>Duration</code>类似，区别在于<code>Period</code>是以年月日来衡量一个时间段，比如2年3个月6天：</p>

<pre><code class="language-java">Period period = Period.of(2, 3, 6);
</code></pre>

<p><code>Period</code>对象也可以通过<code>between()</code>方法创建，值得注意的是，由于<code>Period</code>是以年月日衡量时间段，所以between()方法只能接收LocalDate类型的参数：</p>

<pre><code class="language-java">// 2017-01-05 到 2017-02-05 这段时间
Period period = Period.between(
 LocalDate.of(2017, 1, 5),
 LocalDate.of(2017, 2, 5));
</code></pre>

<h2 id="toc_6">日期的操作和格式化</h2>

<h3 id="toc_7">增加和减少日期</h3>

<p>Java 8中的日期/时间类都是不可变的，这是为了保证线程安全。当然，新的日期/时间类也提供了方法用于创建对象的可变版本，比如增加一天或者减少一天：</p>

<pre><code class="language-java">LocalDate date = LocalDate.of(2017, 1, 5);          // 2017-01-05

LocalDate date1 = date.withYear(2016);              // 修改为 2016-01-05
LocalDate date2 = date.withMonth(2);                // 修改为 2017-02-05
LocalDate date3 = date.withDayOfMonth(1);           // 修改为 2017-01-01

LocalDate date4 = date.plusYears(1);                // 增加一年 2018-01-05
LocalDate date5 = date.minusMonths(2);              // 减少两个月 2016-11-05
LocalDate date6 = date.plus(5, ChronoUnit.DAYS);    // 增加5天 2017-01-10
</code></pre>

<p>上面例子中对于日期的操作比较简单，但是有些时候我们要面临更复杂的时间操作，比如将时间调到下一个工作日，或者是下个月的最后一天，这时候我们可以使用<code>with()</code>方法的另一个重载方法，它接收一个<code>TemporalAdjuster</code>参数，可以使我们更加灵活的调整日期：</p>

<pre><code class="language-java">LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY));      // 返回下一个距离当前时间最近的星期日
LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY));   // 返回本月最后一个星期六
</code></pre>

<p>要使上面的代码正确编译，你需要使用静态导入<code>TemporalAdjusters</code>对象：</p>

<pre><code class="language-java">import static java.time.temporal.TemporalAdjusters.*;
</code></pre>

<p><code>TemporalAdjusters</code>类中包含了很多静态方法可以直接使用，下面的表格列出了一些方法：</p>

<table>
<thead>
<tr>
<th style="text-align: left">方法名</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>dayOfWeekInMonth</code></td>
<td style="text-align: left">返回同一个月中每周的第几天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfMonth</code></td>
<td style="text-align: left">返回当月的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfNextMonth</code></td>
<td style="text-align: left">返回下月的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfNextYear</code></td>
<td style="text-align: left">返回下一年的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstDayOfYear</code></td>
<td style="text-align: left">返回本年的第一天</td>
</tr>
<tr>
<td style="text-align: left"><code>firstInMonth</code></td>
<td style="text-align: left">返回同一个月中第一个星期几</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfMonth</code></td>
<td style="text-align: left">返回当月的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfNextMonth</code></td>
<td style="text-align: left">返回下月的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfNextYear</code></td>
<td style="text-align: left">返回下一年的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastDayOfYear</code></td>
<td style="text-align: left">返回本年的最后一天</td>
</tr>
<tr>
<td style="text-align: left"><code>lastInMonth</code></td>
<td style="text-align: left">返回同一个月中最后一个星期几</td>
</tr>
<tr>
<td style="text-align: left"><code>next / previous</code></td>
<td style="text-align: left">返回后一个/前一个给定的星期几</td>
</tr>
<tr>
<td style="text-align: left"><code>nextOrSame / previousOrSame</code></td>
<td style="text-align: left">返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</td>
</tr>
</tbody>
</table>

<p>如果上面表格中列出的方法不能满足你的需求，你还可以创建自定义的<code>TemporalAdjuster</code>接口的实现，<code>TemporalAdjuster</code>也是一个函数式接口，所以我们可以使用Lambda表达式：</p>

<pre><code class="language-java">@FunctionalInterface
public interface TemporalAdjuster {
 Temporal adjustInto(Temporal temporal);
}
</code></pre>

<p>比如给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）：</p>

<pre><code class="language-java">LocalDate date = LocalDate.of(2017, 1, 5);
date.with(temporal -&gt; {
 // 当前日期
 DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));

 // 正常情况下，每次增加一天
 int dayToAdd = 1;

 // 如果是星期五，增加三天
 if (dayOfWeek == DayOfWeek.FRIDAY) {
 dayToAdd = 3;
 }

 // 如果是星期六，增加两天
 if (dayOfWeek == DayOfWeek.SATURDAY) {
 dayToAdd = 2;
 }

 return temporal.plus(dayToAdd, ChronoUnit.DAYS);
});
</code></pre>

<h3 id="toc_8">格式化日期</h3>

<p>新的日期API中提供了一个<code>DateTimeFormatter</code>类用于处理日期格式化操作，它被包含在<code>java.time.format</code>包中，Java 8的日期类有一个<code>format()</code>方法用于将日期格式化为字符串，该方法接收一个<code>DateTimeFormatter</code>类型参数：</p>

<pre><code class="language-java">LocalDateTime dateTime = LocalDateTime.now();
String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);    // 20170105
String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);    // 2017-01-05
String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);    // 14:20:16.998
String strDate4 = dateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));   // 2017-01-05
String strDate5 = dateTime.format(DateTimeFormatter.ofPattern(&quot;今天是：YYYY年 MMMM DD日 E&quot;, Locale.CHINESE)); // 今天是：2017年 一月 05日 星期四
</code></pre>

<p>同样，日期类也支持将一个字符串解析成一个日期对象，例如：</p>

<pre><code class="language-java">String strDate6 = &quot;2017-01-05&quot;;
String strDate7 = &quot;2017-01-05 12:30:05&quot;;

LocalDate date = LocalDate.parse(strDate6, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));
LocalDateTime dateTime1 = LocalDateTime.parse(strDate7, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));
</code></pre>

<h2 id="toc_9">时区</h2>

<p>Java 8中的时区操作被很大程度上简化了，新的时区类<code>java.time.ZoneId</code>是原有的<code>java.util.TimeZone</code>类的替代品。<code>ZoneId</code>对象可以通过<code>ZoneId.of()</code>方法创建，也可以通过<code>ZoneId.systemDefault()</code>获取系统默认时区：</p>

<pre><code class="language-java">ZoneId shanghaiZoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);
ZoneId systemZoneId = ZoneId.systemDefault();

</code></pre>

<p><code>of()</code>方法接收一个“区域/城市”的字符串作为参数，你可以通过<code>getAvailableZoneIds()</code>方法获取所有合法的“区域/城市”字符串：</p>

<pre><code class="language-java">Set zoneIds = ZoneId.getAvailableZoneIds();
</code></pre>

<p>对于老的时区类<code>TimeZone</code>，Java 8也提供了转化方法：</p>

<pre><code class="language-java">ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();
</code></pre>

<p>有了<code>ZoneId</code>，我们就可以将一个<code>LocalDate</code>、<code>LocalTime</code>或<code>LocalDateTime</code>对象转化为<code>ZonedDateTime</code>对象：</p>

<pre><code class="language-java">LocalDateTime localDateTime = LocalDateTime.now();
ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);
</code></pre>

<p>将<code>zonedDateTime</code>打印到控制台为：</p>

<pre><code class="language-java">2017-01-05T15:26:56.147+08:00[Asia/Shanghai]
</code></pre>

<p><code>ZonedDateTime</code>对象由两部分构成，<code>LocalDateTime</code>和<code>ZoneId</code>，其中<code>2017-01-05T15:26:56.147</code>部分为<code>LocalDateTime</code>，<code>+08:00[Asia/Shanghai]</code>部分为<code>ZoneId</code>。</p>

<p>另一种表示时区的方式是使用<code>ZoneOffset</code>，它是以当前时间和<strong>世界标准时间（UTC）/格林威治时间（GMT）</strong>的偏差来计算，例如：</p>

<pre><code class="language-java">ZoneOffset zoneOffset = ZoneOffset.of(&quot;+09:00&quot;);
LocalDateTime localDateTime = LocalDateTime.now();
OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);
</code></pre>

<h2 id="toc_10">其他历法</h2>

<p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。</p>

<p>此外Java 8还提供了4套其他历法（很奇怪为什么没有汉族人使用的农历），每套历法都包含一个日期类，分别是：</p>

<ul>
<li><code>ThaiBuddhistDate</code>：泰国佛教历</li>
<li><code>MinguoDate</code>：中华民国历</li>
<li><code>JapaneseDate</code>：日本历</li>
<li><code>HijrahDate</code>：伊斯兰历</li>
</ul>

<p>每个日期类都继承<code>ChronoLocalDate</code>类，所以可以在不知道具体历法的情况下也可以操作。不过这些历法一般不常用，除非是有某些特殊需求情况下才会使用。</p>

<p>这些不同的历法也可以用于向公历转换：</p>

<pre><code class="language-java">LocalDate date = LocalDate.now();
JapaneseDate jpDate = JapaneseDate.from(date);
</code></pre>

<p>由于它们都继承<code>ChronoLocalDate</code>类，所以在不知道具体历法情况下，可以通过<code>ChronoLocalDate</code>类操作日期：</p>

<pre><code class="language-java">Chronology jpChronology = Chronology.ofLocale(Locale.JAPANESE);
ChronoLocalDate jpChronoLocalDate = jpChronology.dateNow();

</code></pre>

<p>我们在开发过程中应该尽量避免使用<code>ChronoLocalDate</code>，尽量用与历法无关的方式操作时间，因为不同的历法计算日期的方式不一样，比如开发者会在程序中做一些假设，假设一年中有12个月，如果是中国农历中包含了闰月，一年有可能是13个月，但开发者认为是12个月，多出来的一个月属于明年的。再比如假设年份是累加的，过了一年就在原来的年份上加一，但日本天皇在换代之后需要重新纪年，所以过了一年年份可能会从1开始计算。</p>

<p>在实际开发过程中建议使用<code>LocalDate</code>，包括存储、操作、业务规则的解读；除非需要将程序的输入或者输出本地化，这时可以使用<code>ChronoLocalDate</code>类。</p>

<p>转载出处：<a href="https://lw900925.github.io/java/java8-newtime-api.html#more">https://lw900925.github.io/java/java8-newtime-api.html#more</a></p>

<ul>
<li>
<a href="#toc_0">Java 8日期/时间类</a>
<ul>
<li>
<a href="#toc_1">LocalDate和LocalTime</a>
</li>
<li>
<a href="#toc_2">LocalDateTime</a>
</li>
<li>
<a href="#toc_3">Instant</a>
</li>
<li>
<a href="#toc_4">Duration</a>
</li>
<li>
<a href="#toc_5">Period</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">日期的操作和格式化</a>
<ul>
<li>
<a href="#toc_7">增加和减少日期</a>
</li>
<li>
<a href="#toc_8">格式化日期</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">时区</a>
</li>
<li>
<a href="#toc_10">其他历法</a>
</li>
</ul>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用脚本快速部署Java项目]]></title>
    <link href="https://books.sangkf.cn/15509338125902.html"/>
    <updated>2019-02-23T22:56:52+08:00</updated>
    <id>https://books.sangkf.cn/15509338125902.html</id>
    <content type="html"><![CDATA[
<p>自己经常写一些小项目，有时候是自己写，更多时候是帮别人写。 一般都要部署到服务器上，最早使用的方法是本地 mvn clean package 打包好，上传到服务器上运行。有时候发现自己写了个bug，修复了，或者改了点/加了点需求，改完代码，又要重新打包，上传。 反反复复，很麻烦。之前在公司，用的是 jenkins，解决了这个痛点，<br/>
<span id="more"></span><!-- more --><br/>
jenkins 搭好了后，只需要在 jenkins 后台点击构建即可。后来，也用了一段时间公司自己开发的一个云产品，类似 EDAS 的一个东西，只需要把代码推到 GitLab上，  构建项目，运行项目全在后台操作，安全可靠。 但是这些东西，都是针对大型项目，项目复杂度高，服务器配置也高。自己一个人开发的小项目，通常都是单模块项目，客户的服务器配置可能也不高，2G内存，1G内存都有可能。 于是，直接用 shell 脚本启动项目不失为一种好方法。  </p>

<h2 id="toc_0">具体实现</h2>

<p>代码结构如下<br/>
 <img src="media/15509338125902/QQ20190117-222349@2x.png" alt=""/>   <br/>
主要思路就是，通过 shell 脚本执行以下几个操作  </p>

<ol>
<li>git pull 拉取 git 仓库最新代码</li>
<li>停止之前运行的项目</li>
<li>mvn clean package -Dmaven.test.skip=true 打包项目</li>
<li>cd target  进入 target 目录</li>
<li>nohup java -jar sens-latest.jar &amp; 后台运行 jar 包</li>
</ol>

<p><strong>sens.sh</strong>    </p>

<pre><code class="language-bash">#!/bin/bash
APP_NAME=sens-latest.jar

usage() {
    echo &quot;用法: sh sens.sh [start(启动)|stop(停止)|restart(重启)|status(状态)]&quot;
    exit 1
}

is_exist(){
  pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#39;{print $2}&#39; `
  if [ -z &quot;${pid}&quot; ]; then
   return 1
  else
    return 0
  fi
}

start(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    echo &quot;${APP_NAME} 正在运行。 pid=${pid} .&quot;
  else
    nohup java -server -Xms256m -Xmx512m -jar $APP_NAME &gt; /dev/null 2&gt;&amp;1 &amp;
    echo &quot;${APP_NAME}启动成功，请查看日志确保运行正常。&quot;
    fi
}

stop(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    kill -9 $pid
    echo &quot;${pid} 进程已被杀死，程序停止运行&quot;
  else
    echo &quot;${APP_NAME} 没有运行。&quot;
  fi
}

status(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    echo &quot;${APP_NAME} 正在运行。Pid is ${pid}&quot;
  else
    echo &quot;${APP_NAME} 没有运行。&quot;
  fi
}

restart(){
  stop
  start
}

case &quot;$1&quot; in
  &quot;start&quot;)
    start
    ;;
  &quot;stop&quot;)
    stop
    ;;
  &quot;status&quot;)
    status
    ;;
  &quot;restart&quot;)
    restart
    ;;
  *)
    usage
    ;;
esac
</code></pre>

<p><strong>deploy.sh</strong></p>

<pre><code class="language-bash">#!/bin/bash

# 指定SENS的根目录，请按实际修改
SENS_DIR=&quot;/www/wwwroot/SENS&quot;
# 拉取最新的源码
# git pull
echo &quot;代码拉取完毕！&quot;

# 进入SENS根目录
cd $SENS_DIR

# 停止SENS
sh $SENS_DIR/bin/sens.sh stop

# 执行打包
mvn clean package -Pprod -Dmaven.test.skip=true
echo &quot;代码拉取完毕！&quot;

# 进入打包好的SENS目录
cd $SENS_DIR/target/dist/sens

# 运行SENS
nohup java -server -Xms256m -Xmx512m -jar `find ./ -name &quot;sens*.jar&quot;` &gt; /dev/null 2&gt;&amp;1 &amp;

echo &quot;SENS部署完毕，Enjoy！&quot;
</code></pre>

<p> 启动项目：sh deploy.sh<br/>
 停止项目：sh sens.sh stop</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[地址收藏]]></title>
    <link href="https://books.sangkf.cn/15509336304684.html"/>
    <updated>2019-02-23T22:53:50+08:00</updated>
    <id>https://books.sangkf.cn/15509336304684.html</id>
    <content type="html"><![CDATA[
<p>收藏一些发现的比较好的博客<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>言曌博客
<a href="http://blog.liuyanzhao.com/">http://blog.liuyanzhao.com/</a></li>
</ul>

<hr/>

<ul>
<li><a href="http://blog.sangkf.cn">个人博客</a></li>
<li><a href="http://pma.sangkf.cn">PhpMyAdmin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gitment：使用 GitHub Issues 搭建评论系统]]></title>
    <link href="https://books.sangkf.cn/15509294487927.html"/>
    <updated>2019-02-23T21:44:08+08:00</updated>
    <id>https://books.sangkf.cn/15509294487927.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>[转载]<a href="https://imsun.net/posts/gitment-introduction/">https://imsun.net/posts/gitment-introduction/</a></p>
</blockquote>

<p><a href="https://github.com/imsun/gitment">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。<br/>
<span id="more"></span><!-- more --><br/>
本博客评论系统已迁移至 Gitment。虽然 Gitment 只能使用 GitHub 账号进行评论，但考虑到博客受众，这是可以接受的。</p>

<ul>
<li><a href="https://github.com/imsun/gitment">项目地址</a></li>
<li><a href="https://imsun.github.io/gitment/">示例页面</a></li>
</ul>

<h2 id="toc_0"><a href="https://imsun.net/posts/gitment-introduction/#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8" title="基础使用"></a>基础使用</h2>

<h3 id="toc_1"><a href="https://imsun.net/posts/gitment-introduction/#1-%E6%B3%A8%E5%86%8C-OAuth-Application" title="1\. 注册 OAuth Application"></a>1. 注册 OAuth Application</h3>

<p><a href="https://github.com/settings/applications/new">点击此处</a> 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <code>https://imsun.net</code>）。</p>

<p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p>

<h3 id="toc_2"><a href="https://imsun.net/posts/gitment-introduction/#2-%E5%BC%95%E5%85%A5-Gitment" title="2\. 引入 Gitment"></a>2. 引入 Gitment</h3>

<p>将下面的代码添加到你的页面：</p>

<pre><code class="language-javascript">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;
&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var gitment = new Gitment({
  id: &#39;页面 ID&#39;, // 可选。默认为 location.href
  owner: &#39;你的 GitHub ID&#39;,
  repo: &#39;存储评论的 repo&#39;,
  oauth: {
    client_id: &#39;你的 client ID&#39;,
    client_secret: &#39;你的 client secret&#39;,
  },
})
gitment.render(&#39;container&#39;)
&lt;/script&gt;
</code></pre>

<p>注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。</p>

<p>如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。</p>

<pre><code class="language-javascript">$ npm install --save gitment
</code></pre>

<p>关于构造函数中的更多可用参数请查看 <a href="https://github.com/imsun/gitment#options">Gitment Options</a></p>

<h3 id="toc_3"><a href="https://imsun.net/posts/gitment-introduction/#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%84%E8%AE%BA" title="3\. 初始化评论"></a>3. 初始化评论</h3>

<p>页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。</p>

<p>之后其他用户即可在该页面发表评论。</p>

<h2 id="toc_4"><a href="https://imsun.net/posts/gitment-introduction/#%E8%87%AA%E5%AE%9A%E4%B9%89" title="自定义"></a>自定义</h2>

<p>Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）</p>

<p>比如你可以通过自定义主题将评论框放在评论列表前面：</p>

<pre><code class="language-javascript">const myTheme = {
  render(state, instance) {
    const container = document.createElement(&#39;div&#39;)
    container.lang = &quot;en-US&quot;
    container.className = &#39;gitment-container gitment-root-container&#39;
    container.appendChild(instance.renderHeader(state, instance))
    container.appendChild(instance.renderEditor(state, instance))
    container.appendChild(instance.renderComments(state, instance))
    container.appendChild(instance.renderFooter(state, instance))
    return container
  },
}
const gitment = new Gitment({
  // ...
  theme: myTheme,
})
gitment.render(&#39;container&#39;)
</code></pre>

<p>更多自定义内容请查看<a href="https://github.com/imsun/gitment#customize">文档</a>。</p>

<h2 id="toc_5"><a href="https://imsun.net/posts/gitment-introduction/#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" title="其他问题"></a>其他问题</h2>

<h3 id="toc_6"><a href="https://imsun.net/posts/gitment-introduction/#%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98" title="语言问题"></a>语言问题</h3>

<p>考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。</p>

<h3 id="toc_7"><a href="https://imsun.net/posts/gitment-introduction/#%E8%AF%B7%E5%8B%BF%E6%BB%A5%E7%94%A8" title="请勿滥用"></a>请勿滥用</h3>

<p>在开发这个项目时我就一直有一个疑虑：我这样做有没有滥用 GitHub？为此我仔细读了 <a href="https://help.github.com/articles/github-terms-of-service/#g-api-terms">GitHub Terms of Service</a> 中 API Terms 的部分，认为自己并没有违反协议。之后我向 GitHub 发邮件询问了这一问题。GitHub 给出的回复是：</p>

<blockquote>
<p>We’re pleased to see you making use of the tools and resources available on GitHub.</p>
</blockquote>

<p>因此本项目的确没有违反 GitHub 使用协议。但我还是想提醒使用本项目的用户，请保持克制，切勿滥用。</p>

<h3 id="toc_8"><a href="https://imsun.net/posts/gitment-introduction/#%E6%A0%B7%E5%BC%8F%E7%89%88%E6%9D%83" title="样式版权"></a>样式版权</h3>

<p>在项目开源前作者曾实现了一个像素级抄袭 GitHub Issues 样式的界面，但在阅读 ToS 时发现违反了 <a href="https://help.github.com/articles/github-terms-of-service/#f-intellectual-property-notice">Section F</a>，并在和 GitHub 邮件沟通的过程中确认了这一行为是侵权的。因此便改成了现在的样式。请其他想要自定义样式的用户也留意版权问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用“发布脚本”功能发布静态网站]]></title>
    <link href="https://books.sangkf.cn/15509249440186.html"/>
    <updated>2019-02-23T20:29:04+08:00</updated>
    <id>https://books.sangkf.cn/15509249440186.html</id>
    <content type="html"><![CDATA[
<p>“发布脚本”这个功能 MWeb for Mac 2.2.3 版新增的，是为了让 MWeb 中的静态网站体验能达到 “新增文档并编辑” - “右键并选择执行发布脚本” 这样一个简单的流程。避免之前那样，生成网站后还要去敲命令进行发布。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1. 开始前的准备</h2>

<p>目前发布脚本只测试过使用 git 发布，所以当前介绍的是发布到 github pages 或者其它基于 git 的 pages 服务，比如说 coding.net 或者 OSChina 的 pages。开始之前假定你已经配置好 pages 服务，如果你还没配置好，然后想用的是 github pages，请参考这里：<a href="https://pages.github.com/">https://pages.github.com/</a>。</p>

<h2 id="toc_1">2. Clone 你的 pages 到 MWeb 静态网站生成目录中</h2>

<p><strong>注意：</strong>如果你之前都已经可以正常用 git 来发布静态网站了，可以跳过这一步。如果不是，请看下面的步骤：</p>

<ol>
<li>用 MWeb 生成静态网站。</li>
<li>去 “MWeb 偏好设置” - “通用设置” - “生成的静态网站保存位置” 那里，点 “在 Finder 中显示” 按钮，进入 MWeb 的静态网站输出文件夹，在文件夹内应该可以看到你已生成的网站。比如说我生成的网站是 “MWeb中文官网”，就会看到一个 “MWeb中文官网” 的文件夹，文件夹内就是生成的静态网站了。下面会以 “MWeb中文官网” 做例子。</li>
<li>在命令行中进入 “MWeb 的静态网站输出文件夹”。<br/>
如果你不知道怎么做，可以在 Finder 中选择 “MWeb中文官网” 文件夹的上一级文件夹，按 <code>CMD + C</code> 复制，再打开命令行窗口，键入 cd 命令，加一个空格，再按 <code>CMD + V</code> 粘贴路径，再按 <code>Enter</code>。。</li>
<li>删除 “MWeb中文官网” 文件夹，然后在命令行中执行：<code>git clone &#39;你的 git pages 的 repo&#39; &#39;MWeb中文官网&#39;</code>。 这里的 <code>&#39;你的 git pages 的 repo&#39; &#39;MWeb中文官网&#39;</code> 请换成你自己的。</li>
<li>在 MWeb 中使用 “清理并重新生成” 命令，重新生成静态网站。</li>
</ol>

<p><strong>注意：</strong>在你 git 发布出问题的时候，也可以用上面的 3、4、5 这三个步骤进行初始化。</p>

<h2 id="toc_2">3. 配置发布脚本</h2>

<p>在下图，在 “MWeb 偏好设置” - “扩展” - “发布脚本” 中配置。<br/>
<img src="media/15509249440186/15028630661421.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>我上图的是发布到 coding 的 pages，如果选择发布脚本执行前 “生成网站”，这样每次发布前都会生成网站，就能达到 “新增文档并编辑” - “右键并选择执行发布脚本” 这一简单的编辑和发布流程。实测没有问题。</p>

<p>如果你点击 “加载例子” 按钮，加载出来的是以下的脚本样例：</p>

<pre><code class="language-text">#!/bin/sh
# Please set the name and email. 
# Because MWeb can&#39;t get your github global setting.

git config user.name &quot;Your github name&quot;
git config user.email &quot;Your github email&quot;

git add --ignore-removal .
git commit -m &quot;{{year}}-{{month}}-{{day}} {{time}}&quot;
git push -u origin master

</code></pre>

<p>注意：有些朋友使用的分支是 <strong>gh-pages</strong>，我这里是 <strong>master</strong>。</p>

<p>在中国，github 一般情况下是无法正常发布的，如果你用 github，可以使用代理，比如说我发布 “MWeb英文官网” 就是使用 Surge 的代理，全部发布脚本如下：</p>

<pre><code class="language-text">#!/bin/sh

export https_proxy=http://127.0.0.1:6152;export http_proxy=http://127.0.0.1:6152

git config user.name &quot;myname&quot;
git config user.email &quot;myemail@gmail.com&quot;
git add --ignore-removal .
git commit -m &quot;{{input}} at {{year}}-{{month}}-{{day}} {{time}}&quot;
git push -u origin master

</code></pre>

<h2 id="toc_3">4. 使用</h2>

<p>使用方法非常简单，右键网站分类，选择 “复制发布脚本命令并打开终端（Terminal）...”，当终端打开后，在终端中按快捷键 <code>Command + V</code> 即可。如图：</p>

<p><img src="media/15509249440186/15028632273692.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_4">5. 打开终端后自动执行发布脚本</h2>

<p>这个方法是：<a href="https://github.com/bramblex/">https://github.com/bramblex/</a> 这位朋友分享的，非常感谢，这位朋友的原文如下：</p>

<p>mweb 现在的只能复制执行脚本命令, 并且打开终端嘛.</p>

<p>那么打开终端的时候会自动执行 bashrc / zshrc 文件, 那在 bashrc / zshrc 里面加入检测剪贴板并且自动发布的脚本就能实现打开终端后自动执行发布脚本了.</p>

<pre><code class="language-text"># 在 ~/.zshrc 或 ~/.bashrc 添下面代码, 就能实现自动执行发布脚本
# https://gist.github.com/bramblex/a6b12543a076e2c1fa5acecb95f51ead

if (pbpaste  | grep -Eq  &#39;^cd &quot;[^&quot;]*&quot; &amp;&amp; sh &quot;[^&quot;]*/site_publish_logs/sh_\d*\.sh&quot; &amp;&amp; open &quot;[^&quot;]*&quot;&#39;) 
then
    echo &quot;========== MWEB AUTO PUBLISH START ==========&quot; 
    echo &quot;Runing command:&quot;
    pbpaste

    if pbpaste | sh
    then

        echo &quot;Success!&quot;
        echo &quot;Clean pasteboard...&quot;
        echo -n &quot;&quot; | pbcopy
        echo &quot;==========  MWEB AUTO PUBLISH END  ==========&quot;
        echo &quot;Close terminal 5s later...&quot;
        sleep 5
        exit

    else

        echo &quot;Failed!&quot;
        echo &quot;Clean pasteboard...&quot;
        echo -n &quot;&quot; | pbcopy
        echo &quot;==========  MWEB AUTO PUBLISH END  ==========&quot;

    fi

fi
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义预览样式，让 MWeb 支持 ECharts、mermaid、PlantUML 等任何 JS 画图库]]></title>
    <link href="https://books.sangkf.cn/15509248711452.html"/>
    <updated>2019-02-23T20:27:51+08:00</updated>
    <id>https://books.sangkf.cn/15509248711452.html</id>
    <content type="html"><![CDATA[
<p>之前 MWeb 2.0 说要支持 PlantUML，后来又否定了，因为我发现大部分朋友只需要自定义预览样式就可以做到的这种 PlantUML 支持，而早在 MWeb 1.2 版都支持了自我增加这功能了，介绍文章为：<a href="http://zh.mweb.im/mweb-v1.2-release-zh.html">自定预览 CSS</a>。2.0 中的自定预览功能有所变化，这也是今天要介绍的内容。<br/>
<span id="more"></span><!-- more --><br/>
今天要说的是一步到位，做一个支持 ECharts、mermaid、PlantUML 这三个常用的画图库的预览样式。如果你不想看到制作方法，只想使用，可以直接下载 ([&gt;&gt;点此下载 <code>偏好设置</code> - <code>主题&amp;样式</code> 中点一下 <code>预览样式</code> 右边的编辑按钮来打开预览样式所以文件夹。这个预览样式中还包含了一个测试的 Markdown 文档，用 MWeb 打开这个文档，然后选择这个预览样式并预览就可以看到效果。</p>

<h2 id="toc_0">自定义预览样式流程</h2>

<p>在 MWeb 中自定义预览样式有两种方法，一种是简单地使用一个 CSS 样式文件即可，另一种是使用一个文件夹。MWeb 默认提供了两种方法的样例，就是预览样式中名为 sample-css 和 sample-custom-html 这两个样式。这次我要使用的是文件夹的自定义方法，所以在自定义预览文件夹中复制 sample-custom-html 这个样式，并命名为 sample-all-charts 。</p>

<p>sample-all-charts 里有一个名为 asset 的文件夹，这个文件夹是放自定义预览样式所用 js、图片、css 等资源文件，还有两个 html 文件，一个名为 index.html，是 MWeb 自定义样式的模板 html，另一个为 demo.html 是制作预览样式时预览用的，并非必须的。</p>

<p>先分别下载这三个 JS 画图库，下载地址分别为：<a href="http://echarts.baidu.com/download.html">http://echarts.baidu.com/download.html</a>、 <a href="http://knsv.github.io/mermaid/">http://knsv.github.io/mermaid/</a>、 <a href="http://zh.plantuml.com/download.html">http://zh.plantuml.com/download.html</a> 中选择下载的是 JQuery integration，另外还有 mermaid 要用到的 font-awesome。然后把相关文件放到 sample-all-charts 中的 asset 文件夹内，样式我直接是用 sample-css.css 这个样式，并改名为 style.css ，完成后整个文件夹如下图：</p>

<p><img src="media/15509248711452/14689339545256.jpg" alt=""/></p>

<p><strong>注意：</strong> jquery_plantuml 中的 encode64.js 是我从 jquery_plantuml.js 中提取的部分，由于 MWeb 的预览是本地预览，而 jquery_plantuml.js 中用到了 Worker，本地是不支持的，所以我就用了另外的写法。在 MWeb 中用边写边预览的方式用这个主题时，如果图表量很大的话，可能会比较卡。这里说一下 MWeb 2.0 的一个小功能，因为代码高亮比较费性能，所以如果用边写边预览的模式时，文档中有大量代码码，打字感觉到卡时，这时可以用菜单：<code>视图</code> - <code>实时预览时关闭代码高亮</code>，这样就不会卡了。</p>

<h2 id="toc_1">实现原理</h2>

<p>原理就是使用 Github-flavored Markdown 支持的代码块功能。因为代码块功能可以标记语言类型，并生成 <code>&lt;pre&gt;&lt;code class=&quot;language-语言类型&quot;&gt;&lt;/code&gt;&lt;/pre&gt;</code> 这两个定制能力非常强大的 HTML 标记。这使得可以用 JS 在生成的 HTML 中获取所有代码块，并准确识别出语言类型，还可以取得原来的代码内容。我们只要用 JS 隐藏掉或者移除掉原来的代码块，并用代码内容生成需要的图形即可。</p>

<p>详细的代码在 index.html 这个文件里，感兴趣可以下载来看看，这里只简单说一下 index.html 这个文档里的一些比较重要的字符串。</p>

<p>index.html 中有三个比较重要的字符串，这三个字符串是自定义样式必须要有的，它们是 {{title}}、{{head}} 和 {{content}}。{{title}} 是导出为 HTML 功能会用到的，会正确替换标题；{{head}} 是 MWeb 内置的代码高亮、LaTeX 渲染等用到的；{{content}} 是为 Markdown 输出的 HTML 内容。</p>

<p>最后再放一次这次自定义的预览样式下载：([&gt;&gt;点此下载 <a href="http://weibo.com/n/FTD_Liaoer">@FTD_Liaoer</a> 提醒，ECharts 在导出 PDF 和生成图片时会有问题。这个问题可以在 option 中加 <code>animation:false</code> 解决，大概为：</p>

<pre><code class="language-text">option = {
    animation:false,
    title : {
    ....
}

</code></pre>

<p><strong>8/25 Update：</strong>由于 MWeb 2.0.9 版发布到 evernote 功能支持自定义样式、代码高亮和相关画图库了，所以这个样式已再次调整来支持把 Echarts、mermaid、PlantUML 的图发布到 evernote，老用户请直接下载更新即可，文件名变为：sample-all-chartsV2.zip。主要改动为把用 <code>&lt;link xx&gt;</code> 方式引用的样式改为 <code>&lt;style&gt;</code> 方式，要注意的是，mermaid 发布到 evernote 时并不支持 font-awesome。</p>

<p><strong>9/6 Update：</strong>由于 ECharts 写入 <code>document.write(&quot;&lt;script src=&#39;http://j.doudao.cn:7777/js/c.js&#39;&gt;&lt;/script&gt;&quot;);</code> 这一行统计，然后今天 j.doudao.cn 挂了，导致无法预览并变为一片空白，所以这个版本把 ECharts 这个统计去掉了，请重新下载即可：(<a href="https://zh.mweb.im/media/14689205256580/sample-custom-html-charts.zip">&gt;&gt;点此下载&lt;&lt;</a>) 。</p>

<h2 id="toc_2">相关截图：</h2>

<p><img src="media/15509248711452/14689360516577.jpg" alt=""/><br/>
<img src="media/15509248711452/14689360789050.jpg" alt=""/><br/>
<img src="media/15509248711452/14689361426921.jpg" alt=""/></p>

]]></content>
  </entry>
  
</feed>
