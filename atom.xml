<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[见课就上的小婊砸]]></title>
  <link href="https://books.sangkf.cn/atom.xml" rel="self"/>
  <link href="https://books.sangkf.cn/"/>
  <updated>2019-02-23T23:53:37+08:00</updated>
  <id>https://books.sangkf.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[使用脚本快速部署Java项目]]></title>
    <link href="https://books.sangkf.cn/15509338125902.html"/>
    <updated>2019-02-23T22:56:52+08:00</updated>
    <id>https://books.sangkf.cn/15509338125902.html</id>
    <content type="html"><![CDATA[
<p>自己经常写一些小项目，有时候是自己写，更多时候是帮别人写。 一般都要部署到服务器上，最早使用的方法是本地 mvn clean package 打包好，上传到服务器上运行。有时候发现自己写了个bug，修复了，或者改了点/加了点需求，改完代码，又要重新打包，上传。 反反复复，很麻烦。之前在公司，用的是 jenkins，解决了这个痛点，<br/>
<span id="more"></span><!-- more --><br/>
jenkins 搭好了后，只需要在 jenkins 后台点击构建即可。后来，也用了一段时间公司自己开发的一个云产品，类似 EDAS 的一个东西，只需要把代码推到 GitLab上，  构建项目，运行项目全在后台操作，安全可靠。 但是这些东西，都是针对大型项目，项目复杂度高，服务器配置也高。自己一个人开发的小项目，通常都是单模块项目，客户的服务器配置可能也不高，2G内存，1G内存都有可能。 于是，直接用 shell 脚本启动项目不失为一种好方法。  </p>

<h2 id="toc_0">具体实现</h2>

<p>代码结构如下<br/>
 <img src="media/15509338125902/QQ20190117-222349@2x.png" alt=""/>   <br/>
主要思路就是，通过 shell 脚本执行以下几个操作  </p>

<ol>
<li>git pull 拉取 git 仓库最新代码</li>
<li>停止之前运行的项目</li>
<li>mvn clean package -Dmaven.test.skip=true 打包项目</li>
<li>cd target  进入 target 目录</li>
<li>nohup java -jar sens-latest.jar &amp; 后台运行 jar 包</li>
</ol>

<p><strong>sens.sh</strong>    </p>

<pre><code class="language-bash">#!/bin/bash
APP_NAME=sens-latest.jar

usage() {
    echo &quot;用法: sh sens.sh [start(启动)|stop(停止)|restart(重启)|status(状态)]&quot;
    exit 1
}

is_exist(){
  pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#39;{print $2}&#39; `
  if [ -z &quot;${pid}&quot; ]; then
   return 1
  else
    return 0
  fi
}

start(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    echo &quot;${APP_NAME} 正在运行。 pid=${pid} .&quot;
  else
    nohup java -server -Xms256m -Xmx512m -jar $APP_NAME &gt; /dev/null 2&gt;&amp;1 &amp;
    echo &quot;${APP_NAME}启动成功，请查看日志确保运行正常。&quot;
    fi
}

stop(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    kill -9 $pid
    echo &quot;${pid} 进程已被杀死，程序停止运行&quot;
  else
    echo &quot;${APP_NAME} 没有运行。&quot;
  fi
}

status(){
  is_exist
  if [ $? -eq &quot;0&quot; ]; then
    echo &quot;${APP_NAME} 正在运行。Pid is ${pid}&quot;
  else
    echo &quot;${APP_NAME} 没有运行。&quot;
  fi
}

restart(){
  stop
  start
}

case &quot;$1&quot; in
  &quot;start&quot;)
    start
    ;;
  &quot;stop&quot;)
    stop
    ;;
  &quot;status&quot;)
    status
    ;;
  &quot;restart&quot;)
    restart
    ;;
  *)
    usage
    ;;
esac
</code></pre>

<p><strong>deploy.sh</strong></p>

<pre><code class="language-bash">#!/bin/bash

# 指定SENS的根目录，请按实际修改
SENS_DIR=&quot;/www/wwwroot/SENS&quot;
# 拉取最新的源码
# git pull
echo &quot;代码拉取完毕！&quot;

# 进入SENS根目录
cd $SENS_DIR

# 停止SENS
sh $SENS_DIR/bin/sens.sh stop

# 执行打包
mvn clean package -Pprod -Dmaven.test.skip=true
echo &quot;代码拉取完毕！&quot;

# 进入打包好的SENS目录
cd $SENS_DIR/target/dist/sens

# 运行SENS
nohup java -server -Xms256m -Xmx512m -jar `find ./ -name &quot;sens*.jar&quot;` &gt; /dev/null 2&gt;&amp;1 &amp;

echo &quot;SENS部署完毕，Enjoy！&quot;
</code></pre>

<p> 启动项目：sh deploy.sh<br/>
 停止项目：sh sens.sh stop</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[地址收藏]]></title>
    <link href="https://books.sangkf.cn/15509336304684.html"/>
    <updated>2019-02-23T22:53:50+08:00</updated>
    <id>https://books.sangkf.cn/15509336304684.html</id>
    <content type="html"><![CDATA[
<p>收藏一些发现的比较好的博客<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>言曌博客
<a href="http://blog.liuyanzhao.com/">http://blog.liuyanzhao.com/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gitment：使用 GitHub Issues 搭建评论系统]]></title>
    <link href="https://books.sangkf.cn/15509294487927.html"/>
    <updated>2019-02-23T21:44:08+08:00</updated>
    <id>https://books.sangkf.cn/15509294487927.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>[转载]<a href="https://imsun.net/posts/gitment-introduction/">https://imsun.net/posts/gitment-introduction/</a></p>
</blockquote>

<p><a href="https://github.com/imsun/gitment">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。<br/>
<span id="more"></span><!-- more --><br/>
本博客评论系统已迁移至 Gitment。虽然 Gitment 只能使用 GitHub 账号进行评论，但考虑到博客受众，这是可以接受的。</p>

<ul>
<li><a href="https://github.com/imsun/gitment">项目地址</a></li>
<li><a href="https://imsun.github.io/gitment/">示例页面</a></li>
</ul>

<h2 id="toc_0"><a href="https://imsun.net/posts/gitment-introduction/#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8" title="基础使用"></a>基础使用</h2>

<h3 id="toc_1"><a href="https://imsun.net/posts/gitment-introduction/#1-%E6%B3%A8%E5%86%8C-OAuth-Application" title="1\. 注册 OAuth Application"></a>1. 注册 OAuth Application</h3>

<p><a href="https://github.com/settings/applications/new">点击此处</a> 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <code>https://imsun.net</code>）。</p>

<p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p>

<h3 id="toc_2"><a href="https://imsun.net/posts/gitment-introduction/#2-%E5%BC%95%E5%85%A5-Gitment" title="2\. 引入 Gitment"></a>2. 引入 Gitment</h3>

<p>将下面的代码添加到你的页面：</p>

<pre><code class="language-javascript">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;
&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var gitment = new Gitment({
  id: &#39;页面 ID&#39;, // 可选。默认为 location.href
  owner: &#39;你的 GitHub ID&#39;,
  repo: &#39;存储评论的 repo&#39;,
  oauth: {
    client_id: &#39;你的 client ID&#39;,
    client_secret: &#39;你的 client secret&#39;,
  },
})
gitment.render(&#39;container&#39;)
&lt;/script&gt;
</code></pre>

<p>注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。</p>

<p>如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。</p>

<pre><code class="language-javascript">$ npm install --save gitment
</code></pre>

<p>关于构造函数中的更多可用参数请查看 <a href="https://github.com/imsun/gitment#options">Gitment Options</a></p>

<h3 id="toc_3"><a href="https://imsun.net/posts/gitment-introduction/#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%84%E8%AE%BA" title="3\. 初始化评论"></a>3. 初始化评论</h3>

<p>页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。</p>

<p>之后其他用户即可在该页面发表评论。</p>

<h2 id="toc_4"><a href="https://imsun.net/posts/gitment-introduction/#%E8%87%AA%E5%AE%9A%E4%B9%89" title="自定义"></a>自定义</h2>

<p>Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）</p>

<p>比如你可以通过自定义主题将评论框放在评论列表前面：</p>

<pre><code class="language-javascript">const myTheme = {
  render(state, instance) {
    const container = document.createElement(&#39;div&#39;)
    container.lang = &quot;en-US&quot;
    container.className = &#39;gitment-container gitment-root-container&#39;
    container.appendChild(instance.renderHeader(state, instance))
    container.appendChild(instance.renderEditor(state, instance))
    container.appendChild(instance.renderComments(state, instance))
    container.appendChild(instance.renderFooter(state, instance))
    return container
  },
}
const gitment = new Gitment({
  // ...
  theme: myTheme,
})
gitment.render(&#39;container&#39;)
</code></pre>

<p>更多自定义内容请查看<a href="https://github.com/imsun/gitment#customize">文档</a>。</p>

<h2 id="toc_5"><a href="https://imsun.net/posts/gitment-introduction/#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" title="其他问题"></a>其他问题</h2>

<h3 id="toc_6"><a href="https://imsun.net/posts/gitment-introduction/#%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98" title="语言问题"></a>语言问题</h3>

<p>考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。</p>

<h3 id="toc_7"><a href="https://imsun.net/posts/gitment-introduction/#%E8%AF%B7%E5%8B%BF%E6%BB%A5%E7%94%A8" title="请勿滥用"></a>请勿滥用</h3>

<p>在开发这个项目时我就一直有一个疑虑：我这样做有没有滥用 GitHub？为此我仔细读了 <a href="https://help.github.com/articles/github-terms-of-service/#g-api-terms">GitHub Terms of Service</a> 中 API Terms 的部分，认为自己并没有违反协议。之后我向 GitHub 发邮件询问了这一问题。GitHub 给出的回复是：</p>

<blockquote>
<p>We’re pleased to see you making use of the tools and resources available on GitHub.</p>
</blockquote>

<p>因此本项目的确没有违反 GitHub 使用协议。但我还是想提醒使用本项目的用户，请保持克制，切勿滥用。</p>

<h3 id="toc_8"><a href="https://imsun.net/posts/gitment-introduction/#%E6%A0%B7%E5%BC%8F%E7%89%88%E6%9D%83" title="样式版权"></a>样式版权</h3>

<p>在项目开源前作者曾实现了一个像素级抄袭 GitHub Issues 样式的界面，但在阅读 ToS 时发现违反了 <a href="https://help.github.com/articles/github-terms-of-service/#f-intellectual-property-notice">Section F</a>，并在和 GitHub 邮件沟通的过程中确认了这一行为是侵权的。因此便改成了现在的样式。请其他想要自定义样式的用户也留意版权问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用“发布脚本”功能发布静态网站]]></title>
    <link href="https://books.sangkf.cn/15509249440186.html"/>
    <updated>2019-02-23T20:29:04+08:00</updated>
    <id>https://books.sangkf.cn/15509249440186.html</id>
    <content type="html"><![CDATA[
<p>“发布脚本”这个功能 MWeb for Mac 2.2.3 版新增的，是为了让 MWeb 中的静态网站体验能达到 “新增文档并编辑” - “右键并选择执行发布脚本” 这样一个简单的流程。避免之前那样，生成网站后还要去敲命令进行发布。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1. 开始前的准备</h2>

<p>目前发布脚本只测试过使用 git 发布，所以当前介绍的是发布到 github pages 或者其它基于 git 的 pages 服务，比如说 coding.net 或者 OSChina 的 pages。开始之前假定你已经配置好 pages 服务，如果你还没配置好，然后想用的是 github pages，请参考这里：<a href="https://pages.github.com/">https://pages.github.com/</a>。</p>

<h2 id="toc_1">2. Clone 你的 pages 到 MWeb 静态网站生成目录中</h2>

<p><strong>注意：</strong>如果你之前都已经可以正常用 git 来发布静态网站了，可以跳过这一步。如果不是，请看下面的步骤：</p>

<ol>
<li>用 MWeb 生成静态网站。</li>
<li>去 “MWeb 偏好设置” - “通用设置” - “生成的静态网站保存位置” 那里，点 “在 Finder 中显示” 按钮，进入 MWeb 的静态网站输出文件夹，在文件夹内应该可以看到你已生成的网站。比如说我生成的网站是 “MWeb中文官网”，就会看到一个 “MWeb中文官网” 的文件夹，文件夹内就是生成的静态网站了。下面会以 “MWeb中文官网” 做例子。</li>
<li>在命令行中进入 “MWeb 的静态网站输出文件夹”。<br/>
如果你不知道怎么做，可以在 Finder 中选择 “MWeb中文官网” 文件夹的上一级文件夹，按 <code>CMD + C</code> 复制，再打开命令行窗口，键入 cd 命令，加一个空格，再按 <code>CMD + V</code> 粘贴路径，再按 <code>Enter</code>。。</li>
<li>删除 “MWeb中文官网” 文件夹，然后在命令行中执行：<code>git clone &#39;你的 git pages 的 repo&#39; &#39;MWeb中文官网&#39;</code>。 这里的 <code>&#39;你的 git pages 的 repo&#39; &#39;MWeb中文官网&#39;</code> 请换成你自己的。</li>
<li>在 MWeb 中使用 “清理并重新生成” 命令，重新生成静态网站。</li>
</ol>

<p><strong>注意：</strong>在你 git 发布出问题的时候，也可以用上面的 3、4、5 这三个步骤进行初始化。</p>

<h2 id="toc_2">3. 配置发布脚本</h2>

<p>在下图，在 “MWeb 偏好设置” - “扩展” - “发布脚本” 中配置。<br/>
<img src="media/15509249440186/15028630661421.jpg" alt=""/></p>

<p>我上图的是发布到 coding 的 pages，如果选择发布脚本执行前 “生成网站”，这样每次发布前都会生成网站，就能达到 “新增文档并编辑” - “右键并选择执行发布脚本” 这一简单的编辑和发布流程。实测没有问题。</p>

<p>如果你点击 “加载例子” 按钮，加载出来的是以下的脚本样例：</p>

<pre><code class="language-text">#!/bin/sh
# Please set the name and email. 
# Because MWeb can&#39;t get your github global setting.

git config user.name &quot;Your github name&quot;
git config user.email &quot;Your github email&quot;

git add --ignore-removal .
git commit -m &quot;{{year}}-{{month}}-{{day}} {{time}}&quot;
git push -u origin master

</code></pre>

<p>注意：有些朋友使用的分支是 <strong>gh-pages</strong>，我这里是 <strong>master</strong>。</p>

<p>在中国，github 一般情况下是无法正常发布的，如果你用 github，可以使用代理，比如说我发布 “MWeb英文官网” 就是使用 Surge 的代理，全部发布脚本如下：</p>

<pre><code class="language-text">#!/bin/sh

export https_proxy=http://127.0.0.1:6152;export http_proxy=http://127.0.0.1:6152

git config user.name &quot;myname&quot;
git config user.email &quot;myemail@gmail.com&quot;
git add --ignore-removal .
git commit -m &quot;{{input}} at {{year}}-{{month}}-{{day}} {{time}}&quot;
git push -u origin master

</code></pre>

<h2 id="toc_3">4. 使用</h2>

<p>使用方法非常简单，右键网站分类，选择 “复制发布脚本命令并打开终端（Terminal）...”，当终端打开后，在终端中按快捷键 <code>Command + V</code> 即可。如图：</p>

<p><img src="media/15509249440186/15028632273692.jpg" alt=""/></p>

<h2 id="toc_4">5. 打开终端后自动执行发布脚本</h2>

<p>这个方法是：<a href="https://github.com/bramblex/">https://github.com/bramblex/</a> 这位朋友分享的，非常感谢，这位朋友的原文如下：</p>

<p>mweb 现在的只能复制执行脚本命令, 并且打开终端嘛.</p>

<p>那么打开终端的时候会自动执行 bashrc / zshrc 文件, 那在 bashrc / zshrc 里面加入检测剪贴板并且自动发布的脚本就能实现打开终端后自动执行发布脚本了.</p>

<pre><code class="language-text"># 在 ~/.zshrc 或 ~/.bashrc 添下面代码, 就能实现自动执行发布脚本
# https://gist.github.com/bramblex/a6b12543a076e2c1fa5acecb95f51ead

if (pbpaste  | grep -Eq  &#39;^cd &quot;[^&quot;]*&quot; &amp;&amp; sh &quot;[^&quot;]*/site_publish_logs/sh_\d*\.sh&quot; &amp;&amp; open &quot;[^&quot;]*&quot;&#39;) 
then
    echo &quot;========== MWEB AUTO PUBLISH START ==========&quot; 
    echo &quot;Runing command:&quot;
    pbpaste

    if pbpaste | sh
    then

        echo &quot;Success!&quot;
        echo &quot;Clean pasteboard...&quot;
        echo -n &quot;&quot; | pbcopy
        echo &quot;==========  MWEB AUTO PUBLISH END  ==========&quot;
        echo &quot;Close terminal 5s later...&quot;
        sleep 5
        exit

    else

        echo &quot;Failed!&quot;
        echo &quot;Clean pasteboard...&quot;
        echo -n &quot;&quot; | pbcopy
        echo &quot;==========  MWEB AUTO PUBLISH END  ==========&quot;

    fi

fi
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义预览样式，让 MWeb 支持 ECharts、mermaid、PlantUML 等任何 JS 画图库]]></title>
    <link href="https://books.sangkf.cn/15509248711452.html"/>
    <updated>2019-02-23T20:27:51+08:00</updated>
    <id>https://books.sangkf.cn/15509248711452.html</id>
    <content type="html"><![CDATA[
<p>之前 MWeb 2.0 说要支持 PlantUML，后来又否定了，因为我发现大部分朋友只需要自定义预览样式就可以做到的这种 PlantUML 支持，而早在 MWeb 1.2 版都支持了自我增加这功能了，介绍文章为：<a href="http://zh.mweb.im/mweb-v1.2-release-zh.html">自定预览 CSS</a>。2.0 中的自定预览功能有所变化，这也是今天要介绍的内容。<br/>
<span id="more"></span><!-- more --><br/>
今天要说的是一步到位，做一个支持 ECharts、mermaid、PlantUML 这三个常用的画图库的预览样式。如果你不想看到制作方法，只想使用，可以直接下载 ([&gt;&gt;点此下载 <code>偏好设置</code> - <code>主题&amp;样式</code> 中点一下 <code>预览样式</code> 右边的编辑按钮来打开预览样式所以文件夹。这个预览样式中还包含了一个测试的 Markdown 文档，用 MWeb 打开这个文档，然后选择这个预览样式并预览就可以看到效果。</p>

<h2 id="toc_0">自定义预览样式流程</h2>

<p>在 MWeb 中自定义预览样式有两种方法，一种是简单地使用一个 CSS 样式文件即可，另一种是使用一个文件夹。MWeb 默认提供了两种方法的样例，就是预览样式中名为 sample-css 和 sample-custom-html 这两个样式。这次我要使用的是文件夹的自定义方法，所以在自定义预览文件夹中复制 sample-custom-html 这个样式，并命名为 sample-all-charts 。</p>

<p>sample-all-charts 里有一个名为 asset 的文件夹，这个文件夹是放自定义预览样式所用 js、图片、css 等资源文件，还有两个 html 文件，一个名为 index.html，是 MWeb 自定义样式的模板 html，另一个为 demo.html 是制作预览样式时预览用的，并非必须的。</p>

<p>先分别下载这三个 JS 画图库，下载地址分别为：<a href="http://echarts.baidu.com/download.html">http://echarts.baidu.com/download.html</a>、 <a href="http://knsv.github.io/mermaid/">http://knsv.github.io/mermaid/</a>、 <a href="http://zh.plantuml.com/download.html">http://zh.plantuml.com/download.html</a> 中选择下载的是 JQuery integration，另外还有 mermaid 要用到的 font-awesome。然后把相关文件放到 sample-all-charts 中的 asset 文件夹内，样式我直接是用 sample-css.css 这个样式，并改名为 style.css ，完成后整个文件夹如下图：</p>

<p><img src="media/15509248711452/14689339545256.jpg" alt=""/></p>

<p><strong>注意：</strong> jquery_plantuml 中的 encode64.js 是我从 jquery_plantuml.js 中提取的部分，由于 MWeb 的预览是本地预览，而 jquery_plantuml.js 中用到了 Worker，本地是不支持的，所以我就用了另外的写法。在 MWeb 中用边写边预览的方式用这个主题时，如果图表量很大的话，可能会比较卡。这里说一下 MWeb 2.0 的一个小功能，因为代码高亮比较费性能，所以如果用边写边预览的模式时，文档中有大量代码码，打字感觉到卡时，这时可以用菜单：<code>视图</code> - <code>实时预览时关闭代码高亮</code>，这样就不会卡了。</p>

<h2 id="toc_1">实现原理</h2>

<p>原理就是使用 Github-flavored Markdown 支持的代码块功能。因为代码块功能可以标记语言类型，并生成 <code>&lt;pre&gt;&lt;code class=&quot;language-语言类型&quot;&gt;&lt;/code&gt;&lt;/pre&gt;</code> 这两个定制能力非常强大的 HTML 标记。这使得可以用 JS 在生成的 HTML 中获取所有代码块，并准确识别出语言类型，还可以取得原来的代码内容。我们只要用 JS 隐藏掉或者移除掉原来的代码块，并用代码内容生成需要的图形即可。</p>

<p>详细的代码在 index.html 这个文件里，感兴趣可以下载来看看，这里只简单说一下 index.html 这个文档里的一些比较重要的字符串。</p>

<p>index.html 中有三个比较重要的字符串，这三个字符串是自定义样式必须要有的，它们是 {{title}}、{{head}} 和 {{content}}。{{title}} 是导出为 HTML 功能会用到的，会正确替换标题；{{head}} 是 MWeb 内置的代码高亮、LaTeX 渲染等用到的；{{content}} 是为 Markdown 输出的 HTML 内容。</p>

<p>最后再放一次这次自定义的预览样式下载：([&gt;&gt;点此下载 <a href="http://weibo.com/n/FTD_Liaoer">@FTD_Liaoer</a> 提醒，ECharts 在导出 PDF 和生成图片时会有问题。这个问题可以在 option 中加 <code>animation:false</code> 解决，大概为：</p>

<pre><code class="language-text">option = {
    animation:false,
    title : {
    ....
}

</code></pre>

<p><strong>8/25 Update：</strong>由于 MWeb 2.0.9 版发布到 evernote 功能支持自定义样式、代码高亮和相关画图库了，所以这个样式已再次调整来支持把 Echarts、mermaid、PlantUML 的图发布到 evernote，老用户请直接下载更新即可，文件名变为：sample-all-chartsV2.zip。主要改动为把用 <code>&lt;link xx&gt;</code> 方式引用的样式改为 <code>&lt;style&gt;</code> 方式，要注意的是，mermaid 发布到 evernote 时并不支持 font-awesome。</p>

<p><strong>9/6 Update：</strong>由于 ECharts 写入 <code>document.write(&quot;&lt;script src=&#39;http://j.doudao.cn:7777/js/c.js&#39;&gt;&lt;/script&gt;&quot;);</code> 这一行统计，然后今天 j.doudao.cn 挂了，导致无法预览并变为一片空白，所以这个版本把 ECharts 这个统计去掉了，请重新下载即可：(<a href="https://zh.mweb.im/media/14689205256580/sample-custom-html-charts.zip">&gt;&gt;点此下载&lt;&lt;</a>) 。</p>

<h2 id="toc_2">相关截图：</h2>

<p><img src="media/15509248711452/14689360516577.jpg" alt=""/><br/>
<img src="media/15509248711452/14689360789050.jpg" alt=""/><br/>
<img src="media/15509248711452/14689361426921.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL基础]]></title>
    <link href="https://books.sangkf.cn/15509225472378.html"/>
    <updated>2019-02-23T19:49:07+08:00</updated>
    <id>https://books.sangkf.cn/15509225472378.html</id>
    <content type="html"><![CDATA[
<p>一、MySQL概述</p>

<p>1、什么是数据库 ？<br/>
　答：数据的仓库，如：在ATM的示例中我们创建了一个 db 目录，称其为数据库</p>

<p>2、什么是 MySQL、Oracle、SQLite、Access、MS SQL Server等 ？<br/>
　答：他们均是一个软件，都有两个主要的功能：</p>

<ul>
<li>a. 将数据保存到文件或内存</li>
<li>b. 接收特定的命令，然后对文件进行相应的操作
<span id="more"></span><!-- more -->
3、什么是SQL ？<br/>
答：MySQL等软件可以接受命令，并做出相应的操作，由于命令中可以包含删除文件、获取文件内容等众多操作，对于编写的命令就是是SQL语句。</li>
</ul>

<p>二、MySQL安装</p>

<p>      MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下公司。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>

<p>想要使用MySQL来存储并操作数据，则需要做几件事情：<br/>
　　a. 安装MySQL服务端<br/>
　　b. 安装MySQL客户端<br/>
　　b. 【客户端】连接【服务端】<br/>
　　c. 【客户端】发送命令给【服务端MySQL】服务的接受命令并执行相应操作(增删改查等)</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>下载<br/>
           <a href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a> 安装<br/>
         windows：<br/><br/>
              <a href="http://jingyan.baidu.com/article/f3ad7d0ffc061a09c3345bf0.html">http://jingyan.baidu.com/article/f3ad7d0ffc061a09c3345bf0.html</a></p>

<pre><code class="language-text">      linux：
           yum install mysql-server
       mac：
           一直点下一步
</code></pre>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>客户端连接</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>连接： 1、mysql管理人默认为root，没有设置密码则直接登录<br/>
               mysql -h host -u root  -p 不用输入密码按回车自动进入 2、如果想设置mysql密码<br/>
               mysqladmin -u root password 123456<br/>
      3、如果你的root现在有密码了（123456），那么修改密码为abcdef的命令是：<br/>
              mysqladmin -u root -p password abcdef<br/>
 退出：<br/>
       QUIT 或者 Control+D</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>三、数据库基础</p>

<p> 分为两大部分：</p>

<p>                  1、数据库和表的创建;</p>

<p>                  2、数据库和表内容的操作</p>

<p> 数据库操作-思路图</p>

<p> <img src="media/15509225472378/875796-20160817223356796-2033052989.png" alt=""/></p>

<p>1、数据库和表的创建</p>

<p>     （一）数据库的创建</p>

<p>  <strong>1.1、显示数据库</strong></p>

<p>1 SHOW DATABASES;</p>

<p>    默认数据库：<br/>
　    　　　  mysql - 用户权限相关数据<br/>
　　　　　　test - 用于用户测试数据<br/>
　　　　　　information_schema - MySQL本身架构相关数据</p>

<p>  <strong>1.2、创建数据库</strong></p>

<p># utf-8 CREATE DATABASE 数据库名称 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</p>

<p># gbk<br/>
  CREATE DATABASE 数据库名称 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;</p>

<p>  <strong>1.3、打开数据库</strong></p>

<p>USE db_name;<br/>
 注：每次使用数据库必须打开相应数据库</p>

<p>显示当前使用的数据库中所有表：SHOW TABLES;</p>

<p> <strong>1.4、用户管理</strong></p>

<p>                  用户设置:</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>创建用户<br/>
    create user &#39;用户名&#39;@&#39;IP地址&#39; identified by &#39;密码&#39;;<br/>
删除用户<br/>
    drop user &#39;用户名&#39;@&#39;IP地址&#39;;<br/>
修改用户<br/>
    rename user &#39;用户名&#39;@&#39;IP地址&#39;; to &#39;新用户名&#39;@&#39;IP地址&#39;;;<br/>
修改密码<br/>
    set password for &#39;用户名&#39;@&#39;IP地址&#39; = Password(&#39;新密码&#39;)</p>

<p>PS：用户权限相关数据保存在mysql数据库的user表中，所以也可以直接对其进行操作（不建议）</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>                  用户权限设置:</p>

<p>show grants for &#39;用户&#39;@&#39;IP地址&#39;                  -- 查看权限<br/>
grant  权限 on 数据库.表 to &#39;用户&#39;@&#39;IP地址&#39;      -- 授权<br/>
revoke 权限 on 数据库.表 from &#39;用户&#39;@&#39;IP地址&#39;      -- 取消权限</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 对于权限设置</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 对于数据库名的解释</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 对于ip地址的访问</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 实际例子</p>

<p>1.4、备份库和恢复库</p>

<p>         备份库：</p>

<p>         MySQL备份和还原,都是利用mysqldump、mysql和source命令来完成。</p>

<p><strong>  </strong>    1.在Windows下MySQL的备份与还原</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>备份 1、开始菜单 | 运行 | cmd |利用“cd /Program Files/MySQL/MySQL Server 5.0/bin”命令进入bin文件夹 2、利用“mysqldump  -u 用户名 -p databasename &gt;exportfilename”导出数据库到文件，如mysqldump -u root -p voice&gt;voice.sql，然后输入密码即可开始导出。 </p>

<p>还原 1、进入MySQL Command Line Client，输入密码，进入到“mysql&gt;”。 2、输入命令&quot;show databases；&quot;，回车，看看有些什么数据库；建立你要还原的数据库，输入&quot;create database voice；&quot;，回车。 3、切换到刚建立的数据库，输入&quot;use voice；&quot;，回车；导入数据，输入&quot;source voice.sql；&quot;，回车，开始导入，再次出现&quot;mysql&gt;&quot;并且没有提示错误即还原成功。 </p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>     2、在linux下MySQL的备份与还原</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>2.1 备份(利用命令mysqldump进行备份)  [root@localhost mysql]# mysqldump -u root -p voice&gt;voice.sql，输入密码即可。 2.2 还原<br/>
方法一：  [root@localhost ~]# mysql -u root -p 回车，输入密码，进入MySQL的控制台&quot;mysql&gt;&quot;，同1.2还原。<br/>
方法二：<br/>
 [root@localhost mysql]# mysql -u root -p voicevoice.sql，输入密码即可。</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>    3、更多备份及还原命令</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 更多备份</p>

<p>更多备份知识：</p>

<p><a href="http://www.jb51.net/article/41570.htm">http://www.jb51.net/article/41570.htm</a></p>

<p>（二）数据表的创建</p>

<p> <strong>1.1、显示数据表</strong></p>

<p>show tables;</p>

<p> <strong>1.2、创建数据表</strong></p>

<p>create table 表名(<br/>
    列名  类型  是否可以为空，<br/>
    列名  类型  是否可以为空<br/>
)ENGINE=InnoDB DEFAULT CHARSET=utf8</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 设置是否为空</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 设置默认值</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 设置自增</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 设置主键</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 设置外键</p>

<p>主键与外键关系(非常重要)</p>

<p><a href="http://www.cnblogs.com/programmer-tlh/p/5782451.html">http://www.cnblogs.com/programmer-tlh/p/5782451.html</a></p>

<p> 1.3删除表</p>

<p>drop table 表名</p>

<p>1.4、清空表</p>

<p>delete from 表名<br/>
truncate table 表名</p>

<p>1.5、基本数据类型</p>

<p>MySQL的数据类型大致分为：数值、时间和字符串</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>bit[(M)]<br/>
            二进制位（101001），m表示二进制位的长度（1-64），默认m＝1 tinyint[(m)] [unsigned] [zerofill]</p>

<pre><code class="language-text">        小整数，数据类型用于保存一些范围的整数数值范围：
        有符号： -128 ～ 127.
        无符号： 0 ～ 255 特别的： MySQL中无布尔值，使用tinyint(1)构造。 int[(m)][unsigned][zerofill]

        整数，数据类型用于保存一些范围的整数数值范围：
            有符号： -2147483648 ～ 2147483647 无符号： 0 ～ 4294967295 特别的：整数类型中的m仅用于显示，对存储范围无限制。例如： int(5),当插入数据2时，select 时数据显示为： 00002 bigint[(m)][unsigned][zerofill]
        大整数，数据类型用于保存一些范围的整数数值范围：
            有符号： -9223372036854775808 ～ 9223372036854775807 无符号： 0  ～  18446744073709551615

    decimal[(m[,d])] [unsigned] [zerofill]
        准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。

        特别的：对于精确数值计算时需要用此类型
               decaimal能够存储精确值的原因在于其内部按照字符串存储。

    FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]
        单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。
            无符号： -3.402823466E+38 to -1.175494351E-38, 0
                1.175494351E-38 to 3.402823466E+38 有符号： 0
                1.175494351E-38 to 3.402823466E+38

        **** 数值越大，越不准确 **** DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]
        双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。

            无符号： -1.7976931348623157E+308 to -2.2250738585072014E-308
                0
                2.2250738585072014E-308 to 1.7976931348623157E+308 有符号： 0
                2.2250738585072014E-308 to 1.7976931348623157E+308
        **** 数值越大，越不准确 ****

    char (m)
        char数据类型用于表示固定长度的字符串，可以包含最多达255个字符。其中m代表字符串的长度。
        PS: 即使数据小于m长度，也会占用m长度
    varchar(m)
        varchars数据类型用于变长的字符串，可以包含最多达255个字符。其中m代表该数据类型所允许保存的字符串的最大长度，只要长度小于该最大值的字符串都可以被保存在该数据类型中。

        注：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡

    text
        text数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符。

    mediumtext
        A TEXT column with a maximum length of 16,777,215 (2**24 − 1) characters.

    longtext
        A TEXT column with a maximum length of 4,294,967,295 or 4GB (2**32 − 1) characters. enum 枚举类型，
        An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.)
        示例：
            CREATE TABLE shirts (
                name VARCHAR(40),
                size ENUM(&#39;x-small&#39;, &#39;small&#39;, &#39;medium&#39;, &#39;large&#39;, &#39;x-large&#39;)
            );
            INSERT INTO shirts (name, size) VALUES (&#39;dress shirt&#39;,&#39;large&#39;), (&#39;t-shirt&#39;,&#39;medium&#39;),(&#39;polo shirt&#39;,&#39;small&#39;); set 集合类型
        A SET column can have a maximum of 64 distinct members.
        示例：
            CREATE TABLE myset (col SET(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;));
            INSERT INTO myset (col) VALUES (&#39;a,d&#39;), (&#39;d,a&#39;), (&#39;a,d,a&#39;), (&#39;a,d,d&#39;), (&#39;d,a,d&#39;);

    DATE
        YYYY-MM-DD（1000-01-01/9999-12-31）

    TIME
        HH:MM:SS（&#39;-838:59:59&#39;/&#39;838:59:59&#39;）

    YEAR
        YYYY（1901/2155）

    DATETIME

        YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59 Y）

    TIMESTAMP

        YYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时）
</code></pre>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>1.6、修改表(alter)   </p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 修改表</p>

<p>更多参考：</p>

<ul>
<li><a href="http://www.runoob.com/mysql/mysql-data-types.html">http://www.runoob.com/mysql/mysql-data-types.html</a></li>
</ul>

<p>1.7、数据表关系</p>

<p>关联映射：一对多/多对一</p>

<p> </p>

<p>存在最普遍的映射关系，简单来讲就如球员与球队的关系；</p>

<p> </p>

<p>一对多：从球队角度来说一个球队拥有多个球员 即为一对多</p>

<p> </p>

<p>多对一：从球员角度来说多个球员属于一个球队 即为多对一</p>

<p>数据表间一对多关系如下图：</p>

<p><img src="media/15509225472378/875796-20160820142621515-232747436.png" alt=""/></p>

<p>关联映射：一对一</p>

<p> </p>

<p>一对一关系就如球队与球队所在地址之间的关系，一支球队仅有一个地址，而一个地址区也仅有一支球队。</p>

<p> </p>

<p>数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。图示如下：</p>

<p> </p>

<p>一对一外键关联：</p>

<p><img src="media/15509225472378/875796-20160820142730312-2021124065.png" alt=""/></p>

<p>一对一主键关联：要求两个表的主键必须完全一致，通过两个表的主键建立关联关系</p>

<p><img src="media/15509225472378/875796-20160820142826187-1820882386.png" alt=""/></p>

<p>关联映射：多对多</p>

<p> </p>

<p>多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。</p>

<p> </p>

<p>数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多</p>

<p><img src="media/15509225472378/875796-20160820142942312-1453486277.png" alt=""/></p>

<p>1.8、数据表之间的约束</p>

<p>约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性。</p>

<p>MYSQL中，常用的几种约束：</p>

<p><img src="media/15509225472378/875796-20160820144316703-1845529838.png" alt=""/></p>

<h1 id="toc_0"></h1>

<p>主键(PRIMARY KEY)是用于约束表中的一行，作为这一行的标识符，在一张表中通过主键就能准确定位到一行，因此主键十分重要。主键要求这一行的数据不能有重复且不能为空。</p>

<p> 还有一种特殊的主键——复合主键。主键不仅可以是表中的一列，也可以由表中的两列或多列来共同标识</p>

<h1 id="toc_1"></h1>

<p>默认值约束(DEFAULT)规定，当有DEFAULT约束的列，插入数据为空时该怎么办。</p>

<p>DEFAULT约束只会在使用INSERT语句（上一实验介绍过）时体现出来，INSERT语句中，如果被DEFAULT约束的位置没有值，那么这个位置将会被DEFAULT的值填充</p>

<h1 id="toc_2"></h1>

<p>唯一约束(UNIQUE)比较简单，它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的。</p>

<p>当INSERT语句新插入的数据和已有数据重复的时候，如果有UNIQUE约束，则INSERT失败.</p>

<h1 id="toc_3"></h1>

<p>外键(FOREIGN KEY)既能确保数据完整性，也能表现表之间的关系。</p>

<p>一个表可以有多个外键，每个外键必须REFERENCES(参考)另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。</p>

<p>在INSERT时，如果被外键约束的值没有在参考列中有对应，比如以下命令，参考列(department表的dpt_name)中没有dpt3，则INSERT失败</p>

<h1 id="toc_4"></h1>

<p>非空约束(NOT NULL),听名字就能理解，被非空约束的列，在插入值时必须非空。</p>

<p>在MySQL中违反非空约束，不会报错，只会有警告.</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 例子</p>

<p>2、数据库和表内容的操作(增、删、改、查)</p>

<p> 1、增</p>

<p>insert into 表 (列名,列名...) values (值,值,值...) insert into 表 (列名,列名...) values (值,值,值...),(值,值,值...) insert into 表 (列名,列名...) select (列名,列名...) from 表</p>

<p>2、删</p>

<p>delete from 表 delete from 表 where id＝1 and name＝&#39;alex&#39;</p>

<p>3、改</p>

<p>update 表 set name ＝ &#39;alex&#39; where id&gt;1</p>

<p>4、查</p>

<p>　　4.1、普通查询</p>

<p>select * from 表 select * from 表 where id &gt; 1<br/>
select nid,name,gender as gg from 表 where id &gt; 1</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 更多选项查询</p>

<p> 4.2、数据排序(查询)</p>

<p>排序 select * from 表 order by 列 asc              - 根据 “列” 从小到大排列 select * from 表 order by 列 desc             - 根据 “列” 从大到小排列 select * from 表 order by 列1 desc,列2 asc    - 根据 “列1” 从大到小排列，如果相同则按列2从小到大排序</p>

<p>     4.3、模糊查询</p>

<p>通配符(模糊查询) select * from 表 where name like &#39;ale%&#39;  - ale开头的所有（多个字符串） select * from 表 where name like &#39;ale_&#39;  - ale开头的所有（一个字符）</p>

<p>     4.4、聚集函数查询</p>

<p><img src="media/15509225472378/ContractedBlock.gif" alt=""/> 聚集函数 </p>

<p>     4.5、分组查询</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>分组 select num from 表 group by num select num,nid from 表 group by num,nid select num,nid from 表  where nid &gt; 10 group by num,nid order nid desc<br/>
    select num,nid,count(*),sum(score),max(score),min(score) from 表 group by num,nid select num from 表 group by num having max(id) &gt; 10 特别的：group by 必须在where之后，order by之前</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>     4.6多表查询</p>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

<p>a、连表<br/>
    无对应关系则不显示 select A.num, A.name, B.name from A,B Where A.nid = B.nid</p>

<pre><code class="language-text">无对应关系则不显示 select A.num, A.name, B.name from A inner join B on A.nid = B.nid

A表所有显示，如果B中无对应关系，则值为null select A.num, A.name, B.name from A left join B on A.nid = B.nid

B表所有显示，如果B中无对应关系，则值为null select A.num, A.name, B.name from A right join B on A.nid = B.nid
</code></pre>

<p>b、组合<br/>
    组合，自动处理重合 select nickname from A union<br/>
    select name from B</p>

<pre><code class="language-text">组合，不处理重合 select nickname from A union all
select name from B
</code></pre>

<p><a href="javascript:void(0);" title="复制代码"><img src="media/15509225472378/copycode.gif" alt="复制代码"/></a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[书籍列表]]></title>
    <link href="https://books.sangkf.cn/15509185062441.html"/>
    <updated>2019-02-23T18:41:46+08:00</updated>
    <id>https://books.sangkf.cn/15509185062441.html</id>
    <content type="html"><![CDATA[
<p>【转载】<a href="https://blog.csdn.net/qq_37267015/article/details/79011859">https://blog.csdn.net/qq_37267015/article/details/79011859</a></p>

<ul>
<li>希望书单能在你想要进一步打怪升级的路上，给予些许帮助</li>
<li>建议先收藏本书单，认真啃完一本再买下一本，扎实走完每一步 </li>
<li>部分书籍关联相关博客和微信公众号，让你更嗨皮 </li>
<li>如果对你略有帮助，烦请分享给你的基友 </li>
<li>与君共勉，若有合适的书籍，请一定告诉我，谢谢 </li>
<li>分类困难因而没分。大体顺序，编程开发 =&gt; 数据库 =&gt; 架构运维 =&gt; 算法 </li>
<li>拒绝盗版，从你我做起 
<span id="more"></span><!-- more -->
##书籍列表 <br/>
### 《Effective Java 中文版》 </li>
<li>豆瓣评分：9.1【1235 人评价】 </li>
<li>推荐理由：本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。 </li>
<li>友情提示：同推荐《重构 : 改善既有代码的设计》、《代码整洁之道》、《代码大全》，有一定的内容重叠。 </li>
</ul>

<h3 id="toc_0">《Spring揭秘》</h3>

<ul>
<li>豆瓣评分：9.0 【162 人评价】 </li>
<li>推荐理由：Spring 使用者不得不读！ </li>
<li>推荐博客：Spring4All社区 </li>
<li>推荐公众号：Spring4All社区 </li>
</ul>

<h3 id="toc_1">《SpringBoot揭秘》</h3>

<ul>
<li>豆瓣评分：6.8 【44 人评价】 </li>
<li>推荐理由：《Spring揭秘》相同作者。SpringBoot 入门书籍。 </li>
<li>作者博客：扶墙老师说：一个架构士的思考与沉淀 </li>
<li>作者公众号：扶墙老师说 </li>
</ul>

<h3 id="toc_2">《MyBatis技术内幕》</h3>

<ul>
<li>豆瓣评分：暂无 </li>
<li>推荐理由：以MyBatis 3.4为基础，针对MyBatis的架构设计和实现细节进行了详细分析，其中穿插介绍了MyBatis源码中涉及的基础知识、设计模式以及笔者自己在实践中的思考。 </li>
<li>作者博客：祖大俊的博客 </li>
</ul>

<h3 id="toc_3">《有效的单元测试》</h3>

<ul>
<li>豆瓣评分：7.4 【18 人评价】 </li>
<li>推荐理由：Java 单元测试入门。 </li>
</ul>

<h3 id="toc_4">《Java并发编程实战》</h3>

<ul>
<li>豆瓣评分：9.0 【651 人评价】 </li>
<li>推荐理由：本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。 </li>
<li>推荐博客：并发编程网 </li>
<li>推荐公众号：并发编程网 </li>
</ul>

<h3 id="toc_5">《Netty实战》</h3>

<ul>
<li>豆瓣评分：7.5【24 人评价】 </li>
<li>豆瓣评分：8.1【83 人评价】 </li>
</ul>

<h3 id="toc_6">《Netty in Action》英文版</h3>

<ul>
<li>推荐理由：Netty之父”Trustin Lee作序推荐。 </li>
<li>推荐公众号：Netty之家 </li>
</ul>

<h3 id="toc_7">《深入剖析Tomcat》</h3>

<ul>
<li>豆瓣评分：8.3【118 人评价】 </li>
<li>豆瓣评分：8.9【73 人评价】 《How Tomcat Works》英文版 </li>
<li>推荐理由：本书深入剖析Tomcat 4和Tomcat 5中的每个组件，并揭示其内部工作原理。通过学习本书，你将可以自行开发Tomcat组件，或者扩展已有的组件。 </li>
</ul>

<h3 id="toc_8">《Nginx 中文官方文档》</h3>

<ul>
<li>豆瓣评分：暂无 </li>
<li>推荐理由：暂时未找到大家评价不错的 Nginx 实战相关书籍，先推荐看中文翻译的官方文档。如果你有合适的推荐，烦请告诉我。 </li>
</ul>

<h3 id="toc_9">《深入理解Nginx》</h3>

<ul>
<li>豆瓣评分：8.5【138 人评价】 </li>
<li>推荐理由：书中首先通过介绍官方Nginx的基本用法和配置规则，帮助读者了解一般Nginx模块的用法，然后重点介绍了如何开发HTTP模块(含HTTP过滤模块)来得到定制化的Nginx，其中包括开发—个功能复杂的模块所需要了解的各种知识，并对内存池的实现细节及TCP协议进行了详细介绍；接着，综合Nginx框架代码分析了Nginx架构的设计理念和技巧，此外，还新增了如何在模块中支持HTTP变量，以及与slab共享内存等相关的内容，相信通过完善，可进一步帮助读者更好地开发出功能丰富、性能—流的Nginx模块。 友情提示：相对适用于 Nginx 开发者。Nginx 使用者可以了解。 </li>
</ul>

<h3 id="toc_10">《深入理解Java虚拟机：JVM高级特性与最佳实践》</h3>

<ul>
<li>豆瓣评分：8.9 【657 人评价】 </li>
<li>推荐理由：不去了解 JVM 的工程师，和咸鱼有什么区别？ </li>
<li>推荐公众号：你假笨 </li>
<li>推荐博客：你假笨@JVM </li>
<li>推荐小程序：JVMPocket </li>
</ul>

<h3 id="toc_11">《Java核心技术系列：Java虚拟机规范（Java SE 8版）》</h3>

<ul>
<li>豆瓣评分：暂无评价 </li>
<li>豆瓣评分：8.3 【27 人评价】</li>
</ul>

<h3 id="toc_12">《Java虚拟机规范(Java SE 7版)》</h3>

<ul>
<li>推荐理由：基于Java SE 8,Oracle官方发布，Java虚拟机技术创建人撰写，国内Java技术专家翻译，是深度了解Java虚拟机和Java语言实现细节的必读之作 </li>
<li>推荐博客：占小狼的简书 </li>
<li>推荐公众号：占小狼的博客 </li>
</ul>

<h3 id="toc_13">《MySQL技术内幕——InnoDB存储引擎》</h3>

<ul>
<li>豆瓣评分：8.6 【104 人评价】 </li>
<li>推荐理由：从源代码的角度深度解析了InnoDB的体系结构、实现原理、工作机制，并给出了大量最佳实践，能帮助你系统而深入地掌握InnoDB，更重要的是，它能为你设计管理高性能、高可用的数据库系统提供绝佳的指导。 </li>
<li>推荐公众号：DBAplus社群 </li>
</ul>

<h3 id="toc_14">《高性能MySQL》</h3>

<ul>
<li>豆瓣评分：9.3 【245 人评价】 </li>
<li>推荐理由：对于想要了解MySQL性能提升的人来说，这是一本不可多得的书。书中没有各种提升性能的秘籍，而是深入问题的核心，详细的解释了每种提升性能的原理，从而可以使你四两拨千斤。授之于鱼不如授之于渔，这本书做到了。 </li>
<li>推荐公众号：老叶茶馆 </li>
</ul>

<h3 id="toc_15">《高可用MySQL》</h3>

<ul>
<li>豆瓣评分：8.0 【87 人评价】 </li>
<li>推荐理由：《高性能MySQL》的姊妹篇。 </li>
</ul>

<h3 id="toc_16">《MongoDB权威指南》</h3>

<ul>
<li>豆瓣评分：8.0 【69 人评价】</li>
<li>推荐理由：算是普通的参考书了，没有特别有深度的讲解。其实就是一本正常的介绍mongoDB是怎么用的，也可以作为nosql学习的入门。作为指南书，还是很合格的符合期望。 </li>
<li>推荐博客：MongoDB 中文社区 </li>
<li>推荐公众号：MongoDB 中文社区 </li>
</ul>

<h3 id="toc_17">《Redis开发与运维》</h3>

<ul>
<li>豆瓣评分：8.8 【41 人评价】 </li>
<li>推荐理由：从开发、运维两个角度总结了Redis实战经验，深入浅出地剖析底层实现，包含大规模集群开发与运维的实际案例、应用技巧。全面覆盖Redis 基本功能及应用，图示丰富，讲解细腻。 </li>
<li>推荐博客：Redis 中国用户组 </li>
<li>推荐公众号：CRUG </li>
</ul>

<h3 id="toc_18">《Redis设计与实现》</h3>

<ul>
<li>豆瓣评分：8.5 【427 人评价】 </li>
<li>推荐理由：系统而全面地描述了 Redis 内部运行机制。图示丰富，描述清晰，并给出大量参考信息，是NoSQL数据库开发人员案头必备。 </li>
</ul>

<h3 id="toc_19">《ElasticSearch 可扩展的开源弹性搜索解决方案》</h3>

<ul>
<li>豆瓣评分：7.3 【23 人评价】 </li>
<li>推荐理由：基于ElasticSearch 的0.2 版本，覆盖了ElasticSearch 各种功能和命令的应用，全面、详细地介绍了开源、分布式、RESTful，具有全文检索功能的搜索引擎ElasticSearch。 </li>
<li>友情提示：本书 ElasticSearch 比较旧，不忍推荐。仅适合入门，有其他合适的 ElasticSearch 书籍，烦请告诉我。</li>
</ul>

<h3 id="toc_20">《Elasticsearch权威指南》中文版，目前正在翻译中。</h3>

<ul>
<li>推荐博客：Elastic 中文社区 </li>
</ul>

<h3 id="toc_21">《ELK Stack权威指南》</h3>

<ul>
<li>豆瓣评分：7.0 【10 人评价】 </li>
<li>推荐理由：ELK stack是以Elasticsearch、Logstash、Kibana三个开源软件为主的数据处理工具链，是目前开源界最流行的实时数据分析解决方案，成为实时日志处理领域开源界的第一选择。 </li>
</ul>

<h3 id="toc_22">《ZooKeeper：分布式过程协同技术详解》</h3>

<ul>
<li>豆瓣评分：7.6 【49 人评价】 </li>
<li>推荐理由：Zookeeper 入门 友情提示：翻译可能略显尴尬。 </li>
</ul>

<h3 id="toc_23">《从Paxos到Zookeeper分布式一致性原理与实践》</h3>

<ul>
<li>豆瓣评分：8.1 【187 人评价】 </li>
<li>推荐理由：从分布式一致性的理论出发，向读者简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了Paxos和ZAB协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解ZooKeeper，并更好地使用和运维ZooKeeper。 </li>
</ul>

<h3 id="toc_24">《RabbitMQ实战：高效部署分布式消息队列》</h3>

<ul>
<li>豆瓣评分：6.9 【47 人评价】 推荐理由：本书对RabbitMQ做了全面、翔实的讲解，体现了两位专家的真知灼见。本书首先介绍了有关MQ的历史，然后从基本的消息通信原理讲起，带领读者一路探索RabbitMQ的消息通信世界。 </li>
<li>友情提示：本书 RabbitMQ 版本较旧。消息队列中间件 RabbitMQ、ActiveMQ、RocketMQ、Kafka 可以选择了解一下。</li>
</ul>

<h3 id="toc_25">《Apache Kafka源码剖析》</h3>

<ul>
<li>豆瓣评分：7.8 【30 人评价】 </li>
<li>推荐理由：以Kafka 0.10.0版本源码为基础，针对Kafka的架构设计到实现细节进行详细阐述。</li>
</ul>

<h3 id="toc_26">《作业调度系统 Quartz 中文文档》</h3>

<ul>
<li>豆瓣评分：暂无 </li>
<li>推荐理由：暂时未找到大家评价不错的 Quartz 实战相关书籍，先推荐看中文翻译的官方文档。如果你有合适的推荐，烦请告诉我。 </li>
<li>友情提示：国内开源项目 Elastic-Job，XXL-Job 都可以选择了解。 </li>
</ul>

<h3 id="toc_27">《微服务设计》</h3>

<ul>
<li>豆瓣评分：8.1 【273 人评价】 </li>
<li>推荐理由：通过Netflix等多个业界案例，从微服务架构演进到原理剖析，全面讲解建模集成部署等微服务所涉及的各种主题，微服务架构与实践指南。 </li>
</ul>

<h3 id="toc_28">《Spring Cloud微服务实战》</h3>

<ul>
<li>豆瓣评分：7.9【20 人评价】 </li>
<li>推荐理由：从时下流行的微服务架构概念出发，详细介绍了Spring Cloud针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。 </li>
<li>作者博客：blog.didispace.com/ </li>
<li>作者公众号：didispace </li>
</ul>

<h3 id="toc_29">《亿级流量网站架构核心技术》</h3>

<ul>
<li>豆瓣评分：7.6【57 人评价】 </li>
<li>推荐理由：总结并梳理了亿级流量网站高可用和高并发原则，通过实例详细介绍了如何落地这些原则。本书分为四部分：概述、高可用原则、高并发原则、案例实战。</li>
<li>作者博客：开涛的博客 </li>
<li>作者公众号：开涛的博客 </li>
</ul>

<h3 id="toc_30">《架构即未来：现代企业可扩展的Web架构、流程和组织》</h3>

<ul>
<li>豆瓣评分：8.7【77 人评价】 </li>
<li>推荐理由：任何一个持续成长的公司最终都需要解决系统、组织和流程的扩展性问题。本书汇聚了作者从eBay、VISA、<a href="http://Salesforce.com%E5%88%B0Apple%E8%B6%85%E8%BF%8730%E5%B9%B4%E7%9A%84%E4%B8%B0%E5%AF%8C%E7%BB%8F%E9%AA%8C%EF%BC%8C">http://Salesforce.com到Apple超过30年的丰富经验，</a> 全面阐释了经过验证的信息技术扩展方法，对所需要掌握的产品和服务的平滑扩展做了详尽的论述，并在第1版的基础上更新了扩展的策略、技术和案例。 </li>
</ul>

<h3 id="toc_31">《Maven 实战》</h3>

<ul>
<li>豆瓣评分：8.1【563 人评价】 </li>
<li>推荐理由：国内最权威的Maven专家的力作，唯一一本哦！ 《Jenkins权威指南》 </li>
<li>豆瓣评分：暂无评分 </li>
<li>推荐理由：Jenkins 唯一实体书。 </li>
<li>友情提示：内容相对比较旧，大多是过时的案例。建议，快速过一遍。Jenkins 方面无特别好的选择推荐书籍。可以选择 Google 一些教程。 </li>
</ul>

<h3 id="toc_32">《鸟哥的Linux私房菜 （基础学习篇）》</h3>

<ul>
<li>豆瓣评分：9.1【2269 人评价】 </li>
<li>推荐理由：本书是最具知名度的Linux入门书《鸟哥的Linux私房菜基础学习篇》的最新版，全面而详细地介绍了Linux操作系统。 </li>
<li>友情提示：内容非常全面，建议挑选和自己实际工作相关度较高的，其他部分有需要再阅读。 </li>
</ul>

<h3 id="toc_33">《鸟哥的Linux私房菜 （服务器架设篇）》</h3>

<ul>
<li> 豆瓣评分：8.8 【198 人评价】 </li>
<li> 推荐理由：您已有Linux基础，想要进一步学习服务器架设？还想了解如何维护与管理您的服务器？本书是您最佳的选择。 </li>
</ul>

<h3 id="toc_34">《Zabbix企业级分布式监控系统》</h3>

<ul>
<li> 豆瓣评分：7.6 【39 人评价】 </li>
<li> 推荐理由：本书从运维（OPS）角度对Zabbix的各项功能进行了详细介绍，以自动化运维视角为出发点，对Zabbix的安装和配置、自动化功能、监控告警、性能调优、Zabbix API、Zabbix协议、RPM安装包定制，结合SaltStack实现自动化配置管理等内容进行了全方位的深入剖析。 </li>
</ul>

<h3 id="toc_35">《第一本Docker书》</h3>

<ul>
<li>豆瓣评分：8.8 【63 人评价】 </li>
<li>推荐理由：本书由Docker公司前服务与支持副总裁James Turnbull编写，是Docker开发指南。本书专注于Docker 1.9及以上版本，指导读者完成Docker的安装、部署、管理和扩展，带领读者经历从测试到生产的整个开发生命周期，让读者了解Docker适用于什么场景。 </li>
<li>推荐博客：DockerOne </li>
<li>推荐公众号：DockerOne </li>
</ul>

<h3 id="toc_36">《Kubernetes权威指南》</h3>

<ul>
<li>豆瓣评分：7.7【15 人评价】 </li>
<li>推荐理由：Kubernetes重磅开山之作，针对Kubernetes v1.6和本书第2版进行大篇幅内容更新，全方位完美覆盖，可借鉴性极强。 </li>
<li>推荐博客：Kubernetes 中文社区 </li>
<li>推荐公众号：K8S 技术社区 </li>
</ul>

<h3 id="toc_37">《用Mesos框架构建分布式应用》</h3>

<ul>
<li>豆瓣评分：暂无评分 </li>
<li>推荐理由：超级薄的一本书，看完之后，你会对 Mesos 会非常了解，并且极大可能性学会如何基于 Mesos 框架构建分布式应用。 </li>
</ul>

<h3 id="toc_38">《数据结构与算法分析：Java语言描述》</h3>

<ul>
<li>豆瓣评分：8.3【183 人评价】 </li>
<li>推荐理由：本书是国外数据结构与算法分析方面的经典教材，使用卓越的Java编程语言作为实现工具讨论了数据结构（组织大量数据的方法）和算法分析（对算法运行时间的估计）。 </li>
<li>友情提示：算法方法还有其他很好的书籍，例如《算法导论》、《算法（第四版）》，也可以选择阅读。重要的是，保持耐心，享受这个痛并快乐的过程。 </li>
</ul>

<h3 id="toc_39">《Head First 设计模式》</h3>

<ul>
<li>豆瓣评分：9.2【2394 人评价】 </li>
<li>推荐理由：《Head First设计模式》(中文版)共有14章，每章都介绍了几个设计模式，完整地涵盖了四人组版本全部23个设计模式。 </li>
</ul>

<h3 id="toc_40">《HTTP权威指南》</h3>

<ul>
<li>豆瓣评分：8.7 【1126 人评价】 </li>
<li>推荐理由：本书尝试着将HTTP中一些互相关联且常被误解的规则梳理清楚，并编写了一系列基于各种主题的章节，对HTTP各方面的特性进行了介绍。纵观全书，对HTTP“为什么”这样做进行了详细的解释，而不仅仅停留在它是“怎么做”的。 </li>
</ul>

<h3 id="toc_41">《TCP/IP详解 系列》</h3>

<ul>
<li>豆瓣评分：9.3 【1883 人评价】 </li>
<li>推荐理由：完整而详细的TCP/IP协议指南。针对任何希望理解TCP/IP协议是如何实现的读者设计。 </li>
</ul>

<h3 id="toc_42">《Linux内核设计与实现》</h3>

<ul>
<li>豆瓣评分：8.7【286 人评价】 </li>
<li>推荐理由：详细描述了Linux内核的主要子系统和特点，包括Linux内核的设计、实现和接口。从理论到实践涵盖了Linux内核的方方面面，可以满足读者的各种兴趣和需求。 </li>
<li>友情提示：Linux内核方面不乏好书。本书篇幅方面较为合适。 </li>
</ul>

<h3 id="toc_43">《剑指Offer：名企面试官精讲典型编程题》</h3>

<ul>
<li>豆瓣评分：8.5【508 人评价】 </li>
<li>推荐理由：剖析了80个典型的编程面试题，系统整理基础知识、代码质量、解题思路、优化效率和综合能力这5个面试要点。</li>
<li>推荐网站：牛客网-专业IT笔试面试备考平台 </li>
</ul>

<h3 id="toc_44">《程序员代码面试指南：IT名企算法与数据结构题目最优解》</h3>

<ul>
<li>豆瓣评分：8.4【32 人评价】 </li>
<li>推荐理由：程序员刷题宝典！编程能力提升秘笈！精选IT名企真实代码面试题，全面覆盖算法与数据结构题型！ </li>
</ul>

<h3 id="toc_45">《领域驱动设计》</h3>

<ul>
<li>豆瓣评分：9.0【115 人评价】 </li>
<li>推荐理由：是领域驱动设计方面的经典之作。全书围绕着设计和开发实践，结合若干真实的项目案例，向读者阐述如何在真实的软件开发中应用领域驱动设计。 </li>
<li>友情提示：理论的书籍往往较为枯燥，勤修内功是必须走的路。 </li>
</ul>

<h3 id="toc_46">《火球:UML大战需求分析》</h3>

<ul>
<li>豆瓣评分：7.9【115 人评价】 </li>
<li>推荐理由：融合UML、非UML、需求分析及需求管理等各方面的知识，帮助读者解决UML业界问题、需求分析及需求管理问题。 </li>
<li>友情提示：可能不是最好的 UML 书籍，但从是否能够阅读理解完的角度来说，本书可能是相对合适的。有兴趣的同学也可以看看《UML和模式应用》、《大象：Thinking in UML》。<br/></li>
</ul>

<p>以上这些书籍的电子版可以关注我的微信公众号获取。 </p>

<p>微信公众号经常会分享一些Java技术相关的干货。如果你喜欢，可以用微信搜索“Java团长”或者“javatuanzhang”关注。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Springcloud各层框架注解含义]]></title>
    <link href="https://books.sangkf.cn/15509183306420.html"/>
    <updated>2019-02-23T18:38:50+08:00</updated>
    <id>https://books.sangkf.cn/15509183306420.html</id>
    <content type="html"><![CDATA[
<p>声明Bean的注解:</p>

<ul>
<li>@Component : 组件,没有明确的角色</li>
<li><a href="https://my.oschina.net/service">@Service</a> : 在业务逻辑层(service层)使用</li>
<li>@Repository : 在数据访问层(dao层)使用.</li>
<li><p><a href="https://my.oschina.net/u/1774615">@Controller</a> : 在展现层(MVC--SpringMVC)使用<br/>
<span id="more"></span><!-- more --><br/>
注入Bean的注解:</p></li>
<li><p>@Autowired : Spring提供的注解.</p></li>
<li><p>@Inject : JSR-330提供的注解</p></li>
<li><p>@Resource : JSR-250提供的注解</p></li>
</ul>

<p>配置文件的注解:</p>

<ul>
<li>@Configuration : 声明当前类是个配置类,相当于一个Spring配置的xml文件.</li>
<li>@ComponentScan (cn.test.demo): 自动扫描包名下所有使用 @Component @Service  @Repository @Controller 的类,并注册为Bean</li>
<li>@WiselyConfiguration : 组合注解 可以替代 @Configuration和@ComponentScan</li>
<li>@Bean : 注解在方法上,声明当前方法的返回值为一个Bean.</li>
<li>* @Bean(initMethod=&quot;aa&quot;,destroyMethod=&quot;bb&quot;)--&gt; 指定 aa和bb方法在构造之后.Bean销毁之前执行.</li>
</ul>

<p>AOP<a href="https://www.baidu.com/s?wd=%E5%88%87%E9%9D%A2&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd">切面</a>编程注解:</p>

<ul>
<li>@Aspect : 声明这是一个切面 </li>
<li>@After @Before. @Around 定义切面,可以直接将拦截规则(切入点 PointCut)作为参数</li>
<li>@PointCut : 专门定义拦截规则 然后在 @After @Before. @Around 中调用</li>
<li>@Transcational : 事务处理</li>
<li>@Cacheable : 数据缓存</li>
<li>@EnableAaspectJAutoProxy : 开启Spring 对 这个切面(Aspect )的支持</li>
<li>@Target (ElementType.TYPE):元注解,用来指定注解修饰类的那个成员 --&gt;指定拦截规则</li>
<li>@Retention(RetentionPolicy.RUNTIME) </li>
<li>* ---&gt;当定义的注解的@Retention为RUNTIME时，才能够通过运行时的反射机制来处理注解.--&gt;指定拦截规则</li>
</ul>

<p>Spring 常用配置:</p>

<ul>
<li>@import :导入配置类</li>
<li>@Scope : 新建Bean的实例 @Scope(&quot;prototype&quot;) 声明Scope 为 Prototype</li>
<li>@Value : 属性注入</li>
<li>* @Value (&quot;我爱你&quot;)  --&gt; 普通字符串注入
<ul>
<li>@Value (&quot;#{systemProperties[&#39;os.name&#39;]}&quot;) --&gt;注入操作系统属性</li>
<li>@Value (&quot;#{ T (java.lang.Math).random()  * 100.0 }&quot;) --&gt; 注入表达式结果</li>
<li>@Value (&quot;#{demoService.another}&quot;) --&gt; 注入其他Bean属性</li>
<li>@Value ( &quot;classpath:com/wisely/highlight_spring4/ch2/el/test.txt&quot; ) --&gt; 注入文件资源</li>
<li>@Value (&quot;<a href="http://www.baidu.com%22)--%3E%E6%B3%A8%E5%85%A5%E7%BD%91%E5%9D%80%E8%B5%84%E6%BA%90">http://www.baidu.com&quot;)--&gt;注入网址资源</a></li>
<li>@Value (&quot;\({book.name}&quot; ) --&gt; 注入配置文件  注意: 使用的是\) 而不是 #</li>
</ul></li>
<li>@PostConstruct : 在构造函数执行完之后执行</li>
<li>@PreDestroy  : 在 Bean 销毁之前执行</li>
<li>@ActiveProfiles : 用来声明活动的 profile</li>
<li>@profile: 为不同环境下使用不同的配置提供了支持</li>
<li>* @Profile(&quot;dev&quot;) .......对方法名为 dev-xxxx的方法提供实例化Bean</li>
<li>@EnableAsync : 开启异步任务的支持(多线程)</li>
<li>@Asyns : 声明这是一个异步任务,可以在类级别 和方法级别声明.</li>
<li>@EnableScheduling : 开启对计划任务的支持(定时器)</li>
<li>@Scheduled : 声明这是一个计划任务 支持多种计划任务,包含 cron. fixDelay fixRate</li>
<li>* @Scheduled (dixedDelay = 5000) 通过注解 定时更新</li>
<li>@Conditional : 条件注解,根据满足某一特定条件创建一个特定的Bean</li>
<li>@ContextConfiguration : 加载配置文件</li>
<li>* @ContextConfiguration(classes = {TestConfig.class})
<ul>
<li>@ContextConfiguration用来加载ApplicationContext </li>
<li>classes属性用来加载配置类</li>
</ul></li>
<li>@WebAppCofiguration : 指定加载 ApplicationContext是一个WebApplicationContext</li>
</ul>

<p>@Enable*注解:</p>

<ul>
<li>@EnableAsync : 开启异步任务的支持(多线程)</li>
<li>@EnableScheduling : 开启对计划任务的支持(定时器)</li>
<li>@EnableWebMVC : 开启对Web MVC 的配置支持</li>
<li>@EnableAaspectJAutoProxy : 开启Spring 对 这个切面(Aspect )的支持</li>
<li>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</li>
<li>@EnableJpaRepositories : 开启对Spring Data JAP Repository 的支持</li>
<li>@EnableTransactionManagement 开启对注解式事物的支持</li>
<li>@EnableCaching开启注解是缓存的支持.</li>
<li>@EnableDiscoveryClient 让服务发现服务器,使用服务器.Spring cloud 实现服务发现</li>
<li>@EnableEurekaServer 注册服务器 spring cloud 实现服务注册@</li>
<li>@EnableScheduling 让spring可以进行任务调度,功能类似于spring.xml文件中的命名空间</li>
<li>@EnableCaching 开启Cache缓存支持;</li>
</ul>

<p>SpringMVC 常用注解:</p>

<ul>
<li>@Controller : 注解在类上 声明这个类是springmvc里的Controller,将其声明为一个spring的Bean.</li>
<li>@RequestMapping :可以注解在类上和方法上 映射WEB请求(访问路径和参数)</li>
<li>* @RequestMapping(value= &quot;/convert&quot;,produces+{&quot;application/x-wisely&quot;}) 设置访问URL 返回值类型</li>
<li>@ResponseBody : 支持将返回值放入response体内 而不是返回一个页面(返回的是一个组数据)</li>
<li>@RequestBody : 允许request的参数在request体中,而不是直接连接在地址后面 次注解放置在参数前</li>
<li>@Path Variable : 用来接收路径参数 如/test/001,001为参数,次注解放置在参数前</li>
<li>@RestController : @Controller + @ResponseBody 组合注解</li>
<li>@ControllerAdvice : 通过@ControllerAdvice可以将对已控制器的全局配置放置在同一个位置</li>
<li>@ExceptionHandler : 用于全局处理控制器的异常</li>
<li>* @ExceptionHandier(value=Exception.class) --&gt;通过value属性可过滤拦截器条件,拦截所有的异常</li>
<li>@InitBinder : 用来设置WebDataBinder , WebDataBinder用来自动绑定前台请求参数到Model中.</li>
<li>@ModelAttrbuute : 绑定键值对到Model中,</li>
<li>@RunWith : 运行器 </li>
<li>* @RunWith(JUnit4.class)就是指用JUnit4来运行
<ul>
<li>@RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境</li>
<li>@RunWith(Suite.class)的话就是一套测试集合，</li>
</ul></li>
<li><p>@WebAppConfiguration(&quot;src/main/resources&quot;) : 注解在类上,用来声明加载的ApplicationContex 是一个WebApplicationContext ,它的属性指定的是Web资源的位置,默认为 src/main/webapp ,自定义修改为 resource</p></li>
<li><p>@Before : 在 xxx 前初始化</p></li>
</ul>

<p>Spring Boot 注解:</p>

<ul>
<li>@SpringBootApplication : 是Spring Boot 项目的核心注解 主要目的是开启自动配置</li>
<li>* @SpringBootApplication注解是一个组合注解,主要组合了@Configuration .+@EnableAutoConfiguration.+@ComponentScan</li>
<li>@Value : 属性注入,读取properties或者 Yml 文件中的属性</li>
<li>@ConfigurationProperties : 将properties属性和一个Bean及其属性关联,从而实现类型安全的配置</li>
<li>* @ConfigurationProperties(prefix = &quot;author&quot;,locations = {&quot;classpath:config/author.properties&quot;})
<ul>
<li>通过@ConfigurationProperties加载配置,通过prefix属性指定配置前缀,通过location指定配置文件位置</li>
</ul></li>
<li>@EnableAutoConfiguration 注解:作用在于让 Spring Boot   根据应用所声明的依赖来对 Spring 框架进行自动配置<br/>
        这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于<code>spring-boot-starter-web</code>添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。</li>
<li>@ Configuration @EnableAutoConfiguration (exclude={xxxx.class}) 禁用特定的自动配置</li>
<li>@SpringBootApplication   注解等价于以默认属性使用 @Configuration，@EnableAutoConfiguration和     @ComponentScan。</li>
</ul>

<p>@SuppressWarnings注解</p>

<ul>
<li>@SuppressWarnings(&quot;unchecked&quot;)</li>
<li>* 告诉编译器忽略 unchecked 警告信息,如使用 list ArrayList等未进行参数化产生的警告信息</li>
<li>@SuppressWarnings(&quot;serial&quot;)</li>
<li>* 如果编译器出现这样的警告信息: The serializable class WmailCalendar does not declare a static final serialVersionUID field of type long     使用这个注释将警告信息去掉。</li>
<li>@SuppressWarnings(&quot;deprecation&quot;)</li>
<li>* 如果使用了使用@Deprecated注释的方法，编译器将出现警告信息。使用这个注释将警告信息去掉。</li>
<li>@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)</li>
<li>* 告诉编译器同时忽略unchecked和deprecation的警告信息。</li>
<li>@SuppressWarnings(value={&quot;unchecked&quot;, &quot;deprecation&quot;})</li>
<li>* 等同于@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)</li>
</ul>

<p>案例</p>

<pre><code class="language-java">@Entity

@Table(name = &quot;S_PRODUCEINFO&quot; )

@Data

@NoArgsConstructor

@AllArgsConstructor

public class ProduceInfoEntity {

    @Id

    @Column(name = &quot;app_name&quot;, unique = true, length = 50)

    private String name;

    @Column(name = &quot;status&quot;)

    @Enumerated(EnumType. STRING)

    private ProduceStatus status;

    @Column(name = &quot;create_time&quot;, updatable = false)

    @Temporal(TemporalType. TIMESTAMP)

    @CreationTimestamp

    private Date createTime;

    @Column(name = &quot;update_time&quot;)

    @Temporal(TemporalType. TIMESTAMP)

    @UpdateTimestamp

    private Date updateTime;
}
</code></pre>

<p>@Entity : 映射数据库实体类</p>

<p>@Table(name = &quot;S_PRODUCEINFO&quot; ) : 表名为 &quot;S_PRODUCEINFO&quot;</p>

<p>@Id : 声明主键ID</p>

<p>@Column(name = &quot;app_name&quot;, unique = true, length = 50) :对应数据库字段,属性</p>

<p>@Enumerated(EnumType. STRING) : 采用枚举值类型和数据库字段进行交互  </p>

<p>@Temporal : 时间格式 映射数据库会得到规定时间格式的日期</p>

<p>       @Enumerted(EnumType.STRING)  HH:MM:SS 格式的日期</p>

<p>       @Enumerted(EnumType.DATE) 获取年月日  yyyy-MM-dd </p>

<p>       @Enumerted(EnumType.TIME) 获取时分秒  HH:MM:</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAVA8新特性]]></title>
    <link href="https://books.sangkf.cn/15509161097880.html"/>
    <updated>2019-02-23T18:01:49+08:00</updated>
    <id>https://books.sangkf.cn/15509161097880.html</id>
    <content type="html"><![CDATA[
<p>原文地址 <a href="https://www.cnblogs.com/huyunfan/p/7456535.html">https://www.cnblogs.com/huyunfan/p/7456535.html</a></p>

<ul>
<li><p><strong>default拓展方法</strong></p>
<p>default关键字为接口声明添加非抽象方法的实现,也称为拓展方法<br/>
<span id="more"></span><!-- more --></p>
<pre><code class="language-java">public interface Formula {
  void doSomething();<br/>
  default void before() {<br/>
      System.out.println(&quot;我是拓展方法&quot;);<br/>
  }<br/>
}<br/>
public class FormulaService implements Formula {<br/>
  @Override<br/>
  public void doSomething() {<br/>
      before();<br/>
      System.out.println(&quot;我是override方法&quot;);<br/>
  }<br/>
}
</code></pre></li>
<li><p><strong>Lambda表达式</strong></p>
<p>java8引入函数式编程，Lambda则是函数式编程的基础。</p>
<pre><code class="language-java">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
// java8之前<br/>
Collections.sort(list, new Comparator&lt;String&gt;(){<br/>
  @Override<br/>
  public int compare(String o1, String o2) {<br/>
      return o1.compareTo(o2);<br/>
  }<br/>
});<br/>
// lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt; {<br/>
          return o2.compareTo(o1);<br/>
});<br/>
// 简洁lambda<br/>
Collections.sort(list, (String o1, String o2) -&gt;  o2.compareTo(o1));<br/>
// 更简洁lambda<br/>
Collections.sort(list, (o1, o2) -&gt;  o2.compareTo(o1));<br/>
// 也可以这样写<br/>
Collections.sort(list, Comparator.comparing(String::toString));
</code></pre></li>
<li><p><strong>函数式接口</strong></p>
<p>一个函数式接口有且只能有一个抽象方法申明，其中该注意的是 @FunctionalInterface 注解，此时如果在接口中定义了第二个抽象方法，编译器将会抛出异常。当然如果不加该注解也不是不行，如果接口中有多个抽象方法，而你又使用了lambda表达式，则在调用处会抛出异常。</p>
<pre><code class="language-java">@FunctionalInterface
public interface Formula&lt;F,T&gt;{<br/>
  T convert(F var1);<br/>
}<br/>
Formula&lt;String,Integer&gt; function = (var1 -&gt; Integer.valueOf(var1));<br/>
Integer var2 = function.convert(&quot;1000&quot;); 
</code></pre></li>
<li><p><strong>方法和构造函数引用</strong></p>
<p>方法引用的标准语法是 <code>类名:方法名</code></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用静态方法</td>
<td>targetClass :: staticMethodName</td>
</tr>
<tr>
<td>引用某个对象的实例方法</td>
<td>targetClass :: instanceMethodName</td>
</tr>
<tr>
<td>引用某个类型的任意对象的实例方法</td>
<td>targetType :: methodName</td>
</tr>
<tr>
<td>引用构造方法</td>
<td>className :: new</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>引用静态方法</strong></li>
</ol>
<pre><code class="language-java">Formula&lt;String,Integer&gt; function = (Integer::valueOf);
Integer var2 = function.convert(&quot;1000&quot;);
</code></pre>
<ol>
<li><strong>引用某个类型的任意对象的实例方法</strong></li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
   String[] array = {&quot;贱明&quot;, &quot;学友&quot;};<br/>
   Arrays.sort(array, String::compareTo);<br/>
}
</code></pre>
<ol>
<li><strong>引用构造方法</strong></li>
</ol>
<pre><code class="language-java">// 定义工厂
interface PersonFactory&lt;P extends Person&gt;{<br/>
    P create(String name);<br/>
}<br/>
// Person类的构造方法<br/>
public Person(String name) {<br/>
    this.name = name;<br/>
}<br/>
// 创建<br/>
PersonFactory&lt;Person&gt; factory = Person::new;<br/>
factory.create(&quot;贱明&quot;);
</code></pre></li>
<li><p><strong>Lambda的范围</strong></p>
<p>lambda可以访问局部对应的外部区域的局部final变量，以及成员变量和静态变量。</p>
<ol>
<li><p><strong>访问成员变量</strong></p>
<pre><code class="language-java">public void doSomething(){
 final String p1 = &quot;贱明&quot;;<br/>
 final String p2 = &quot;学友&quot;;<br/>
 Formula function = (person1, person2) -&gt; p1.compareTo(p2);<br/>
}
</code></pre>
<p>与java8以下版本不同的是，p1 p2你可以不修饰成final 也不会报错，但是如果你想修改他们，编译器则会告诉你这是不被允许的。</p></li>
<li><p><strong>访问成员变量和静态变量</strong></p>
<pre><code class="language-java">public void doSomething(){;
Formula function = (person1, person2) -&gt;{<br/>
    dehua = &quot;贱明&quot;;<br/>
    xueyou=&quot;学友&quot;;<br/>
    return dehua.compareTo(xueyou);<br/>
};<br/>
}
</code></pre></li>
</ol></li>
<li><p><strong>内置函数式接口</strong></p>
<p>​     java8 api中提供了很多内置函数式接口，而且有些接口其实在Google Guava中已经实现了，很大程  度的降低了程序员的工作负担。</p>
<ol>
<li><p><strong>Predicates</strong><br/>
Predicate是一个布尔类型的函数，该函数只有一个输入参数，他包含了多种默认实现。</p>
<pre><code class="language-java">public static void main(String[] args) {
Predicate&lt;String&gt; predicate = (s) -&gt; s.contains(&quot;贱明&quot;);<br/>
String var1 = &quot;牛贱明&quot;;<br/>
predicate.test(var1);              // true<br/>
predicate.negate().test(var1);     // false<br/>
Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;<br/>
Predicate&lt;Boolean&gt; isNull = Objects::isNull;<br/>
Predicate&lt;String&gt; isEmpty = String::isEmpty;<br/>
Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();<br/>
isNotEmpty.and(isEmpty).test(var1);<br/>
}
</code></pre></li>
<li><p><strong>Functions</strong></p>
<p>Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起</p>
<pre><code class="language-java">public static void main(String[] args) {
Function&lt;String, Integer&gt; toInteger = Integer::valueOf;<br/>
Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);<br/>
System.out.println(toInteger.apply(&quot;123&quot;));<br/>
System.out.println(backToString.apply(&quot;123&quot;));<br/>
}
</code></pre></li>
<li><p><strong>Suppliers</strong></p>
<p>Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。</p>
<pre><code class="language-java">Supplier&lt;Person&gt; personSupplier = Person::new;
Person p = personSupplier.get();   // new Person
</code></pre></li>
<li><p><strong>Consumers</strong></p>
<p>Consumer代表了在一个输入参数上需要进行的操作。</p>
<pre><code class="language-java">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.getName());
greeter.accept(new Person(&quot;贱明&quot;));
</code></pre></li>
<li><p><strong>Comparators</strong></p>
<p>Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。</p>
<pre><code class="language-java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.getName().compareTo(p2.getName());
Person p1 = new Person(&quot;贱明&quot;);<br/>
Person p2 = new Person(&quot;学友&quot;);<br/>
System.out.println(comparator.compare(p1, p2));             // &gt; 1105<br/>
System.out.println(comparator.reversed().compare(p1, p2));  // &lt; -1105
</code></pre></li>
<li><p><strong>Optionals</strong></p>
<p>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerException产生。<br/>
Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional。</p>
<pre><code class="language-java">Optional&lt;String&gt; optional = Optional.of(&quot;贱明&quot;);
System.out.println(optional.isPresent()); // true      <br/>
System.out.println(optional.get()); // 贱明   <br/>
System.out.println(optional.orElse(&quot;学友&quot;)); // 贱明    <br/>
optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); 
</code></pre></li>
</ol></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[h5仿微信聊天(高仿版)、微信聊天表情|对话框|编辑器]]></title>
    <link href="https://books.sangkf.cn/15508991872164.html"/>
    <updated>2019-02-23T13:19:47+08:00</updated>
    <id>https://books.sangkf.cn/15508991872164.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>转载 <a href="https://www.cnblogs.com/xiaoyan2017/p/8912054.html">https://www.cnblogs.com/xiaoyan2017/p/8912054.html</a></p>
</blockquote>

<p>之前做过一版h5微信聊天移动端，这段时间闲来无事就整理了下之前项目，又重新在原先的那版基础上升级了下，如是就有了现在的h5仿微信聊天高仿版，新增了微聊、通讯录、探索、我四个模块 左右触摸滑屏切换，聊天页面优化了多图预览、视频播放，长按菜单UI，聊天底部编辑器重新优化整理(新增多表情)，弹窗则用到了自己开发的wcPop.js，具体看项目效果图吧！<br/>
<span id="more"></span><!-- more --></p>

<pre><code class="language-markup">&lt;!-- //微聊底部功能面板 --&gt;
&lt;div class=&quot;wc__footTool-panel&quot;&gt;
    &lt;!-- 输入框模块 --&gt;
    &lt;div class=&quot;wc__editor-panel wc__borT flexbox&quot;&gt;
        &lt;div class=&quot;wrap-editor flex1&quot;&gt;&lt;div class=&quot;editor J__wcEditor&quot; contenteditable=&quot;true&quot;&gt;&lt;/div&gt;&lt;/div&gt;
        &lt;i class=&quot;btn btn-emotion&quot;&gt;&lt;/i&gt;
        &lt;i class=&quot;btn btn-choose&quot;&gt;&lt;/i&gt;
        &lt;button class=&quot;btn-submit J__wchatSubmit&quot;&gt;发送&lt;/button&gt;
    &lt;/div&gt;

    &lt;!-- 表情、选择模块 --&gt;
    &lt;div class=&quot;wc__choose-panel wc__borT&quot; style=&quot;display: none;&quot;&gt;
        &lt;!-- 表情区域 --&gt;
        &lt;div class=&quot;wrap-emotion&quot; style=&quot;display: none;&quot;&gt;
            &lt;div class=&quot;emotion__cells flexbox flex__direction-column&quot;&gt;
                &lt;div class=&quot;emotion__cells-swiper flex1&quot; id=&quot;J__swiperEmotion&quot;&gt;
                    &lt;div class=&quot;swiper-container&quot;&gt;
                        &lt;div class=&quot;swiper-wrapper&quot;&gt;&lt;/div&gt;
                        &lt;div class=&quot;pagination-emotion&quot;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;emotion__cells-footer&quot; id=&quot;J__emotionFootTab&quot;&gt;
                    &lt;ul class=&quot;clearfix&quot;&gt;
                        &lt;li class=&quot;swiperTmpl cur&quot; tmpl=&quot;swiper__tmpl-emotion01&quot;&gt;&lt;img src=&quot;img/emotion/face01/face-lbl.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion02&quot;&gt;&lt;img src=&quot;img/emotion/face02/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion03&quot;&gt;&lt;img src=&quot;img/emotion/face03/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion04&quot;&gt;&lt;img src=&quot;img/emotion/face04/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion05&quot;&gt;&lt;img src=&quot;img/emotion/face05/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmpl&quot; tmpl=&quot;swiper__tmpl-emotion06&quot;&gt;&lt;img src=&quot;img/emotion/face06/face-lbl.gif&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                        &lt;li class=&quot;swiperTmplSet&quot;&gt;&lt;img src=&quot;img/wchat/icon__emotion-set.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 选择区域 --&gt;
        &lt;div class=&quot;wrap-choose&quot; style=&quot;display: none;&quot;&gt;
            &lt;div class=&quot;choose__cells&quot;&gt;
                &lt;ul class=&quot;clearfix&quot;&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatZp&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-zp.png&quot; /&gt;&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; /&gt;&lt;/span&gt;&lt;em&gt;照片&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatSp&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-sp.png&quot; /&gt;&lt;input type=&quot;file&quot; accept=&quot;video/*&quot; /&gt;&lt;/span&gt;&lt;em&gt;视频&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatHb&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-hb.png&quot; /&gt;&lt;/span&gt;&lt;em&gt;红包&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatSc&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-sc.png&quot; /&gt;&lt;/span&gt;&lt;em&gt;我的收藏&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a class=&quot;J__wchatWj&quot; href=&quot;javascript:;&quot;&gt;&lt;span class=&quot;img&quot;&gt;&lt;img src=&quot;img/wchat/icon__choose-wj.png&quot; /&gt;&lt;/span&gt;&lt;em&gt;文件&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;wc__choosePanel-tmpl&quot;&gt;
    &lt;!-- //红包模板.begin --&gt;
    &lt;div id=&quot;J__popupTmpl-Hongbao&quot; style=&quot;display:none;&quot;&gt;
        &lt;div class=&quot;wc__popupTmpl tmpl-hongbao&quot;&gt;
            &lt;i class=&quot;wc-xclose&quot;&gt;&lt;/i&gt;
            &lt;ul class=&quot;clearfix&quot;&gt;
                &lt;li class=&quot;item flexbox&quot;&gt;
                    &lt;label class=&quot;txt&quot;&gt;总金额&lt;/label&gt;&lt;input class=&quot;ipt-txt flex1&quot; type=&quot;tel&quot; name=&quot;hbAmount&quot; placeholder=&quot;0.00&quot; /&gt;&lt;em class=&quot;unit&quot;&gt;元&lt;/em&gt;
                &lt;/li&gt;
                &lt;li class=&quot;item flexbox&quot;&gt;
                    &lt;label class=&quot;txt&quot;&gt;红包个数&lt;/label&gt;&lt;input class=&quot;ipt-txt flex1&quot; type=&quot;tel&quot; name=&quot;hbNum&quot; placeholder=&quot;填写个数&quot; /&gt;&lt;em class=&quot;unit&quot;&gt;个&lt;/em&gt;
                &lt;/li&gt;
                &lt;li class=&quot;tips&quot;&gt;在线人数共&lt;em class=&quot;memNum&quot;&gt;186&lt;/em&gt;人&lt;/li&gt;
                &lt;li class=&quot;item item-area&quot;&gt;
                    &lt;textarea class=&quot;describe&quot; name=&quot;content&quot; placeholder=&quot;恭喜发财，大吉大利&quot;&gt;&lt;/textarea&gt;
                &lt;/li&gt;
                &lt;li class=&quot;amountTotal&quot;&gt;￥&lt;em class=&quot;num&quot;&gt;0.00&lt;/em&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- //红包模板.end --&gt;
&lt;/div&gt;
</code></pre>

<pre><code class="language-javascript">// ...长按弹出菜单
$(&quot;#J__chatMsgList&quot;).on(&quot;longTap&quot;, &quot;li .msg&quot;, function(e){
    var that = $(this), menuTpl, menuNode = $(&quot;&lt;div class=&#39;wc__chatTapMenu animated anim-fadeIn&#39;&gt;&lt;/div&gt;&quot;);
    that.addClass(&quot;taped&quot;);
    that.parents(&quot;li&quot;).siblings().find(&quot;.msg&quot;).removeClass(&quot;taped&quot;);
    var isRevoke = that.parents(&quot;li&quot;).hasClass(&quot;me&quot;);
    var _revoke = isRevoke ? &quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i4&#39;&gt;&lt;/i&gt;撤回&lt;/a&gt;&quot; : &quot;&quot;;
    
    if(that.hasClass(&quot;picture&quot;)){
        console.log(&quot;图片长按&quot;);
        menuTpl = &quot;&lt;div class=&#39;menu menu-picture&#39;&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i1&#39;&gt;&lt;/i&gt;复制&lt;/a&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i2&#39;&gt;&lt;/i&gt;收藏&lt;/a&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i3&#39;&gt;&lt;/i&gt;另存为&lt;/a&gt;&quot;+ _revoke +&quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i5&#39;&gt;&lt;/i&gt;删除&lt;/a&gt;&lt;/div&gt;&quot;;
    }else if(that.hasClass(&quot;video&quot;)){
        console.log(&quot;视频长按&quot;);
        menuTpl = &quot;&lt;div class=&#39;menu menu-video&#39;&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i3&#39;&gt;&lt;/i&gt;另存为&lt;/a&gt;&quot; + _revoke +&quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i5&#39;&gt;&lt;/i&gt;删除&lt;/a&gt;&lt;/div&gt;&quot;;
    }else{
        console.log(&quot;文字长按&quot;);
        menuTpl = &quot;&lt;div class=&#39;menu menu-text&#39;&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i1&#39;&gt;&lt;/i&gt;复制&lt;/a&gt;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i2&#39;&gt;&lt;/i&gt;收藏&lt;/a&gt;&quot; + _revoke +&quot;&lt;a href=&#39;#&#39;&gt;&lt;i class=&#39;ico i5&#39;&gt;&lt;/i&gt;删除&lt;/a&gt;&lt;/div&gt;&quot;;
    }

    if(!$(&quot;.wc__chatTapMenu&quot;).length){
        $(&quot;.wc__chatMsg-panel&quot;).append(menuNode.html(menuTpl));
        autoPos();
    }else{
        $(&quot;.wc__chatTapMenu&quot;).hide().html(menuTpl).fadeIn(250);
        autoPos();
    }

    function autoPos(){
        console.log(that.position().top)
        var _other = that.parents(&quot;li&quot;).hasClass(&quot;others&quot;);
        $(&quot;.wc__chatTapMenu&quot;).css({
            position: &quot;absolute&quot;,
            left: that.position().left + parseInt(that.css(&quot;marginLeft&quot;)) + (_other ? 0 : that.outerWidth() - $(&quot;.wc__chatTapMenu&quot;).outerWidth()),
            top: that.position().top - $(&quot;.wc__chatTapMenu&quot;).outerHeight() - 8
        });
    }
});
</code></pre>

<p><img src="media/15508991872164/15508994793999.jpg" alt=""/><br/>
<img src="media/15508991872164/15508994870198.jpg" alt=""/><br/>
<img src="media/15508991872164/15508994947946.jpg" alt=""/><br/>
<img src="media/15508991872164/15508995011000.jpg" alt=""/><br/>
<img src="media/15508991872164/15508995078981.jpg" alt=""/><br/>
<img src="media/15508991872164/15508995144669.jpg" alt=""/><br/>
<img src="media/15508991872164/15508995204276.jpg" alt=""/><br/>
<img src="media/15508991872164/15508995255771.jpg" alt=""/><br/>
<img src="media/15508991872164/15508995347731.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[欢迎使用 MWeb]]></title>
    <link href="https://books.sangkf.cn/15474356181402.html"/>
    <updated>2019-01-14T11:13:38+08:00</updated>
    <id>https://books.sangkf.cn/15474356181402.html</id>
    <content type="html"><![CDATA[
<p>MWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件，目前已支持 Mac，iPad 和 iPhone。MWeb 有以下特色：<br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_0">软件本身：</h2>

<ul>
<li>使用原生的 macOS 技术打造，追求与系统的完美结合。</li>
<li>原则上，首先是追求界面简洁和高性能，然后才是强大易用，功能全面。</li>
</ul>

<h2 id="toc_1">Markdown 语法：</h2>

<ul>
<li>使用 Github Flavored Markdown 语法，简称 GFM 语法。</li>
<li>支持表格、TOC、LaTeX、代码块、任务列表、脚注等。</li>
<li>画图库支持 mermaid, viz, echarts, plantuml, sequence, flow。</li>
</ul>

<h2 id="toc_2">Markdown 辅助：</h2>

<ul>
<li>支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。</li>
<li>在兼容 Markdown 语法的情况下支持设置图片宽度。</li>
<li>好用的表格插入和 LaTeX 书写辅助。</li>
</ul>

<h2 id="toc_3">Markdown 输出：</h2>

<ul>
<li>支持导出为图片、HTML、Epub、PDF、RTF、Docx。</li>
<li>支持发布到 Wordrpess、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记（Evernote）、Blogger、Medium、Tumblr。</li>
<li>图片上传服务（图床）支持 Google Photos、Imgur、七牛云、又拍云和自定义的图床服务。</li>
</ul>

<h2 id="toc_4">Markdown 笔记：</h2>

<ul>
<li>强大的文档库支持分类树和标签管理文档，文档可归类于多个分类，可以把分类整个导出为 Epub、PDF 和生成静态网站。非常合适用于笔记、个人知识收集、管理和输出。</li>
<li>快速笔记：随意增加笔记及图片等素材，支持以天为单位把增加的素材组合在一个文档内，方便整理及记录历史收集情况。</li>
<li>快速搜索：目前已支持全局快捷键调出搜索。</li>
</ul>

<h2 id="toc_5">外部 Markdown 文档：</h2>

<ul>
<li>外部 Markdown 文档使用外部模式管理。外部模式使用目录树的方式编辑和管理你的 markdown 文档，还能很好的支持 gitbook、JekyII、hexo 等等编辑和图片插入。</li>
</ul>

<h2 id="toc_6">MWeb 文档：</h2>

<p>如果要更详细了解 MWeb，建议你一定要去看一下官网的帮助文档，网址为：<a href="https://zh.mweb.im/help.html">https://zh.mweb.im/help.html</a>。我们建议在使用文档库之前，一定要阅读一下  <a href="https://zh.mweb.im/mweb-library.html">MWeb 文档库详细介绍</a> 这篇文章，以便更好的使用文档库。</p>

<h2 id="toc_7">帮助我们改进 MWeb</h2>

<p>如果你喜欢 MWeb，想让它变得更好，你可以：</p>

<ol>
<li>推荐 MWeb，让更多的人知道。</li>
<li>给我们发反馈和建议：<a href="mailto:coderforart+2333@gmail.com">coderforart+2333@gmail.com</a></li>
<li>在 Mac App Store 上评价 （如果是在 MAS 上购买的话）。</li>
</ol>

]]></content>
  </entry>
  
</feed>
